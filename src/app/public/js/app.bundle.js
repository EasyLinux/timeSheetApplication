/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\n__webpack_require__(1);\n\n__webpack_require__(4);\n\nvar _app = __webpack_require__(6);\n\nvar models = __webpack_require__(7); // var req = require.context(\"../client-app\", true, /^(.*\\.(js$))[^.]*$/igm);\n// req.keys().forEach(function(key){\n//     req(key);\n// });\n\nmodels.keys().forEach(function (key) {\n    models(key);\n});\n\nvar collections = __webpack_require__(16);\ncollections.keys().forEach(function (key) {\n    collections(key);\n});\n\nvar views = __webpack_require__(19);\nviews.keys().forEach(function (key) {\n    views(key);\n});\n\nwindow.onload = function () {\n    _app.app.init();\n};\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvZW50cnkuanM/ODJkZSJdLCJuYW1lcyI6WyJtb2RlbHMiLCJrZXlzIiwiZm9yRWFjaCIsImtleSIsImNvbGxlY3Rpb25zIiwidmlld3MiLCJ3aW5kb3ciLCJvbmxvYWQiLCJpbml0Il0sIm1hcHBpbmdzIjoiOztBQUtBOztBQUNBOztBQUNBOztBQUVBLElBQUlBLFNBQVMsc0JBQWIsQyxDQVRBO0FBQ0E7QUFDQTtBQUNBOztBQU9BQSxPQUFPQyxJQUFQLEdBQWNDLE9BQWQsQ0FBc0IsVUFBU0MsR0FBVCxFQUFhO0FBQy9CSCxXQUFPRyxHQUFQO0FBQ0gsQ0FGRDs7QUFJQSxJQUFJQyxjQUFjLHVCQUFsQjtBQUNBQSxZQUFZSCxJQUFaLEdBQW1CQyxPQUFuQixDQUEyQixVQUFTQyxHQUFULEVBQWE7QUFDcENDLGdCQUFZRCxHQUFaO0FBQ0gsQ0FGRDs7QUFJQSxJQUFJRSxRQUFRLHVCQUFaO0FBQ0FBLE1BQU1KLElBQU4sR0FBYUMsT0FBYixDQUFxQixVQUFTQyxHQUFULEVBQWE7QUFDOUJFLFVBQU1GLEdBQU47QUFDSCxDQUZEOztBQUlBRyxPQUFPQyxNQUFQLEdBQWdCLFlBQVc7QUFDMUIsYUFBSUMsSUFBSjtBQUNBLENBRkQiLCJmaWxlIjoiMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHZhciByZXEgPSByZXF1aXJlLmNvbnRleHQoXCIuLi9jbGllbnQtYXBwXCIsIHRydWUsIC9eKC4qXFwuKGpzJCkpW14uXSokL2lnbSk7XG4vLyByZXEua2V5cygpLmZvckVhY2goZnVuY3Rpb24oa2V5KXtcbi8vICAgICByZXEoa2V5KTtcbi8vIH0pO1xuXG5pbXBvcnQgJ3NjcmlwdCFqcXVlcnknO1xuaW1wb3J0ICdzY3JpcHQhZm91bmRhdGlvbi1zaXRlcyc7XG5pbXBvcnQgeyBhcHAgfSBmcm9tICcuLi9jbGllbnQtYXBwL2FwcC5qcyc7XG5cbnZhciBtb2RlbHMgPSByZXF1aXJlLmNvbnRleHQoXCIuLi9jbGllbnQtYXBwL21vZGVsc1wiLCB0cnVlLCAvXiguKlxcLihqcyQpKVteLl0qJC9pZ20pO1xubW9kZWxzLmtleXMoKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7XG4gICAgbW9kZWxzKGtleSk7XG59KTtcblxudmFyIGNvbGxlY3Rpb25zID0gcmVxdWlyZS5jb250ZXh0KFwiLi4vY2xpZW50LWFwcC9jb2xsZWN0aW9uc1wiLCB0cnVlLCAvXiguKlxcLihqcyQpKVteLl0qJC9pZ20pO1xuY29sbGVjdGlvbnMua2V5cygpLmZvckVhY2goZnVuY3Rpb24oa2V5KXtcbiAgICBjb2xsZWN0aW9ucyhrZXkpO1xufSk7XG5cbnZhciB2aWV3cyA9IHJlcXVpcmUuY29udGV4dChcIi4uL2NsaWVudC1hcHAvdmlld3NcIiwgdHJ1ZSwgL14oLipcXC4oanMkKSlbXi5dKiQvaWdtKTtcbnZpZXdzLmtleXMoKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSl7XG4gICAgdmlld3Moa2V5KTtcbn0pO1xuXG53aW5kb3cub25sb2FkID0gZnVuY3Rpb24oKSB7XG5cdGFwcC5pbml0KCk7XG59XG5cblxuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2FwcC9jbGllbnQtYXBwL2VudHJ5LmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(3)+\"\\n\\n// SCRIPT-LOADER FOOTER\\n//# sourceURL=script:///Users/carterwooten/Sites/timeSheetApplication/node_modules/null-loader/index.js!/Users/carterwooten/Sites/timeSheetApplication/node_modules/jquery/dist/jquery.js\")\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5qcz85YjliIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJyZXF1aXJlKFwiISEvVXNlcnMvY2FydGVyd29vdGVuL1NpdGVzL3RpbWVTaGVldEFwcGxpY2F0aW9uL25vZGVfbW9kdWxlcy9zY3JpcHQtbG9hZGVyL2FkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISEvVXNlcnMvY2FydGVyd29vdGVuL1NpdGVzL3RpbWVTaGVldEFwcGxpY2F0aW9uL25vZGVfbW9kdWxlcy9yYXctbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9jYXJ0ZXJ3b290ZW4vU2l0ZXMvdGltZVNoZWV0QXBwbGljYXRpb24vbm9kZV9tb2R1bGVzL251bGwtbG9hZGVyL2luZGV4LmpzIS9Vc2Vycy9jYXJ0ZXJ3b290ZW4vU2l0ZXMvdGltZVNoZWV0QXBwbGljYXRpb24vbm9kZV9tb2R1bGVzL2pxdWVyeS9kaXN0L2pxdWVyeS5qc1wiKStcIlxcblxcbi8vIFNDUklQVC1MT0FERVIgRk9PVEVSXFxuLy8jIHNvdXJjZVVSTD1zY3JpcHQ6Ly8vVXNlcnMvY2FydGVyd29vdGVuL1NpdGVzL3RpbWVTaGVldEFwcGxpY2F0aW9uL25vZGVfbW9kdWxlcy9udWxsLWxvYWRlci9pbmRleC5qcyEvVXNlcnMvY2FydGVyd29vdGVuL1NpdGVzL3RpbWVTaGVldEFwcGxpY2F0aW9uL25vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanNcIilcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9qcXVlcnkvZGlzdC9qcXVlcnkuanNcbiAqKiBtb2R1bGUgaWQgPSAxXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 2 */
/***/ function(module, exports) {

	eval("/*\r\n\tMIT License http://www.opensource.org/licenses/mit-license.php\r\n\tAuthor Tobias Koppers @sokra\r\n*/\r\nmodule.exports = function(src) {\r\n\tif (typeof execScript !== \"undefined\")\r\n\t\texecScript(src);\r\n\telse\r\n\t\teval.call(null, src);\r\n}\r\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzPzgxMDciXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3JjKSB7XHJcblx0aWYgKHR5cGVvZiBleGVjU2NyaXB0ICE9PSBcInVuZGVmaW5lZFwiKVxyXG5cdFx0ZXhlY1NjcmlwdChzcmMpO1xyXG5cdGVsc2VcclxuXHRcdGV2YWwuY2FsbChudWxsLCBzcmMpO1xyXG59XHJcblxuXG5cbi8qKioqKioqKioqKioqKioqKlxuICoqIFdFQlBBQ0sgRk9PVEVSXG4gKiogLi9+L3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXG4gKiogbW9kdWxlIGlkID0gMlxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 3 */
/***/ function(module, exports) {

	eval("module.exports = \"// empty (null-loader)\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5qcz9lZTA5Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBIiwiZmlsZSI6IjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiLy8gZW1wdHkgKG51bGwtbG9hZGVyKVwiXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL34vcmF3LWxvYWRlciEuL34vbnVsbC1sb2FkZXIhLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5qc1xuICoqIG1vZHVsZSBpZCA9IDNcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	eval("__webpack_require__(2)(__webpack_require__(5)+\"\\n\\n// SCRIPT-LOADER FOOTER\\n//# sourceURL=script:///Users/carterwooten/Sites/timeSheetApplication/node_modules/foundation-sites/dist/foundation.js\")\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9mb3VuZGF0aW9uLmpzP2QyOWUiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiNC5qcyIsInNvdXJjZXNDb250ZW50IjpbInJlcXVpcmUoXCIhIS9Vc2Vycy9jYXJ0ZXJ3b290ZW4vU2l0ZXMvdGltZVNoZWV0QXBwbGljYXRpb24vbm9kZV9tb2R1bGVzL3NjcmlwdC1sb2FkZXIvYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIS9Vc2Vycy9jYXJ0ZXJ3b290ZW4vU2l0ZXMvdGltZVNoZWV0QXBwbGljYXRpb24vbm9kZV9tb2R1bGVzL3Jhdy1sb2FkZXIvaW5kZXguanMhL1VzZXJzL2NhcnRlcndvb3Rlbi9TaXRlcy90aW1lU2hlZXRBcHBsaWNhdGlvbi9ub2RlX21vZHVsZXMvZm91bmRhdGlvbi1zaXRlcy9kaXN0L2ZvdW5kYXRpb24uanNcIikrXCJcXG5cXG4vLyBTQ1JJUFQtTE9BREVSIEZPT1RFUlxcbi8vIyBzb3VyY2VVUkw9c2NyaXB0Oi8vL1VzZXJzL2NhcnRlcndvb3Rlbi9TaXRlcy90aW1lU2hlZXRBcHBsaWNhdGlvbi9ub2RlX21vZHVsZXMvZm91bmRhdGlvbi1zaXRlcy9kaXN0L2ZvdW5kYXRpb24uanNcIilcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvZm91bmRhdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDRcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 5 */
/***/ function(module, exports) {

	eval("module.exports = \"!function ($) {\\n\\n  \\\"use strict\\\";\\n\\n  var FOUNDATION_VERSION = '6.2.3';\\n\\n  // Global Foundation object\\n  // This is attached to the window, or used as a module for AMD/Browserify\\n  var Foundation = {\\n    version: FOUNDATION_VERSION,\\n\\n    /**\\n     * Stores initialized plugins.\\n     */\\n    _plugins: {},\\n\\n    /**\\n     * Stores generated unique ids for plugin instances\\n     */\\n    _uuids: [],\\n\\n    /**\\n     * Returns a boolean for RTL support\\n     */\\n    rtl: function () {\\n      return $('html').attr('dir') === 'rtl';\\n    },\\n    /**\\n     * Defines a Foundation plugin, adding it to the `Foundation` namespace and the list of plugins to initialize when reflowing.\\n     * @param {Object} plugin - The constructor of the plugin.\\n     */\\n    plugin: function (plugin, name) {\\n      // Object key to use when adding to global Foundation object\\n      // Examples: Foundation.Reveal, Foundation.OffCanvas\\n      var className = name || functionName(plugin);\\n      // Object key to use when storing the plugin, also used to create the identifying data attribute for the plugin\\n      // Examples: data-reveal, data-off-canvas\\n      var attrName = hyphenate(className);\\n\\n      // Add to the Foundation object and the plugins list (for reflowing)\\n      this._plugins[attrName] = this[className] = plugin;\\n    },\\n    /**\\n     * @function\\n     * Populates the _uuids array with pointers to each individual plugin instance.\\n     * Adds the `zfPlugin` data-attribute to programmatically created plugins to allow use of $(selector).foundation(method) calls.\\n     * Also fires the initialization event for each plugin, consolidating repetitive code.\\n     * @param {Object} plugin - an instance of a plugin, usually `this` in context.\\n     * @param {String} name - the name of the plugin, passed as a camelCased string.\\n     * @fires Plugin#init\\n     */\\n    registerPlugin: function (plugin, name) {\\n      var pluginName = name ? hyphenate(name) : functionName(plugin.constructor).toLowerCase();\\n      plugin.uuid = this.GetYoDigits(6, pluginName);\\n\\n      if (!plugin.$element.attr('data-' + pluginName)) {\\n        plugin.$element.attr('data-' + pluginName, plugin.uuid);\\n      }\\n      if (!plugin.$element.data('zfPlugin')) {\\n        plugin.$element.data('zfPlugin', plugin);\\n      }\\n      /**\\n       * Fires when the plugin has initialized.\\n       * @event Plugin#init\\n       */\\n      plugin.$element.trigger('init.zf.' + pluginName);\\n\\n      this._uuids.push(plugin.uuid);\\n\\n      return;\\n    },\\n    /**\\n     * @function\\n     * Removes the plugins uuid from the _uuids array.\\n     * Removes the zfPlugin data attribute, as well as the data-plugin-name attribute.\\n     * Also fires the destroyed event for the plugin, consolidating repetitive code.\\n     * @param {Object} plugin - an instance of a plugin, usually `this` in context.\\n     * @fires Plugin#destroyed\\n     */\\n    unregisterPlugin: function (plugin) {\\n      var pluginName = hyphenate(functionName(plugin.$element.data('zfPlugin').constructor));\\n\\n      this._uuids.splice(this._uuids.indexOf(plugin.uuid), 1);\\n      plugin.$element.removeAttr('data-' + pluginName).removeData('zfPlugin')\\n      /**\\n       * Fires when the plugin has been destroyed.\\n       * @event Plugin#destroyed\\n       */\\n      .trigger('destroyed.zf.' + pluginName);\\n      for (var prop in plugin) {\\n        plugin[prop] = null; //clean up script to prep for garbage collection.\\n      }\\n      return;\\n    },\\n\\n    /**\\n     * @function\\n     * Causes one or more active plugins to re-initialize, resetting event listeners, recalculating positions, etc.\\n     * @param {String} plugins - optional string of an individual plugin key, attained by calling `$(element).data('pluginName')`, or string of a plugin class i.e. `'dropdown'`\\n     * @default If no argument is passed, reflow all currently active plugins.\\n     */\\n    reInit: function (plugins) {\\n      var isJQ = plugins instanceof $;\\n      try {\\n        if (isJQ) {\\n          plugins.each(function () {\\n            $(this).data('zfPlugin')._init();\\n          });\\n        } else {\\n          var type = typeof plugins,\\n              _this = this,\\n              fns = {\\n            'object': function (plgs) {\\n              plgs.forEach(function (p) {\\n                p = hyphenate(p);\\n                $('[data-' + p + ']').foundation('_init');\\n              });\\n            },\\n            'string': function () {\\n              plugins = hyphenate(plugins);\\n              $('[data-' + plugins + ']').foundation('_init');\\n            },\\n            'undefined': function () {\\n              this['object'](Object.keys(_this._plugins));\\n            }\\n          };\\n          fns[type](plugins);\\n        }\\n      } catch (err) {\\n        console.error(err);\\n      } finally {\\n        return plugins;\\n      }\\n    },\\n\\n    /**\\n     * returns a random base-36 uid with namespacing\\n     * @function\\n     * @param {Number} length - number of random base-36 digits desired. Increase for more random strings.\\n     * @param {String} namespace - name of plugin to be incorporated in uid, optional.\\n     * @default {String} '' - if no plugin name is provided, nothing is appended to the uid.\\n     * @returns {String} - unique id\\n     */\\n    GetYoDigits: function (length, namespace) {\\n      length = length || 6;\\n      return Math.round(Math.pow(36, length + 1) - Math.random() * Math.pow(36, length)).toString(36).slice(1) + (namespace ? '-' + namespace : '');\\n    },\\n    /**\\n     * Initialize plugins on any elements within `elem` (and `elem` itself) that aren't already initialized.\\n     * @param {Object} elem - jQuery object containing the element to check inside. Also checks the element itself, unless it's the `document` object.\\n     * @param {String|Array} plugins - A list of plugins to initialize. Leave this out to initialize everything.\\n     */\\n    reflow: function (elem, plugins) {\\n\\n      // If plugins is undefined, just grab everything\\n      if (typeof plugins === 'undefined') {\\n        plugins = Object.keys(this._plugins);\\n      }\\n      // If plugins is a string, convert it to an array with one item\\n      else if (typeof plugins === 'string') {\\n          plugins = [plugins];\\n        }\\n\\n      var _this = this;\\n\\n      // Iterate through each plugin\\n      $.each(plugins, function (i, name) {\\n        // Get the current plugin\\n        var plugin = _this._plugins[name];\\n\\n        // Localize the search to all elements inside elem, as well as elem itself, unless elem === document\\n        var $elem = $(elem).find('[data-' + name + ']').addBack('[data-' + name + ']');\\n\\n        // For each plugin found, initialize it\\n        $elem.each(function () {\\n          var $el = $(this),\\n              opts = {};\\n          // Don't double-dip on plugins\\n          if ($el.data('zfPlugin')) {\\n            console.warn(\\\"Tried to initialize \\\" + name + \\\" on an element that already has a Foundation plugin.\\\");\\n            return;\\n          }\\n\\n          if ($el.attr('data-options')) {\\n            var thing = $el.attr('data-options').split(';').forEach(function (e, i) {\\n              var opt = e.split(':').map(function (el) {\\n                return el.trim();\\n              });\\n              if (opt[0]) opts[opt[0]] = parseValue(opt[1]);\\n            });\\n          }\\n          try {\\n            $el.data('zfPlugin', new plugin($(this), opts));\\n          } catch (er) {\\n            console.error(er);\\n          } finally {\\n            return;\\n          }\\n        });\\n      });\\n    },\\n    getFnName: functionName,\\n    transitionend: function ($elem) {\\n      var transitions = {\\n        'transition': 'transitionend',\\n        'WebkitTransition': 'webkitTransitionEnd',\\n        'MozTransition': 'transitionend',\\n        'OTransition': 'otransitionend'\\n      };\\n      var elem = document.createElement('div'),\\n          end;\\n\\n      for (var t in transitions) {\\n        if (typeof elem.style[t] !== 'undefined') {\\n          end = transitions[t];\\n        }\\n      }\\n      if (end) {\\n        return end;\\n      } else {\\n        end = setTimeout(function () {\\n          $elem.triggerHandler('transitionend', [$elem]);\\n        }, 1);\\n        return 'transitionend';\\n      }\\n    }\\n  };\\n\\n  Foundation.util = {\\n    /**\\n     * Function for applying a debounce effect to a function call.\\n     * @function\\n     * @param {Function} func - Function to be called at end of timeout.\\n     * @param {Number} delay - Time in ms to delay the call of `func`.\\n     * @returns function\\n     */\\n    throttle: function (func, delay) {\\n      var timer = null;\\n\\n      return function () {\\n        var context = this,\\n            args = arguments;\\n\\n        if (timer === null) {\\n          timer = setTimeout(function () {\\n            func.apply(context, args);\\n            timer = null;\\n          }, delay);\\n        }\\n      };\\n    }\\n  };\\n\\n  // TODO: consider not making this a jQuery function\\n  // TODO: need way to reflow vs. re-initialize\\n  /**\\n   * The Foundation jQuery method.\\n   * @param {String|Array} method - An action to perform on the current jQuery object.\\n   */\\n  var foundation = function (method) {\\n    var type = typeof method,\\n        $meta = $('meta.foundation-mq'),\\n        $noJS = $('.no-js');\\n\\n    if (!$meta.length) {\\n      $('<meta class=\\\"foundation-mq\\\">').appendTo(document.head);\\n    }\\n    if ($noJS.length) {\\n      $noJS.removeClass('no-js');\\n    }\\n\\n    if (type === 'undefined') {\\n      //needs to initialize the Foundation object, or an individual plugin.\\n      Foundation.MediaQuery._init();\\n      Foundation.reflow(this);\\n    } else if (type === 'string') {\\n      //an individual method to invoke on a plugin or group of plugins\\n      var args = Array.prototype.slice.call(arguments, 1); //collect all the arguments, if necessary\\n      var plugClass = this.data('zfPlugin'); //determine the class of plugin\\n\\n      if (plugClass !== undefined && plugClass[method] !== undefined) {\\n        //make sure both the class and method exist\\n        if (this.length === 1) {\\n          //if there's only one, call it directly.\\n          plugClass[method].apply(plugClass, args);\\n        } else {\\n          this.each(function (i, el) {\\n            //otherwise loop through the jQuery collection and invoke the method on each\\n            plugClass[method].apply($(el).data('zfPlugin'), args);\\n          });\\n        }\\n      } else {\\n        //error for no class or no method\\n        throw new ReferenceError(\\\"We're sorry, '\\\" + method + \\\"' is not an available method for \\\" + (plugClass ? functionName(plugClass) : 'this element') + '.');\\n      }\\n    } else {\\n      //error for invalid argument type\\n      throw new TypeError('We\\\\'re sorry, ' + type + ' is not a valid parameter. You must use a string representing the method you wish to invoke.');\\n    }\\n    return this;\\n  };\\n\\n  window.Foundation = Foundation;\\n  $.fn.foundation = foundation;\\n\\n  // Polyfill for requestAnimationFrame\\n  (function () {\\n    if (!Date.now || !window.Date.now) window.Date.now = Date.now = function () {\\n      return new Date().getTime();\\n    };\\n\\n    var vendors = ['webkit', 'moz'];\\n    for (var i = 0; i < vendors.length && !window.requestAnimationFrame; ++i) {\\n      var vp = vendors[i];\\n      window.requestAnimationFrame = window[vp + 'RequestAnimationFrame'];\\n      window.cancelAnimationFrame = window[vp + 'CancelAnimationFrame'] || window[vp + 'CancelRequestAnimationFrame'];\\n    }\\n    if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {\\n      var lastTime = 0;\\n      window.requestAnimationFrame = function (callback) {\\n        var now = Date.now();\\n        var nextTime = Math.max(lastTime + 16, now);\\n        return setTimeout(function () {\\n          callback(lastTime = nextTime);\\n        }, nextTime - now);\\n      };\\n      window.cancelAnimationFrame = clearTimeout;\\n    }\\n    /**\\n     * Polyfill for performance.now, required by rAF\\n     */\\n    if (!window.performance || !window.performance.now) {\\n      window.performance = {\\n        start: Date.now(),\\n        now: function () {\\n          return Date.now() - this.start;\\n        }\\n      };\\n    }\\n  })();\\n  if (!Function.prototype.bind) {\\n    Function.prototype.bind = function (oThis) {\\n      if (typeof this !== 'function') {\\n        // closest thing possible to the ECMAScript 5\\n        // internal IsCallable function\\n        throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\\n      }\\n\\n      var aArgs = Array.prototype.slice.call(arguments, 1),\\n          fToBind = this,\\n          fNOP = function () {},\\n          fBound = function () {\\n        return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\\n      };\\n\\n      if (this.prototype) {\\n        // native functions don't have a prototype\\n        fNOP.prototype = this.prototype;\\n      }\\n      fBound.prototype = new fNOP();\\n\\n      return fBound;\\n    };\\n  }\\n  // Polyfill to get the name of a function in IE9\\n  function functionName(fn) {\\n    if (Function.prototype.name === undefined) {\\n      var funcNameRegex = /function\\\\s([^(]{1,})\\\\(/;\\n      var results = funcNameRegex.exec(fn.toString());\\n      return results && results.length > 1 ? results[1].trim() : \\\"\\\";\\n    } else if (fn.prototype === undefined) {\\n      return fn.constructor.name;\\n    } else {\\n      return fn.prototype.constructor.name;\\n    }\\n  }\\n  function parseValue(str) {\\n    if (/true/.test(str)) return true;else if (/false/.test(str)) return false;else if (!isNaN(str * 1)) return parseFloat(str);\\n    return str;\\n  }\\n  // Convert PascalCase to kebab-case\\n  // Thank you: http://stackoverflow.com/a/8955580\\n  function hyphenate(str) {\\n    return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();\\n  }\\n}(jQuery);\\n'use strict';\\n\\n!function ($) {\\n\\n  Foundation.Box = {\\n    ImNotTouchingYou: ImNotTouchingYou,\\n    GetDimensions: GetDimensions,\\n    GetOffsets: GetOffsets\\n  };\\n\\n  /**\\n   * Compares the dimensions of an element to a container and determines collision events with container.\\n   * @function\\n   * @param {jQuery} element - jQuery object to test for collisions.\\n   * @param {jQuery} parent - jQuery object to use as bounding container.\\n   * @param {Boolean} lrOnly - set to true to check left and right values only.\\n   * @param {Boolean} tbOnly - set to true to check top and bottom values only.\\n   * @default if no parent object passed, detects collisions with `window`.\\n   * @returns {Boolean} - true if collision free, false if a collision in any direction.\\n   */\\n  function ImNotTouchingYou(element, parent, lrOnly, tbOnly) {\\n    var eleDims = GetDimensions(element),\\n        top,\\n        bottom,\\n        left,\\n        right;\\n\\n    if (parent) {\\n      var parDims = GetDimensions(parent);\\n\\n      bottom = eleDims.offset.top + eleDims.height <= parDims.height + parDims.offset.top;\\n      top = eleDims.offset.top >= parDims.offset.top;\\n      left = eleDims.offset.left >= parDims.offset.left;\\n      right = eleDims.offset.left + eleDims.width <= parDims.width + parDims.offset.left;\\n    } else {\\n      bottom = eleDims.offset.top + eleDims.height <= eleDims.windowDims.height + eleDims.windowDims.offset.top;\\n      top = eleDims.offset.top >= eleDims.windowDims.offset.top;\\n      left = eleDims.offset.left >= eleDims.windowDims.offset.left;\\n      right = eleDims.offset.left + eleDims.width <= eleDims.windowDims.width;\\n    }\\n\\n    var allDirs = [bottom, top, left, right];\\n\\n    if (lrOnly) {\\n      return left === right === true;\\n    }\\n\\n    if (tbOnly) {\\n      return top === bottom === true;\\n    }\\n\\n    return allDirs.indexOf(false) === -1;\\n  };\\n\\n  /**\\n   * Uses native methods to return an object of dimension values.\\n   * @function\\n   * @param {jQuery || HTML} element - jQuery object or DOM element for which to get the dimensions. Can be any element other that document or window.\\n   * @returns {Object} - nested object of integer pixel values\\n   * TODO - if element is window, return only those values.\\n   */\\n  function GetDimensions(elem, test) {\\n    elem = elem.length ? elem[0] : elem;\\n\\n    if (elem === window || elem === document) {\\n      throw new Error(\\\"I'm sorry, Dave. I'm afraid I can't do that.\\\");\\n    }\\n\\n    var rect = elem.getBoundingClientRect(),\\n        parRect = elem.parentNode.getBoundingClientRect(),\\n        winRect = document.body.getBoundingClientRect(),\\n        winY = window.pageYOffset,\\n        winX = window.pageXOffset;\\n\\n    return {\\n      width: rect.width,\\n      height: rect.height,\\n      offset: {\\n        top: rect.top + winY,\\n        left: rect.left + winX\\n      },\\n      parentDims: {\\n        width: parRect.width,\\n        height: parRect.height,\\n        offset: {\\n          top: parRect.top + winY,\\n          left: parRect.left + winX\\n        }\\n      },\\n      windowDims: {\\n        width: winRect.width,\\n        height: winRect.height,\\n        offset: {\\n          top: winY,\\n          left: winX\\n        }\\n      }\\n    };\\n  }\\n\\n  /**\\n   * Returns an object of top and left integer pixel values for dynamically rendered elements,\\n   * such as: Tooltip, Reveal, and Dropdown\\n   * @function\\n   * @param {jQuery} element - jQuery object for the element being positioned.\\n   * @param {jQuery} anchor - jQuery object for the element's anchor point.\\n   * @param {String} position - a string relating to the desired position of the element, relative to it's anchor\\n   * @param {Number} vOffset - integer pixel value of desired vertical separation between anchor and element.\\n   * @param {Number} hOffset - integer pixel value of desired horizontal separation between anchor and element.\\n   * @param {Boolean} isOverflow - if a collision event is detected, sets to true to default the element to full width - any desired offset.\\n   * TODO alter/rewrite to work with `em` values as well/instead of pixels\\n   */\\n  function GetOffsets(element, anchor, position, vOffset, hOffset, isOverflow) {\\n    var $eleDims = GetDimensions(element),\\n        $anchorDims = anchor ? GetDimensions(anchor) : null;\\n\\n    switch (position) {\\n      case 'top':\\n        return {\\n          left: Foundation.rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width : $anchorDims.offset.left,\\n          top: $anchorDims.offset.top - ($eleDims.height + vOffset)\\n        };\\n        break;\\n      case 'left':\\n        return {\\n          left: $anchorDims.offset.left - ($eleDims.width + hOffset),\\n          top: $anchorDims.offset.top\\n        };\\n        break;\\n      case 'right':\\n        return {\\n          left: $anchorDims.offset.left + $anchorDims.width + hOffset,\\n          top: $anchorDims.offset.top\\n        };\\n        break;\\n      case 'center top':\\n        return {\\n          left: $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2,\\n          top: $anchorDims.offset.top - ($eleDims.height + vOffset)\\n        };\\n        break;\\n      case 'center bottom':\\n        return {\\n          left: isOverflow ? hOffset : $anchorDims.offset.left + $anchorDims.width / 2 - $eleDims.width / 2,\\n          top: $anchorDims.offset.top + $anchorDims.height + vOffset\\n        };\\n        break;\\n      case 'center left':\\n        return {\\n          left: $anchorDims.offset.left - ($eleDims.width + hOffset),\\n          top: $anchorDims.offset.top + $anchorDims.height / 2 - $eleDims.height / 2\\n        };\\n        break;\\n      case 'center right':\\n        return {\\n          left: $anchorDims.offset.left + $anchorDims.width + hOffset + 1,\\n          top: $anchorDims.offset.top + $anchorDims.height / 2 - $eleDims.height / 2\\n        };\\n        break;\\n      case 'center':\\n        return {\\n          left: $eleDims.windowDims.offset.left + $eleDims.windowDims.width / 2 - $eleDims.width / 2,\\n          top: $eleDims.windowDims.offset.top + $eleDims.windowDims.height / 2 - $eleDims.height / 2\\n        };\\n        break;\\n      case 'reveal':\\n        return {\\n          left: ($eleDims.windowDims.width - $eleDims.width) / 2,\\n          top: $eleDims.windowDims.offset.top + vOffset\\n        };\\n      case 'reveal full':\\n        return {\\n          left: $eleDims.windowDims.offset.left,\\n          top: $eleDims.windowDims.offset.top\\n        };\\n        break;\\n      case 'left bottom':\\n        return {\\n          left: $anchorDims.offset.left - ($eleDims.width + hOffset),\\n          top: $anchorDims.offset.top + $anchorDims.height\\n        };\\n        break;\\n      case 'right bottom':\\n        return {\\n          left: $anchorDims.offset.left + $anchorDims.width + hOffset - $eleDims.width,\\n          top: $anchorDims.offset.top + $anchorDims.height\\n        };\\n        break;\\n      default:\\n        return {\\n          left: Foundation.rtl() ? $anchorDims.offset.left - $eleDims.width + $anchorDims.width : $anchorDims.offset.left,\\n          top: $anchorDims.offset.top + $anchorDims.height + vOffset\\n        };\\n    }\\n  }\\n}(jQuery);\\n/*******************************************\\n *                                         *\\n * This util was created by Marius Olbertz *\\n * Please thank Marius on GitHub /owlbertz *\\n * or the web http://www.mariusolbertz.de/ *\\n *                                         *\\n ******************************************/\\n\\n'use strict';\\n\\n!function ($) {\\n\\n  var keyCodes = {\\n    9: 'TAB',\\n    13: 'ENTER',\\n    27: 'ESCAPE',\\n    32: 'SPACE',\\n    37: 'ARROW_LEFT',\\n    38: 'ARROW_UP',\\n    39: 'ARROW_RIGHT',\\n    40: 'ARROW_DOWN'\\n  };\\n\\n  var commands = {};\\n\\n  var Keyboard = {\\n    keys: getKeyCodes(keyCodes),\\n\\n    /**\\n     * Parses the (keyboard) event and returns a String that represents its key\\n     * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE\\n     * @param {Event} event - the event generated by the event handler\\n     * @return String key - String that represents the key pressed\\n     */\\n    parseKey: function (event) {\\n      var key = keyCodes[event.which || event.keyCode] || String.fromCharCode(event.which).toUpperCase();\\n      if (event.shiftKey) key = 'SHIFT_' + key;\\n      if (event.ctrlKey) key = 'CTRL_' + key;\\n      if (event.altKey) key = 'ALT_' + key;\\n      return key;\\n    },\\n\\n\\n    /**\\n     * Handles the given (keyboard) event\\n     * @param {Event} event - the event generated by the event handler\\n     * @param {String} component - Foundation component's name, e.g. Slider or Reveal\\n     * @param {Objects} functions - collection of functions that are to be executed\\n     */\\n    handleKey: function (event, component, functions) {\\n      var commandList = commands[component],\\n          keyCode = this.parseKey(event),\\n          cmds,\\n          command,\\n          fn;\\n\\n      if (!commandList) return console.warn('Component not defined!');\\n\\n      if (typeof commandList.ltr === 'undefined') {\\n        // this component does not differentiate between ltr and rtl\\n        cmds = commandList; // use plain list\\n      } else {\\n          // merge ltr and rtl: if document is rtl, rtl overwrites ltr and vice versa\\n          if (Foundation.rtl()) cmds = $.extend({}, commandList.ltr, commandList.rtl);else cmds = $.extend({}, commandList.rtl, commandList.ltr);\\n        }\\n      command = cmds[keyCode];\\n\\n      fn = functions[command];\\n      if (fn && typeof fn === 'function') {\\n        // execute function  if exists\\n        var returnValue = fn.apply();\\n        if (functions.handled || typeof functions.handled === 'function') {\\n          // execute function when event was handled\\n          functions.handled(returnValue);\\n        }\\n      } else {\\n        if (functions.unhandled || typeof functions.unhandled === 'function') {\\n          // execute function when event was not handled\\n          functions.unhandled();\\n        }\\n      }\\n    },\\n\\n\\n    /**\\n     * Finds all focusable elements within the given `$element`\\n     * @param {jQuery} $element - jQuery object to search within\\n     * @return {jQuery} $focusable - all focusable elements within `$element`\\n     */\\n    findFocusable: function ($element) {\\n      return $element.find('a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]').filter(function () {\\n        if (!$(this).is(':visible') || $(this).attr('tabindex') < 0) {\\n          return false;\\n        } //only have visible elements and those that have a tabindex greater or equal 0\\n        return true;\\n      });\\n    },\\n\\n\\n    /**\\n     * Returns the component name name\\n     * @param {Object} component - Foundation component, e.g. Slider or Reveal\\n     * @return String componentName\\n     */\\n\\n    register: function (componentName, cmds) {\\n      commands[componentName] = cmds;\\n    }\\n  };\\n\\n  /*\\n   * Constants for easier comparing.\\n   * Can be used like Foundation.parseKey(event) === Foundation.keys.SPACE\\n   */\\n  function getKeyCodes(kcs) {\\n    var k = {};\\n    for (var kc in kcs) {\\n      k[kcs[kc]] = kcs[kc];\\n    }return k;\\n  }\\n\\n  Foundation.Keyboard = Keyboard;\\n}(jQuery);\\n'use strict';\\n\\n!function ($) {\\n\\n  // Default set of media queries\\n  var defaultQueries = {\\n    'default': 'only screen',\\n    landscape: 'only screen and (orientation: landscape)',\\n    portrait: 'only screen and (orientation: portrait)',\\n    retina: 'only screen and (-webkit-min-device-pixel-ratio: 2),' + 'only screen and (min--moz-device-pixel-ratio: 2),' + 'only screen and (-o-min-device-pixel-ratio: 2/1),' + 'only screen and (min-device-pixel-ratio: 2),' + 'only screen and (min-resolution: 192dpi),' + 'only screen and (min-resolution: 2dppx)'\\n  };\\n\\n  var MediaQuery = {\\n    queries: [],\\n\\n    current: '',\\n\\n    /**\\n     * Initializes the media query helper, by extracting the breakpoint list from the CSS and activating the breakpoint watcher.\\n     * @function\\n     * @private\\n     */\\n    _init: function () {\\n      var self = this;\\n      var extractedStyles = $('.foundation-mq').css('font-family');\\n      var namedQueries;\\n\\n      namedQueries = parseStyleToObject(extractedStyles);\\n\\n      for (var key in namedQueries) {\\n        if (namedQueries.hasOwnProperty(key)) {\\n          self.queries.push({\\n            name: key,\\n            value: 'only screen and (min-width: ' + namedQueries[key] + ')'\\n          });\\n        }\\n      }\\n\\n      this.current = this._getCurrentSize();\\n\\n      this._watcher();\\n    },\\n\\n\\n    /**\\n     * Checks if the screen is at least as wide as a breakpoint.\\n     * @function\\n     * @param {String} size - Name of the breakpoint to check.\\n     * @returns {Boolean} `true` if the breakpoint matches, `false` if it's smaller.\\n     */\\n    atLeast: function (size) {\\n      var query = this.get(size);\\n\\n      if (query) {\\n        return window.matchMedia(query).matches;\\n      }\\n\\n      return false;\\n    },\\n\\n\\n    /**\\n     * Gets the media query of a breakpoint.\\n     * @function\\n     * @param {String} size - Name of the breakpoint to get.\\n     * @returns {String|null} - The media query of the breakpoint, or `null` if the breakpoint doesn't exist.\\n     */\\n    get: function (size) {\\n      for (var i in this.queries) {\\n        if (this.queries.hasOwnProperty(i)) {\\n          var query = this.queries[i];\\n          if (size === query.name) return query.value;\\n        }\\n      }\\n\\n      return null;\\n    },\\n\\n\\n    /**\\n     * Gets the current breakpoint name by testing every breakpoint and returning the last one to match (the biggest one).\\n     * @function\\n     * @private\\n     * @returns {String} Name of the current breakpoint.\\n     */\\n    _getCurrentSize: function () {\\n      var matched;\\n\\n      for (var i = 0; i < this.queries.length; i++) {\\n        var query = this.queries[i];\\n\\n        if (window.matchMedia(query.value).matches) {\\n          matched = query;\\n        }\\n      }\\n\\n      if (typeof matched === 'object') {\\n        return matched.name;\\n      } else {\\n        return matched;\\n      }\\n    },\\n\\n\\n    /**\\n     * Activates the breakpoint watcher, which fires an event on the window whenever the breakpoint changes.\\n     * @function\\n     * @private\\n     */\\n    _watcher: function () {\\n      var _this = this;\\n\\n      $(window).on('resize.zf.mediaquery', function () {\\n        var newSize = _this._getCurrentSize(),\\n            currentSize = _this.current;\\n\\n        if (newSize !== currentSize) {\\n          // Change the current media query\\n          _this.current = newSize;\\n\\n          // Broadcast the media query change on the window\\n          $(window).trigger('changed.zf.mediaquery', [newSize, currentSize]);\\n        }\\n      });\\n    }\\n  };\\n\\n  Foundation.MediaQuery = MediaQuery;\\n\\n  // matchMedia() polyfill - Test a CSS media type/query in JS.\\n  // Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license\\n  window.matchMedia || (window.matchMedia = function () {\\n    'use strict';\\n\\n    // For browsers that support matchMedium api such as IE 9 and webkit\\n\\n    var styleMedia = window.styleMedia || window.media;\\n\\n    // For those that don't support matchMedium\\n    if (!styleMedia) {\\n      var style = document.createElement('style'),\\n          script = document.getElementsByTagName('script')[0],\\n          info = null;\\n\\n      style.type = 'text/css';\\n      style.id = 'matchmediajs-test';\\n\\n      script.parentNode.insertBefore(style, script);\\n\\n      // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers\\n      info = 'getComputedStyle' in window && window.getComputedStyle(style, null) || style.currentStyle;\\n\\n      styleMedia = {\\n        matchMedium: function (media) {\\n          var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';\\n\\n          // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers\\n          if (style.styleSheet) {\\n            style.styleSheet.cssText = text;\\n          } else {\\n            style.textContent = text;\\n          }\\n\\n          // Test if media query is true or false\\n          return info.width === '1px';\\n        }\\n      };\\n    }\\n\\n    return function (media) {\\n      return {\\n        matches: styleMedia.matchMedium(media || 'all'),\\n        media: media || 'all'\\n      };\\n    };\\n  }());\\n\\n  // Thank you: https://github.com/sindresorhus/query-string\\n  function parseStyleToObject(str) {\\n    var styleObject = {};\\n\\n    if (typeof str !== 'string') {\\n      return styleObject;\\n    }\\n\\n    str = str.trim().slice(1, -1); // browsers re-quote string style values\\n\\n    if (!str) {\\n      return styleObject;\\n    }\\n\\n    styleObject = str.split('&').reduce(function (ret, param) {\\n      var parts = param.replace(/\\\\+/g, ' ').split('=');\\n      var key = parts[0];\\n      var val = parts[1];\\n      key = decodeURIComponent(key);\\n\\n      // missing `=` should be `null`:\\n      // http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters\\n      val = val === undefined ? null : decodeURIComponent(val);\\n\\n      if (!ret.hasOwnProperty(key)) {\\n        ret[key] = val;\\n      } else if (Array.isArray(ret[key])) {\\n        ret[key].push(val);\\n      } else {\\n        ret[key] = [ret[key], val];\\n      }\\n      return ret;\\n    }, {});\\n\\n    return styleObject;\\n  }\\n\\n  Foundation.MediaQuery = MediaQuery;\\n}(jQuery);\\n'use strict';\\n\\n!function ($) {\\n\\n  /**\\n   * Motion module.\\n   * @module foundation.motion\\n   */\\n\\n  var initClasses = ['mui-enter', 'mui-leave'];\\n  var activeClasses = ['mui-enter-active', 'mui-leave-active'];\\n\\n  var Motion = {\\n    animateIn: function (element, animation, cb) {\\n      animate(true, element, animation, cb);\\n    },\\n\\n    animateOut: function (element, animation, cb) {\\n      animate(false, element, animation, cb);\\n    }\\n  };\\n\\n  function Move(duration, elem, fn) {\\n    var anim,\\n        prog,\\n        start = null;\\n    // console.log('called');\\n\\n    function move(ts) {\\n      if (!start) start = window.performance.now();\\n      // console.log(start, ts);\\n      prog = ts - start;\\n      fn.apply(elem);\\n\\n      if (prog < duration) {\\n        anim = window.requestAnimationFrame(move, elem);\\n      } else {\\n        window.cancelAnimationFrame(anim);\\n        elem.trigger('finished.zf.animate', [elem]).triggerHandler('finished.zf.animate', [elem]);\\n      }\\n    }\\n    anim = window.requestAnimationFrame(move);\\n  }\\n\\n  /**\\n   * Animates an element in or out using a CSS transition class.\\n   * @function\\n   * @private\\n   * @param {Boolean} isIn - Defines if the animation is in or out.\\n   * @param {Object} element - jQuery or HTML object to animate.\\n   * @param {String} animation - CSS class to use.\\n   * @param {Function} cb - Callback to run when animation is finished.\\n   */\\n  function animate(isIn, element, animation, cb) {\\n    element = $(element).eq(0);\\n\\n    if (!element.length) return;\\n\\n    var initClass = isIn ? initClasses[0] : initClasses[1];\\n    var activeClass = isIn ? activeClasses[0] : activeClasses[1];\\n\\n    // Set up the animation\\n    reset();\\n\\n    element.addClass(animation).css('transition', 'none');\\n\\n    requestAnimationFrame(function () {\\n      element.addClass(initClass);\\n      if (isIn) element.show();\\n    });\\n\\n    // Start the animation\\n    requestAnimationFrame(function () {\\n      element[0].offsetWidth;\\n      element.css('transition', '').addClass(activeClass);\\n    });\\n\\n    // Clean up the animation when it finishes\\n    element.one(Foundation.transitionend(element), finish);\\n\\n    // Hides the element (for out animations), resets the element, and runs a callback\\n    function finish() {\\n      if (!isIn) element.hide();\\n      reset();\\n      if (cb) cb.apply(element);\\n    }\\n\\n    // Resets transitions and removes motion-specific classes\\n    function reset() {\\n      element[0].style.transitionDuration = 0;\\n      element.removeClass(initClass + ' ' + activeClass + ' ' + animation);\\n    }\\n  }\\n\\n  Foundation.Move = Move;\\n  Foundation.Motion = Motion;\\n}(jQuery);\\n'use strict';\\n\\n!function ($) {\\n\\n  var Nest = {\\n    Feather: function (menu) {\\n      var type = arguments.length <= 1 || arguments[1] === undefined ? 'zf' : arguments[1];\\n\\n      menu.attr('role', 'menubar');\\n\\n      var items = menu.find('li').attr({ 'role': 'menuitem' }),\\n          subMenuClass = 'is-' + type + '-submenu',\\n          subItemClass = subMenuClass + '-item',\\n          hasSubClass = 'is-' + type + '-submenu-parent';\\n\\n      menu.find('a:first').attr('tabindex', 0);\\n\\n      items.each(function () {\\n        var $item = $(this),\\n            $sub = $item.children('ul');\\n\\n        if ($sub.length) {\\n          $item.addClass(hasSubClass).attr({\\n            'aria-haspopup': true,\\n            'aria-expanded': false,\\n            'aria-label': $item.children('a:first').text()\\n          });\\n\\n          $sub.addClass('submenu ' + subMenuClass).attr({\\n            'data-submenu': '',\\n            'aria-hidden': true,\\n            'role': 'menu'\\n          });\\n        }\\n\\n        if ($item.parent('[data-submenu]').length) {\\n          $item.addClass('is-submenu-item ' + subItemClass);\\n        }\\n      });\\n\\n      return;\\n    },\\n    Burn: function (menu, type) {\\n      var items = menu.find('li').removeAttr('tabindex'),\\n          subMenuClass = 'is-' + type + '-submenu',\\n          subItemClass = subMenuClass + '-item',\\n          hasSubClass = 'is-' + type + '-submenu-parent';\\n\\n      menu.find('*').removeClass(subMenuClass + ' ' + subItemClass + ' ' + hasSubClass + ' is-submenu-item submenu is-active').removeAttr('data-submenu').css('display', '');\\n\\n      // console.log(      menu.find('.' + subMenuClass + ', .' + subItemClass + ', .has-submenu, .is-submenu-item, .submenu, [data-submenu]')\\n      //           .removeClass(subMenuClass + ' ' + subItemClass + ' has-submenu is-submenu-item submenu')\\n      //           .removeAttr('data-submenu'));\\n      // items.each(function(){\\n      //   var $item = $(this),\\n      //       $sub = $item.children('ul');\\n      //   if($item.parent('[data-submenu]').length){\\n      //     $item.removeClass('is-submenu-item ' + subItemClass);\\n      //   }\\n      //   if($sub.length){\\n      //     $item.removeClass('has-submenu');\\n      //     $sub.removeClass('submenu ' + subMenuClass).removeAttr('data-submenu');\\n      //   }\\n      // });\\n    }\\n  };\\n\\n  Foundation.Nest = Nest;\\n}(jQuery);\\n'use strict';\\n\\n!function ($) {\\n\\n  function Timer(elem, options, cb) {\\n    var _this = this,\\n        duration = options.duration,\\n        //options is an object for easily adding features later.\\n    nameSpace = Object.keys(elem.data())[0] || 'timer',\\n        remain = -1,\\n        start,\\n        timer;\\n\\n    this.isPaused = false;\\n\\n    this.restart = function () {\\n      remain = -1;\\n      clearTimeout(timer);\\n      this.start();\\n    };\\n\\n    this.start = function () {\\n      this.isPaused = false;\\n      // if(!elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.\\n      clearTimeout(timer);\\n      remain = remain <= 0 ? duration : remain;\\n      elem.data('paused', false);\\n      start = Date.now();\\n      timer = setTimeout(function () {\\n        if (options.infinite) {\\n          _this.restart(); //rerun the timer.\\n        }\\n        cb();\\n      }, remain);\\n      elem.trigger('timerstart.zf.' + nameSpace);\\n    };\\n\\n    this.pause = function () {\\n      this.isPaused = true;\\n      //if(elem.data('paused')){ return false; }//maybe implement this sanity check if used for other things.\\n      clearTimeout(timer);\\n      elem.data('paused', true);\\n      var end = Date.now();\\n      remain = remain - (end - start);\\n      elem.trigger('timerpaused.zf.' + nameSpace);\\n    };\\n  }\\n\\n  /**\\n   * Runs a callback function when images are fully loaded.\\n   * @param {Object} images - Image(s) to check if loaded.\\n   * @param {Func} callback - Function to execute when image is fully loaded.\\n   */\\n  function onImagesLoaded(images, callback) {\\n    var self = this,\\n        unloaded = images.length;\\n\\n    if (unloaded === 0) {\\n      callback();\\n    }\\n\\n    images.each(function () {\\n      if (this.complete) {\\n        singleImageLoaded();\\n      } else if (typeof this.naturalWidth !== 'undefined' && this.naturalWidth > 0) {\\n        singleImageLoaded();\\n      } else {\\n        $(this).one('load', function () {\\n          singleImageLoaded();\\n        });\\n      }\\n    });\\n\\n    function singleImageLoaded() {\\n      unloaded--;\\n      if (unloaded === 0) {\\n        callback();\\n      }\\n    }\\n  }\\n\\n  Foundation.Timer = Timer;\\n  Foundation.onImagesLoaded = onImagesLoaded;\\n}(jQuery);\\n//**************************************************\\n//**Work inspired by multiple jquery swipe plugins**\\n//**Done by Yohai Ararat ***************************\\n//**************************************************\\n(function ($) {\\n\\n\\t$.spotSwipe = {\\n\\t\\tversion: '1.0.0',\\n\\t\\tenabled: 'ontouchstart' in document.documentElement,\\n\\t\\tpreventDefault: false,\\n\\t\\tmoveThreshold: 75,\\n\\t\\ttimeThreshold: 200\\n\\t};\\n\\n\\tvar startPosX,\\n\\t    startPosY,\\n\\t    startTime,\\n\\t    elapsedTime,\\n\\t    isMoving = false;\\n\\n\\tfunction onTouchEnd() {\\n\\t\\t//  alert(this);\\n\\t\\tthis.removeEventListener('touchmove', onTouchMove);\\n\\t\\tthis.removeEventListener('touchend', onTouchEnd);\\n\\t\\tisMoving = false;\\n\\t}\\n\\n\\tfunction onTouchMove(e) {\\n\\t\\tif ($.spotSwipe.preventDefault) {\\n\\t\\t\\te.preventDefault();\\n\\t\\t}\\n\\t\\tif (isMoving) {\\n\\t\\t\\tvar x = e.touches[0].pageX;\\n\\t\\t\\tvar y = e.touches[0].pageY;\\n\\t\\t\\tvar dx = startPosX - x;\\n\\t\\t\\tvar dy = startPosY - y;\\n\\t\\t\\tvar dir;\\n\\t\\t\\telapsedTime = new Date().getTime() - startTime;\\n\\t\\t\\tif (Math.abs(dx) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {\\n\\t\\t\\t\\tdir = dx > 0 ? 'left' : 'right';\\n\\t\\t\\t}\\n\\t\\t\\t// else if(Math.abs(dy) >= $.spotSwipe.moveThreshold && elapsedTime <= $.spotSwipe.timeThreshold) {\\n\\t\\t\\t//   dir = dy > 0 ? 'down' : 'up';\\n\\t\\t\\t// }\\n\\t\\t\\tif (dir) {\\n\\t\\t\\t\\te.preventDefault();\\n\\t\\t\\t\\tonTouchEnd.call(this);\\n\\t\\t\\t\\t$(this).trigger('swipe', dir).trigger('swipe' + dir);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfunction onTouchStart(e) {\\n\\t\\tif (e.touches.length == 1) {\\n\\t\\t\\tstartPosX = e.touches[0].pageX;\\n\\t\\t\\tstartPosY = e.touches[0].pageY;\\n\\t\\t\\tisMoving = true;\\n\\t\\t\\tstartTime = new Date().getTime();\\n\\t\\t\\tthis.addEventListener('touchmove', onTouchMove, false);\\n\\t\\t\\tthis.addEventListener('touchend', onTouchEnd, false);\\n\\t\\t}\\n\\t}\\n\\n\\tfunction init() {\\n\\t\\tthis.addEventListener && this.addEventListener('touchstart', onTouchStart, false);\\n\\t}\\n\\n\\tfunction teardown() {\\n\\t\\tthis.removeEventListener('touchstart', onTouchStart);\\n\\t}\\n\\n\\t$.event.special.swipe = { setup: init };\\n\\n\\t$.each(['left', 'up', 'down', 'right'], function () {\\n\\t\\t$.event.special['swipe' + this] = { setup: function () {\\n\\t\\t\\t\\t$(this).on('swipe', $.noop);\\n\\t\\t\\t} };\\n\\t});\\n})(jQuery);\\n/****************************************************\\n * Method for adding psuedo drag events to elements *\\n ***************************************************/\\n!function ($) {\\n\\t$.fn.addTouch = function () {\\n\\t\\tthis.each(function (i, el) {\\n\\t\\t\\t$(el).bind('touchstart touchmove touchend touchcancel', function () {\\n\\t\\t\\t\\t//we pass the original event object because the jQuery event\\n\\t\\t\\t\\t//object is normalized to w3c specs and does not provide the TouchList\\n\\t\\t\\t\\thandleTouch(event);\\n\\t\\t\\t});\\n\\t\\t});\\n\\n\\t\\tvar handleTouch = function (event) {\\n\\t\\t\\tvar touches = event.changedTouches,\\n\\t\\t\\t    first = touches[0],\\n\\t\\t\\t    eventTypes = {\\n\\t\\t\\t\\ttouchstart: 'mousedown',\\n\\t\\t\\t\\ttouchmove: 'mousemove',\\n\\t\\t\\t\\ttouchend: 'mouseup'\\n\\t\\t\\t},\\n\\t\\t\\t    type = eventTypes[event.type],\\n\\t\\t\\t    simulatedEvent;\\n\\n\\t\\t\\tif ('MouseEvent' in window && typeof window.MouseEvent === 'function') {\\n\\t\\t\\t\\tsimulatedEvent = new window.MouseEvent(type, {\\n\\t\\t\\t\\t\\t'bubbles': true,\\n\\t\\t\\t\\t\\t'cancelable': true,\\n\\t\\t\\t\\t\\t'screenX': first.screenX,\\n\\t\\t\\t\\t\\t'screenY': first.screenY,\\n\\t\\t\\t\\t\\t'clientX': first.clientX,\\n\\t\\t\\t\\t\\t'clientY': first.clientY\\n\\t\\t\\t\\t});\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsimulatedEvent = document.createEvent('MouseEvent');\\n\\t\\t\\t\\tsimulatedEvent.initMouseEvent(type, true, true, window, 1, first.screenX, first.screenY, first.clientX, first.clientY, false, false, false, false, 0 /*left*/, null);\\n\\t\\t\\t}\\n\\t\\t\\tfirst.target.dispatchEvent(simulatedEvent);\\n\\t\\t};\\n\\t};\\n}(jQuery);\\n\\n//**********************************\\n//**From the jQuery Mobile Library**\\n//**need to recreate functionality**\\n//**and try to improve if possible**\\n//**********************************\\n\\n/* Removing the jQuery function ****\\n************************************\\n\\n(function( $, window, undefined ) {\\n\\n\\tvar $document = $( document ),\\n\\t\\t// supportTouch = $.mobile.support.touch,\\n\\t\\ttouchStartEvent = 'touchstart'//supportTouch ? \\\"touchstart\\\" : \\\"mousedown\\\",\\n\\t\\ttouchStopEvent = 'touchend'//supportTouch ? \\\"touchend\\\" : \\\"mouseup\\\",\\n\\t\\ttouchMoveEvent = 'touchmove'//supportTouch ? \\\"touchmove\\\" : \\\"mousemove\\\";\\n\\n\\t// setup new event shortcuts\\n\\t$.each( ( \\\"touchstart touchmove touchend \\\" +\\n\\t\\t\\\"swipe swipeleft swiperight\\\" ).split( \\\" \\\" ), function( i, name ) {\\n\\n\\t\\t$.fn[ name ] = function( fn ) {\\n\\t\\t\\treturn fn ? this.bind( name, fn ) : this.trigger( name );\\n\\t\\t};\\n\\n\\t\\t// jQuery < 1.8\\n\\t\\tif ( $.attrFn ) {\\n\\t\\t\\t$.attrFn[ name ] = true;\\n\\t\\t}\\n\\t});\\n\\n\\tfunction triggerCustomEvent( obj, eventType, event, bubble ) {\\n\\t\\tvar originalType = event.type;\\n\\t\\tevent.type = eventType;\\n\\t\\tif ( bubble ) {\\n\\t\\t\\t$.event.trigger( event, undefined, obj );\\n\\t\\t} else {\\n\\t\\t\\t$.event.dispatch.call( obj, event );\\n\\t\\t}\\n\\t\\tevent.type = originalType;\\n\\t}\\n\\n\\t// also handles taphold\\n\\n\\t// Also handles swipeleft, swiperight\\n\\t$.event.special.swipe = {\\n\\n\\t\\t// More than this horizontal displacement, and we will suppress scrolling.\\n\\t\\tscrollSupressionThreshold: 30,\\n\\n\\t\\t// More time than this, and it isn't a swipe.\\n\\t\\tdurationThreshold: 1000,\\n\\n\\t\\t// Swipe horizontal displacement must be more than this.\\n\\t\\thorizontalDistanceThreshold: window.devicePixelRatio >= 2 ? 15 : 30,\\n\\n\\t\\t// Swipe vertical displacement must be less than this.\\n\\t\\tverticalDistanceThreshold: window.devicePixelRatio >= 2 ? 15 : 30,\\n\\n\\t\\tgetLocation: function ( event ) {\\n\\t\\t\\tvar winPageX = window.pageXOffset,\\n\\t\\t\\t\\twinPageY = window.pageYOffset,\\n\\t\\t\\t\\tx = event.clientX,\\n\\t\\t\\t\\ty = event.clientY;\\n\\n\\t\\t\\tif ( event.pageY === 0 && Math.floor( y ) > Math.floor( event.pageY ) ||\\n\\t\\t\\t\\tevent.pageX === 0 && Math.floor( x ) > Math.floor( event.pageX ) ) {\\n\\n\\t\\t\\t\\t// iOS4 clientX/clientY have the value that should have been\\n\\t\\t\\t\\t// in pageX/pageY. While pageX/page/ have the value 0\\n\\t\\t\\t\\tx = x - winPageX;\\n\\t\\t\\t\\ty = y - winPageY;\\n\\t\\t\\t} else if ( y < ( event.pageY - winPageY) || x < ( event.pageX - winPageX ) ) {\\n\\n\\t\\t\\t\\t// Some Android browsers have totally bogus values for clientX/Y\\n\\t\\t\\t\\t// when scrolling/zooming a page. Detectable since clientX/clientY\\n\\t\\t\\t\\t// should never be smaller than pageX/pageY minus page scroll\\n\\t\\t\\t\\tx = event.pageX - winPageX;\\n\\t\\t\\t\\ty = event.pageY - winPageY;\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tx: x,\\n\\t\\t\\t\\ty: y\\n\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\tstart: function( event ) {\\n\\t\\t\\tvar data = event.originalEvent.touches ?\\n\\t\\t\\t\\t\\tevent.originalEvent.touches[ 0 ] : event,\\n\\t\\t\\t\\tlocation = $.event.special.swipe.getLocation( data );\\n\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t\\ttime: ( new Date() ).getTime(),\\n\\t\\t\\t\\t\\t\\tcoords: [ location.x, location.y ],\\n\\t\\t\\t\\t\\t\\torigin: $( event.target )\\n\\t\\t\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\tstop: function( event ) {\\n\\t\\t\\tvar data = event.originalEvent.touches ?\\n\\t\\t\\t\\t\\tevent.originalEvent.touches[ 0 ] : event,\\n\\t\\t\\t\\tlocation = $.event.special.swipe.getLocation( data );\\n\\t\\t\\treturn {\\n\\t\\t\\t\\t\\t\\ttime: ( new Date() ).getTime(),\\n\\t\\t\\t\\t\\t\\tcoords: [ location.x, location.y ]\\n\\t\\t\\t\\t\\t};\\n\\t\\t},\\n\\n\\t\\thandleSwipe: function( start, stop, thisObject, origTarget ) {\\n\\t\\t\\tif ( stop.time - start.time < $.event.special.swipe.durationThreshold &&\\n\\t\\t\\t\\tMath.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.horizontalDistanceThreshold &&\\n\\t\\t\\t\\tMath.abs( start.coords[ 1 ] - stop.coords[ 1 ] ) < $.event.special.swipe.verticalDistanceThreshold ) {\\n\\t\\t\\t\\tvar direction = start.coords[0] > stop.coords[ 0 ] ? \\\"swipeleft\\\" : \\\"swiperight\\\";\\n\\n\\t\\t\\t\\ttriggerCustomEvent( thisObject, \\\"swipe\\\", $.Event( \\\"swipe\\\", { target: origTarget, swipestart: start, swipestop: stop }), true );\\n\\t\\t\\t\\ttriggerCustomEvent( thisObject, direction,$.Event( direction, { target: origTarget, swipestart: start, swipestop: stop } ), true );\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\n\\t\\t},\\n\\n\\t\\t// This serves as a flag to ensure that at most one swipe event event is\\n\\t\\t// in work at any given time\\n\\t\\teventInProgress: false,\\n\\n\\t\\tsetup: function() {\\n\\t\\t\\tvar events,\\n\\t\\t\\t\\tthisObject = this,\\n\\t\\t\\t\\t$this = $( thisObject ),\\n\\t\\t\\t\\tcontext = {};\\n\\n\\t\\t\\t// Retrieve the events data for this element and add the swipe context\\n\\t\\t\\tevents = $.data( this, \\\"mobile-events\\\" );\\n\\t\\t\\tif ( !events ) {\\n\\t\\t\\t\\tevents = { length: 0 };\\n\\t\\t\\t\\t$.data( this, \\\"mobile-events\\\", events );\\n\\t\\t\\t}\\n\\t\\t\\tevents.length++;\\n\\t\\t\\tevents.swipe = context;\\n\\n\\t\\t\\tcontext.start = function( event ) {\\n\\n\\t\\t\\t\\t// Bail if we're already working on a swipe event\\n\\t\\t\\t\\tif ( $.event.special.swipe.eventInProgress ) {\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t$.event.special.swipe.eventInProgress = true;\\n\\n\\t\\t\\t\\tvar stop,\\n\\t\\t\\t\\t\\tstart = $.event.special.swipe.start( event ),\\n\\t\\t\\t\\t\\torigTarget = event.target,\\n\\t\\t\\t\\t\\temitted = false;\\n\\n\\t\\t\\t\\tcontext.move = function( event ) {\\n\\t\\t\\t\\t\\tif ( !start || event.isDefaultPrevented() ) {\\n\\t\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\tstop = $.event.special.swipe.stop( event );\\n\\t\\t\\t\\t\\tif ( !emitted ) {\\n\\t\\t\\t\\t\\t\\temitted = $.event.special.swipe.handleSwipe( start, stop, thisObject, origTarget );\\n\\t\\t\\t\\t\\t\\tif ( emitted ) {\\n\\n\\t\\t\\t\\t\\t\\t\\t// Reset the context to make way for the next swipe event\\n\\t\\t\\t\\t\\t\\t\\t$.event.special.swipe.eventInProgress = false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t// prevent scrolling\\n\\t\\t\\t\\t\\tif ( Math.abs( start.coords[ 0 ] - stop.coords[ 0 ] ) > $.event.special.swipe.scrollSupressionThreshold ) {\\n\\t\\t\\t\\t\\t\\tevent.preventDefault();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\tcontext.stop = function() {\\n\\t\\t\\t\\t\\t\\temitted = true;\\n\\n\\t\\t\\t\\t\\t\\t// Reset the context to make way for the next swipe event\\n\\t\\t\\t\\t\\t\\t$.event.special.swipe.eventInProgress = false;\\n\\t\\t\\t\\t\\t\\t$document.off( touchMoveEvent, context.move );\\n\\t\\t\\t\\t\\t\\tcontext.move = null;\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\t$document.on( touchMoveEvent, context.move )\\n\\t\\t\\t\\t\\t.one( touchStopEvent, context.stop );\\n\\t\\t\\t};\\n\\t\\t\\t$this.on( touchStartEvent, context.start );\\n\\t\\t},\\n\\n\\t\\tteardown: function() {\\n\\t\\t\\tvar events, context;\\n\\n\\t\\t\\tevents = $.data( this, \\\"mobile-events\\\" );\\n\\t\\t\\tif ( events ) {\\n\\t\\t\\t\\tcontext = events.swipe;\\n\\t\\t\\t\\tdelete events.swipe;\\n\\t\\t\\t\\tevents.length--;\\n\\t\\t\\t\\tif ( events.length === 0 ) {\\n\\t\\t\\t\\t\\t$.removeData( this, \\\"mobile-events\\\" );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif ( context ) {\\n\\t\\t\\t\\tif ( context.start ) {\\n\\t\\t\\t\\t\\t$( this ).off( touchStartEvent, context.start );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( context.move ) {\\n\\t\\t\\t\\t\\t$document.off( touchMoveEvent, context.move );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( context.stop ) {\\n\\t\\t\\t\\t\\t$document.off( touchStopEvent, context.stop );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\t$.each({\\n\\t\\tswipeleft: \\\"swipe.left\\\",\\n\\t\\tswiperight: \\\"swipe.right\\\"\\n\\t}, function( event, sourceEvent ) {\\n\\n\\t\\t$.event.special[ event ] = {\\n\\t\\t\\tsetup: function() {\\n\\t\\t\\t\\t$( this ).bind( sourceEvent, $.noop );\\n\\t\\t\\t},\\n\\t\\t\\tteardown: function() {\\n\\t\\t\\t\\t$( this ).unbind( sourceEvent );\\n\\t\\t\\t}\\n\\t\\t};\\n\\t});\\n})( jQuery, this );\\n*/\\n'use strict';\\n\\n!function ($) {\\n\\n  var MutationObserver = function () {\\n    var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];\\n    for (var i = 0; i < prefixes.length; i++) {\\n      if (prefixes[i] + 'MutationObserver' in window) {\\n        return window[prefixes[i] + 'MutationObserver'];\\n      }\\n    }\\n    return false;\\n  }();\\n\\n  var triggers = function (el, type) {\\n    el.data(type).split(' ').forEach(function (id) {\\n      $('#' + id)[type === 'close' ? 'trigger' : 'triggerHandler'](type + '.zf.trigger', [el]);\\n    });\\n  };\\n  // Elements with [data-open] will reveal a plugin that supports it when clicked.\\n  $(document).on('click.zf.trigger', '[data-open]', function () {\\n    triggers($(this), 'open');\\n  });\\n\\n  // Elements with [data-close] will close a plugin that supports it when clicked.\\n  // If used without a value on [data-close], the event will bubble, allowing it to close a parent component.\\n  $(document).on('click.zf.trigger', '[data-close]', function () {\\n    var id = $(this).data('close');\\n    if (id) {\\n      triggers($(this), 'close');\\n    } else {\\n      $(this).trigger('close.zf.trigger');\\n    }\\n  });\\n\\n  // Elements with [data-toggle] will toggle a plugin that supports it when clicked.\\n  $(document).on('click.zf.trigger', '[data-toggle]', function () {\\n    triggers($(this), 'toggle');\\n  });\\n\\n  // Elements with [data-closable] will respond to close.zf.trigger events.\\n  $(document).on('close.zf.trigger', '[data-closable]', function (e) {\\n    e.stopPropagation();\\n    var animation = $(this).data('closable');\\n\\n    if (animation !== '') {\\n      Foundation.Motion.animateOut($(this), animation, function () {\\n        $(this).trigger('closed.zf');\\n      });\\n    } else {\\n      $(this).fadeOut().trigger('closed.zf');\\n    }\\n  });\\n\\n  $(document).on('focus.zf.trigger blur.zf.trigger', '[data-toggle-focus]', function () {\\n    var id = $(this).data('toggle-focus');\\n    $('#' + id).triggerHandler('toggle.zf.trigger', [$(this)]);\\n  });\\n\\n  /**\\n  * Fires once after all other scripts have loaded\\n  * @function\\n  * @private\\n  */\\n  $(window).load(function () {\\n    checkListeners();\\n  });\\n\\n  function checkListeners() {\\n    eventsListener();\\n    resizeListener();\\n    scrollListener();\\n    closemeListener();\\n  }\\n\\n  //******** only fires this function once on load, if there's something to watch ********\\n  function closemeListener(pluginName) {\\n    var yetiBoxes = $('[data-yeti-box]'),\\n        plugNames = ['dropdown', 'tooltip', 'reveal'];\\n\\n    if (pluginName) {\\n      if (typeof pluginName === 'string') {\\n        plugNames.push(pluginName);\\n      } else if (typeof pluginName === 'object' && typeof pluginName[0] === 'string') {\\n        plugNames.concat(pluginName);\\n      } else {\\n        console.error('Plugin names must be strings');\\n      }\\n    }\\n    if (yetiBoxes.length) {\\n      var listeners = plugNames.map(function (name) {\\n        return 'closeme.zf.' + name;\\n      }).join(' ');\\n\\n      $(window).off(listeners).on(listeners, function (e, pluginId) {\\n        var plugin = e.namespace.split('.')[0];\\n        var plugins = $('[data-' + plugin + ']').not('[data-yeti-box=\\\"' + pluginId + '\\\"]');\\n\\n        plugins.each(function () {\\n          var _this = $(this);\\n\\n          _this.triggerHandler('close.zf.trigger', [_this]);\\n        });\\n      });\\n    }\\n  }\\n\\n  function resizeListener(debounce) {\\n    var timer = void 0,\\n        $nodes = $('[data-resize]');\\n    if ($nodes.length) {\\n      $(window).off('resize.zf.trigger').on('resize.zf.trigger', function (e) {\\n        if (timer) {\\n          clearTimeout(timer);\\n        }\\n\\n        timer = setTimeout(function () {\\n\\n          if (!MutationObserver) {\\n            //fallback for IE 9\\n            $nodes.each(function () {\\n              $(this).triggerHandler('resizeme.zf.trigger');\\n            });\\n          }\\n          //trigger all listening elements and signal a resize event\\n          $nodes.attr('data-events', \\\"resize\\\");\\n        }, debounce || 10); //default time to emit resize event\\n      });\\n    }\\n  }\\n\\n  function scrollListener(debounce) {\\n    var timer = void 0,\\n        $nodes = $('[data-scroll]');\\n    if ($nodes.length) {\\n      $(window).off('scroll.zf.trigger').on('scroll.zf.trigger', function (e) {\\n        if (timer) {\\n          clearTimeout(timer);\\n        }\\n\\n        timer = setTimeout(function () {\\n\\n          if (!MutationObserver) {\\n            //fallback for IE 9\\n            $nodes.each(function () {\\n              $(this).triggerHandler('scrollme.zf.trigger');\\n            });\\n          }\\n          //trigger all listening elements and signal a scroll event\\n          $nodes.attr('data-events', \\\"scroll\\\");\\n        }, debounce || 10); //default time to emit scroll event\\n      });\\n    }\\n  }\\n\\n  function eventsListener() {\\n    if (!MutationObserver) {\\n      return false;\\n    }\\n    var nodes = document.querySelectorAll('[data-resize], [data-scroll], [data-mutate]');\\n\\n    //element callback\\n    var listeningElementsMutation = function (mutationRecordsList) {\\n      var $target = $(mutationRecordsList[0].target);\\n      //trigger the event handler for the element depending on type\\n      switch ($target.attr(\\\"data-events\\\")) {\\n\\n        case \\\"resize\\\":\\n          $target.triggerHandler('resizeme.zf.trigger', [$target]);\\n          break;\\n\\n        case \\\"scroll\\\":\\n          $target.triggerHandler('scrollme.zf.trigger', [$target, window.pageYOffset]);\\n          break;\\n\\n        // case \\\"mutate\\\" :\\n        // console.log('mutate', $target);\\n        // $target.triggerHandler('mutate.zf.trigger');\\n        //\\n        // //make sure we don't get stuck in an infinite loop from sloppy codeing\\n        // if ($target.index('[data-mutate]') == $(\\\"[data-mutate]\\\").length-1) {\\n        //   domMutationObserver();\\n        // }\\n        // break;\\n\\n        default:\\n          return false;\\n        //nothing\\n      }\\n    };\\n\\n    if (nodes.length) {\\n      //for each element that needs to listen for resizing, scrolling, (or coming soon mutation) add a single observer\\n      for (var i = 0; i <= nodes.length - 1; i++) {\\n        var elementObserver = new MutationObserver(listeningElementsMutation);\\n        elementObserver.observe(nodes[i], { attributes: true, childList: false, characterData: false, subtree: false, attributeFilter: [\\\"data-events\\\"] });\\n      }\\n    }\\n  }\\n\\n  // ------------------------------------\\n\\n  // [PH]\\n  // Foundation.CheckWatchers = checkWatchers;\\n  Foundation.IHearYou = checkListeners;\\n  // Foundation.ISeeYou = scrollListener;\\n  // Foundation.IFeelYou = closemeListener;\\n}(jQuery);\\n\\n// function domMutationObserver(debounce) {\\n//   // !!! This is coming soon and needs more work; not active  !!! //\\n//   var timer,\\n//   nodes = document.querySelectorAll('[data-mutate]');\\n//   //\\n//   if (nodes.length) {\\n//     // var MutationObserver = (function () {\\n//     //   var prefixes = ['WebKit', 'Moz', 'O', 'Ms', ''];\\n//     //   for (var i=0; i < prefixes.length; i++) {\\n//     //     if (prefixes[i] + 'MutationObserver' in window) {\\n//     //       return window[prefixes[i] + 'MutationObserver'];\\n//     //     }\\n//     //   }\\n//     //   return false;\\n//     // }());\\n//\\n//\\n//     //for the body, we need to listen for all changes effecting the style and class attributes\\n//     var bodyObserver = new MutationObserver(bodyMutation);\\n//     bodyObserver.observe(document.body, { attributes: true, childList: true, characterData: false, subtree:true, attributeFilter:[\\\"style\\\", \\\"class\\\"]});\\n//\\n//\\n//     //body callback\\n//     function bodyMutation(mutate) {\\n//       //trigger all listening elements and signal a mutation event\\n//       if (timer) { clearTimeout(timer); }\\n//\\n//       timer = setTimeout(function() {\\n//         bodyObserver.disconnect();\\n//         $('[data-mutate]').attr('data-events',\\\"mutate\\\");\\n//       }, debounce || 150);\\n//     }\\n//   }\\n// }\\n'use strict';\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n!function ($) {\\n\\n  /**\\n   * Abide module.\\n   * @module foundation.abide\\n   */\\n\\n  var Abide = function () {\\n    /**\\n     * Creates a new instance of Abide.\\n     * @class\\n     * @fires Abide#init\\n     * @param {Object} element - jQuery object to add the trigger to.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n\\n    function Abide(element) {\\n      var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\\n\\n      _classCallCheck(this, Abide);\\n\\n      this.$element = element;\\n      this.options = $.extend({}, Abide.defaults, this.$element.data(), options);\\n\\n      this._init();\\n\\n      Foundation.registerPlugin(this, 'Abide');\\n    }\\n\\n    /**\\n     * Initializes the Abide plugin and calls functions to get Abide functioning on load.\\n     * @private\\n     */\\n\\n\\n    _createClass(Abide, [{\\n      key: '_init',\\n      value: function _init() {\\n        this.$inputs = this.$element.find('input, textarea, select');\\n\\n        this._events();\\n      }\\n\\n      /**\\n       * Initializes events for Abide.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_events',\\n      value: function _events() {\\n        var _this2 = this;\\n\\n        this.$element.off('.abide').on('reset.zf.abide', function () {\\n          _this2.resetForm();\\n        }).on('submit.zf.abide', function () {\\n          return _this2.validateForm();\\n        });\\n\\n        if (this.options.validateOn === 'fieldChange') {\\n          this.$inputs.off('change.zf.abide').on('change.zf.abide', function (e) {\\n            _this2.validateInput($(e.target));\\n          });\\n        }\\n\\n        if (this.options.liveValidate) {\\n          this.$inputs.off('input.zf.abide').on('input.zf.abide', function (e) {\\n            _this2.validateInput($(e.target));\\n          });\\n        }\\n      }\\n\\n      /**\\n       * Calls necessary functions to update Abide upon DOM change\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_reflow',\\n      value: function _reflow() {\\n        this._init();\\n      }\\n\\n      /**\\n       * Checks whether or not a form element has the required attribute and if it's checked or not\\n       * @param {Object} element - jQuery object to check for required attribute\\n       * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty\\n       */\\n\\n    }, {\\n      key: 'requiredCheck',\\n      value: function requiredCheck($el) {\\n        if (!$el.attr('required')) return true;\\n\\n        var isGood = true;\\n\\n        switch ($el[0].type) {\\n          case 'checkbox':\\n            isGood = $el[0].checked;\\n            break;\\n\\n          case 'select':\\n          case 'select-one':\\n          case 'select-multiple':\\n            var opt = $el.find('option:selected');\\n            if (!opt.length || !opt.val()) isGood = false;\\n            break;\\n\\n          default:\\n            if (!$el.val() || !$el.val().length) isGood = false;\\n        }\\n\\n        return isGood;\\n      }\\n\\n      /**\\n       * Based on $el, get the first element with selector in this order:\\n       * 1. The element's direct sibling('s).\\n       * 3. The element's parent's children.\\n       *\\n       * This allows for multiple form errors per input, though if none are found, no form errors will be shown.\\n       *\\n       * @param {Object} $el - jQuery object to use as reference to find the form error selector.\\n       * @returns {Object} jQuery object with the selector.\\n       */\\n\\n    }, {\\n      key: 'findFormError',\\n      value: function findFormError($el) {\\n        var $error = $el.siblings(this.options.formErrorSelector);\\n\\n        if (!$error.length) {\\n          $error = $el.parent().find(this.options.formErrorSelector);\\n        }\\n\\n        return $error;\\n      }\\n\\n      /**\\n       * Get the first element in this order:\\n       * 2. The <label> with the attribute `[for=\\\"someInputId\\\"]`\\n       * 3. The `.closest()` <label>\\n       *\\n       * @param {Object} $el - jQuery object to check for required attribute\\n       * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty\\n       */\\n\\n    }, {\\n      key: 'findLabel',\\n      value: function findLabel($el) {\\n        var id = $el[0].id;\\n        var $label = this.$element.find('label[for=\\\"' + id + '\\\"]');\\n\\n        if (!$label.length) {\\n          return $el.closest('label');\\n        }\\n\\n        return $label;\\n      }\\n\\n      /**\\n       * Get the set of labels associated with a set of radio els in this order\\n       * 2. The <label> with the attribute `[for=\\\"someInputId\\\"]`\\n       * 3. The `.closest()` <label>\\n       *\\n       * @param {Object} $el - jQuery object to check for required attribute\\n       * @returns {Boolean} Boolean value depends on whether or not attribute is checked or empty\\n       */\\n\\n    }, {\\n      key: 'findRadioLabels',\\n      value: function findRadioLabels($els) {\\n        var _this3 = this;\\n\\n        var labels = $els.map(function (i, el) {\\n          var id = el.id;\\n          var $label = _this3.$element.find('label[for=\\\"' + id + '\\\"]');\\n\\n          if (!$label.length) {\\n            $label = $(el).closest('label');\\n          }\\n          return $label[0];\\n        });\\n\\n        return $(labels);\\n      }\\n\\n      /**\\n       * Adds the CSS error class as specified by the Abide settings to the label, input, and the form\\n       * @param {Object} $el - jQuery object to add the class to\\n       */\\n\\n    }, {\\n      key: 'addErrorClasses',\\n      value: function addErrorClasses($el) {\\n        var $label = this.findLabel($el);\\n        var $formError = this.findFormError($el);\\n\\n        if ($label.length) {\\n          $label.addClass(this.options.labelErrorClass);\\n        }\\n\\n        if ($formError.length) {\\n          $formError.addClass(this.options.formErrorClass);\\n        }\\n\\n        $el.addClass(this.options.inputErrorClass).attr('data-invalid', '');\\n      }\\n\\n      /**\\n       * Remove CSS error classes etc from an entire radio button group\\n       * @param {String} groupName - A string that specifies the name of a radio button group\\n       *\\n       */\\n\\n    }, {\\n      key: 'removeRadioErrorClasses',\\n      value: function removeRadioErrorClasses(groupName) {\\n        var $els = this.$element.find(':radio[name=\\\"' + groupName + '\\\"]');\\n        var $labels = this.findRadioLabels($els);\\n        var $formErrors = this.findFormError($els);\\n\\n        if ($labels.length) {\\n          $labels.removeClass(this.options.labelErrorClass);\\n        }\\n\\n        if ($formErrors.length) {\\n          $formErrors.removeClass(this.options.formErrorClass);\\n        }\\n\\n        $els.removeClass(this.options.inputErrorClass).removeAttr('data-invalid');\\n      }\\n\\n      /**\\n       * Removes CSS error class as specified by the Abide settings from the label, input, and the form\\n       * @param {Object} $el - jQuery object to remove the class from\\n       */\\n\\n    }, {\\n      key: 'removeErrorClasses',\\n      value: function removeErrorClasses($el) {\\n        // radios need to clear all of the els\\n        if ($el[0].type == 'radio') {\\n          return this.removeRadioErrorClasses($el.attr('name'));\\n        }\\n\\n        var $label = this.findLabel($el);\\n        var $formError = this.findFormError($el);\\n\\n        if ($label.length) {\\n          $label.removeClass(this.options.labelErrorClass);\\n        }\\n\\n        if ($formError.length) {\\n          $formError.removeClass(this.options.formErrorClass);\\n        }\\n\\n        $el.removeClass(this.options.inputErrorClass).removeAttr('data-invalid');\\n      }\\n\\n      /**\\n       * Goes through a form to find inputs and proceeds to validate them in ways specific to their type\\n       * @fires Abide#invalid\\n       * @fires Abide#valid\\n       * @param {Object} element - jQuery object to validate, should be an HTML input\\n       * @returns {Boolean} goodToGo - If the input is valid or not.\\n       */\\n\\n    }, {\\n      key: 'validateInput',\\n      value: function validateInput($el) {\\n        var clearRequire = this.requiredCheck($el),\\n            validated = false,\\n            customValidator = true,\\n            validator = $el.attr('data-validator'),\\n            equalTo = true;\\n\\n        // don't validate ignored inputs or hidden inputs\\n        if ($el.is('[data-abide-ignore]') || $el.is('[type=\\\"hidden\\\"]')) {\\n          return true;\\n        }\\n\\n        switch ($el[0].type) {\\n          case 'radio':\\n            validated = this.validateRadio($el.attr('name'));\\n            break;\\n\\n          case 'checkbox':\\n            validated = clearRequire;\\n            break;\\n\\n          case 'select':\\n          case 'select-one':\\n          case 'select-multiple':\\n            validated = clearRequire;\\n            break;\\n\\n          default:\\n            validated = this.validateText($el);\\n        }\\n\\n        if (validator) {\\n          customValidator = this.matchValidation($el, validator, $el.attr('required'));\\n        }\\n\\n        if ($el.attr('data-equalto')) {\\n          equalTo = this.options.validators.equalTo($el);\\n        }\\n\\n        var goodToGo = [clearRequire, validated, customValidator, equalTo].indexOf(false) === -1;\\n        var message = (goodToGo ? 'valid' : 'invalid') + '.zf.abide';\\n\\n        this[goodToGo ? 'removeErrorClasses' : 'addErrorClasses']($el);\\n\\n        /**\\n         * Fires when the input is done checking for validation. Event trigger is either `valid.zf.abide` or `invalid.zf.abide`\\n         * Trigger includes the DOM element of the input.\\n         * @event Abide#valid\\n         * @event Abide#invalid\\n         */\\n        $el.trigger(message, [$el]);\\n\\n        return goodToGo;\\n      }\\n\\n      /**\\n       * Goes through a form and if there are any invalid inputs, it will display the form error element\\n       * @returns {Boolean} noError - true if no errors were detected...\\n       * @fires Abide#formvalid\\n       * @fires Abide#forminvalid\\n       */\\n\\n    }, {\\n      key: 'validateForm',\\n      value: function validateForm() {\\n        var acc = [];\\n        var _this = this;\\n\\n        this.$inputs.each(function () {\\n          acc.push(_this.validateInput($(this)));\\n        });\\n\\n        var noError = acc.indexOf(false) === -1;\\n\\n        this.$element.find('[data-abide-error]').css('display', noError ? 'none' : 'block');\\n\\n        /**\\n         * Fires when the form is finished validating. Event trigger is either `formvalid.zf.abide` or `forminvalid.zf.abide`.\\n         * Trigger includes the element of the form.\\n         * @event Abide#formvalid\\n         * @event Abide#forminvalid\\n         */\\n        this.$element.trigger((noError ? 'formvalid' : 'forminvalid') + '.zf.abide', [this.$element]);\\n\\n        return noError;\\n      }\\n\\n      /**\\n       * Determines whether or a not a text input is valid based on the pattern specified in the attribute. If no matching pattern is found, returns true.\\n       * @param {Object} $el - jQuery object to validate, should be a text input HTML element\\n       * @param {String} pattern - string value of one of the RegEx patterns in Abide.options.patterns\\n       * @returns {Boolean} Boolean value depends on whether or not the input value matches the pattern specified\\n       */\\n\\n    }, {\\n      key: 'validateText',\\n      value: function validateText($el, pattern) {\\n        // A pattern can be passed to this function, or it will be infered from the input's \\\"pattern\\\" attribute, or it's \\\"type\\\" attribute\\n        pattern = pattern || $el.attr('pattern') || $el.attr('type');\\n        var inputText = $el.val();\\n        var valid = false;\\n\\n        if (inputText.length) {\\n          // If the pattern attribute on the element is in Abide's list of patterns, then test that regexp\\n          if (this.options.patterns.hasOwnProperty(pattern)) {\\n            valid = this.options.patterns[pattern].test(inputText);\\n          }\\n          // If the pattern name isn't also the type attribute of the field, then test it as a regexp\\n          else if (pattern !== $el.attr('type')) {\\n              valid = new RegExp(pattern).test(inputText);\\n            } else {\\n              valid = true;\\n            }\\n        }\\n        // An empty field is valid if it's not required\\n        else if (!$el.prop('required')) {\\n            valid = true;\\n          }\\n\\n        return valid;\\n      }\\n\\n      /**\\n       * Determines whether or a not a radio input is valid based on whether or not it is required and selected. Although the function targets a single `<input>`, it validates by checking the `required` and `checked` properties of all radio buttons in its group.\\n       * @param {String} groupName - A string that specifies the name of a radio button group\\n       * @returns {Boolean} Boolean value depends on whether or not at least one radio input has been selected (if it's required)\\n       */\\n\\n    }, {\\n      key: 'validateRadio',\\n      value: function validateRadio(groupName) {\\n        // If at least one radio in the group has the `required` attribute, the group is considered required\\n        // Per W3C spec, all radio buttons in a group should have `required`, but we're being nice\\n        var $group = this.$element.find(':radio[name=\\\"' + groupName + '\\\"]');\\n        var valid = false,\\n            required = false;\\n\\n        // For the group to be required, at least one radio needs to be required\\n        $group.each(function (i, e) {\\n          if ($(e).attr('required')) {\\n            required = true;\\n          }\\n        });\\n        if (!required) valid = true;\\n\\n        if (!valid) {\\n          // For the group to be valid, at least one radio needs to be checked\\n          $group.each(function (i, e) {\\n            if ($(e).prop('checked')) {\\n              valid = true;\\n            }\\n          });\\n        };\\n\\n        return valid;\\n      }\\n\\n      /**\\n       * Determines if a selected input passes a custom validation function. Multiple validations can be used, if passed to the element with `data-validator=\\\"foo bar baz\\\"` in a space separated listed.\\n       * @param {Object} $el - jQuery input element.\\n       * @param {String} validators - a string of function names matching functions in the Abide.options.validators object.\\n       * @param {Boolean} required - self explanatory?\\n       * @returns {Boolean} - true if validations passed.\\n       */\\n\\n    }, {\\n      key: 'matchValidation',\\n      value: function matchValidation($el, validators, required) {\\n        var _this4 = this;\\n\\n        required = required ? true : false;\\n\\n        var clear = validators.split(' ').map(function (v) {\\n          return _this4.options.validators[v]($el, required, $el.parent());\\n        });\\n        return clear.indexOf(false) === -1;\\n      }\\n\\n      /**\\n       * Resets form inputs and styles\\n       * @fires Abide#formreset\\n       */\\n\\n    }, {\\n      key: 'resetForm',\\n      value: function resetForm() {\\n        var $form = this.$element,\\n            opts = this.options;\\n\\n        $('.' + opts.labelErrorClass, $form).not('small').removeClass(opts.labelErrorClass);\\n        $('.' + opts.inputErrorClass, $form).not('small').removeClass(opts.inputErrorClass);\\n        $(opts.formErrorSelector + '.' + opts.formErrorClass).removeClass(opts.formErrorClass);\\n        $form.find('[data-abide-error]').css('display', 'none');\\n        $(':input', $form).not(':button, :submit, :reset, :hidden, :radio, :checkbox, [data-abide-ignore]').val('').removeAttr('data-invalid');\\n        $(':input:radio', $form).not('[data-abide-ignore]').prop('checked', false).removeAttr('data-invalid');\\n        $(':input:checkbox', $form).not('[data-abide-ignore]').prop('checked', false).removeAttr('data-invalid');\\n        /**\\n         * Fires when the form has been reset.\\n         * @event Abide#formreset\\n         */\\n        $form.trigger('formreset.zf.abide', [$form]);\\n      }\\n\\n      /**\\n       * Destroys an instance of Abide.\\n       * Removes error styles and classes from elements, without resetting their values.\\n       */\\n\\n    }, {\\n      key: 'destroy',\\n      value: function destroy() {\\n        var _this = this;\\n        this.$element.off('.abide').find('[data-abide-error]').css('display', 'none');\\n\\n        this.$inputs.off('.abide').each(function () {\\n          _this.removeErrorClasses($(this));\\n        });\\n\\n        Foundation.unregisterPlugin(this);\\n      }\\n    }]);\\n\\n    return Abide;\\n  }();\\n\\n  /**\\n   * Default settings for plugin\\n   */\\n\\n\\n  Abide.defaults = {\\n    /**\\n     * The default event to validate inputs. Checkboxes and radios validate immediately.\\n     * Remove or change this value for manual validation.\\n     * @option\\n     * @example 'fieldChange'\\n     */\\n    validateOn: 'fieldChange',\\n\\n    /**\\n     * Class to be applied to input labels on failed validation.\\n     * @option\\n     * @example 'is-invalid-label'\\n     */\\n    labelErrorClass: 'is-invalid-label',\\n\\n    /**\\n     * Class to be applied to inputs on failed validation.\\n     * @option\\n     * @example 'is-invalid-input'\\n     */\\n    inputErrorClass: 'is-invalid-input',\\n\\n    /**\\n     * Class selector to use to target Form Errors for show/hide.\\n     * @option\\n     * @example '.form-error'\\n     */\\n    formErrorSelector: '.form-error',\\n\\n    /**\\n     * Class added to Form Errors on failed validation.\\n     * @option\\n     * @example 'is-visible'\\n     */\\n    formErrorClass: 'is-visible',\\n\\n    /**\\n     * Set to true to validate text inputs on any value change.\\n     * @option\\n     * @example false\\n     */\\n    liveValidate: false,\\n\\n    patterns: {\\n      alpha: /^[a-zA-Z]+$/,\\n      alpha_numeric: /^[a-zA-Z0-9]+$/,\\n      integer: /^[-+]?\\\\d+$/,\\n      number: /^[-+]?\\\\d*(?:[\\\\.\\\\,]\\\\d+)?$/,\\n\\n      // amex, visa, diners\\n      card: /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\\\d{3})\\\\d{11})$/,\\n      cvv: /^([0-9]){3,4}$/,\\n\\n      // http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#valid-e-mail-address\\n      email: /^[a-zA-Z0-9.!#$%&'*+\\\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,\\n\\n      url: /^(https?|ftp|file|ssh):\\\\/\\\\/(((([a-zA-Z]|\\\\d|-|\\\\.|_|~|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])|(%[\\\\da-f]{2})|[!\\\\$&'\\\\(\\\\)\\\\*\\\\+,;=]|:)*@)?(((\\\\d|[1-9]\\\\d|1\\\\d\\\\d|2[0-4]\\\\d|25[0-5])\\\\.(\\\\d|[1-9]\\\\d|1\\\\d\\\\d|2[0-4]\\\\d|25[0-5])\\\\.(\\\\d|[1-9]\\\\d|1\\\\d\\\\d|2[0-4]\\\\d|25[0-5])\\\\.(\\\\d|[1-9]\\\\d|1\\\\d\\\\d|2[0-4]\\\\d|25[0-5]))|((([a-zA-Z]|\\\\d|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])|(([a-zA-Z]|\\\\d|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])([a-zA-Z]|\\\\d|-|\\\\.|_|~|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])*([a-zA-Z]|\\\\d|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])))\\\\.)+(([a-zA-Z]|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])|(([a-zA-Z]|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])([a-zA-Z]|\\\\d|-|\\\\.|_|~|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])*([a-zA-Z]|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])))\\\\.?)(:\\\\d*)?)(\\\\/((([a-zA-Z]|\\\\d|-|\\\\.|_|~|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])|(%[\\\\da-f]{2})|[!\\\\$&'\\\\(\\\\)\\\\*\\\\+,;=]|:|@)+(\\\\/(([a-zA-Z]|\\\\d|-|\\\\.|_|~|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])|(%[\\\\da-f]{2})|[!\\\\$&'\\\\(\\\\)\\\\*\\\\+,;=]|:|@)*)*)?)?(\\\\?((([a-zA-Z]|\\\\d|-|\\\\.|_|~|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])|(%[\\\\da-f]{2})|[!\\\\$&'\\\\(\\\\)\\\\*\\\\+,;=]|:|@)|[\\\\uE000-\\\\uF8FF]|\\\\/|\\\\?)*)?(\\\\#((([a-zA-Z]|\\\\d|-|\\\\.|_|~|[\\\\u00A0-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF])|(%[\\\\da-f]{2})|[!\\\\$&'\\\\(\\\\)\\\\*\\\\+,;=]|:|@)|\\\\/|\\\\?)*)?$/,\\n      // abc.de\\n      domain: /^([a-zA-Z0-9]([a-zA-Z0-9\\\\-]{0,61}[a-zA-Z0-9])?\\\\.)+[a-zA-Z]{2,8}$/,\\n\\n      datetime: /^([0-2][0-9]{3})\\\\-([0-1][0-9])\\\\-([0-3][0-9])T([0-5][0-9])\\\\:([0-5][0-9])\\\\:([0-5][0-9])(Z|([\\\\-\\\\+]([0-1][0-9])\\\\:00))$/,\\n      // YYYY-MM-DD\\n      date: /(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,\\n      // HH:MM:SS\\n      time: /^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,\\n      dateISO: /^\\\\d{4}[\\\\/\\\\-]\\\\d{1,2}[\\\\/\\\\-]\\\\d{1,2}$/,\\n      // MM/DD/YYYY\\n      month_day_year: /^(0[1-9]|1[012])[- \\\\/.](0[1-9]|[12][0-9]|3[01])[- \\\\/.]\\\\d{4}$/,\\n      // DD/MM/YYYY\\n      day_month_year: /^(0[1-9]|[12][0-9]|3[01])[- \\\\/.](0[1-9]|1[012])[- \\\\/.]\\\\d{4}$/,\\n\\n      // #FFF or #FFFFFF\\n      color: /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/\\n    },\\n\\n    /**\\n     * Optional validation functions to be used. `equalTo` being the only default included function.\\n     * Functions should return only a boolean if the input is valid or not. Functions are given the following arguments:\\n     * el : The jQuery element to validate.\\n     * required : Boolean value of the required attribute be present or not.\\n     * parent : The direct parent of the input.\\n     * @option\\n     */\\n    validators: {\\n      equalTo: function (el, required, parent) {\\n        return $('#' + el.attr('data-equalto')).val() === el.val();\\n      }\\n    }\\n  };\\n\\n  // Window exports\\n  Foundation.plugin(Abide, 'Abide');\\n}(jQuery);\\n'use strict';\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n!function ($) {\\n\\n  /**\\n   * Accordion module.\\n   * @module foundation.accordion\\n   * @requires foundation.util.keyboard\\n   * @requires foundation.util.motion\\n   */\\n\\n  var Accordion = function () {\\n    /**\\n     * Creates a new instance of an accordion.\\n     * @class\\n     * @fires Accordion#init\\n     * @param {jQuery} element - jQuery object to make into an accordion.\\n     * @param {Object} options - a plain object with settings to override the default options.\\n     */\\n\\n    function Accordion(element, options) {\\n      _classCallCheck(this, Accordion);\\n\\n      this.$element = element;\\n      this.options = $.extend({}, Accordion.defaults, this.$element.data(), options);\\n\\n      this._init();\\n\\n      Foundation.registerPlugin(this, 'Accordion');\\n      Foundation.Keyboard.register('Accordion', {\\n        'ENTER': 'toggle',\\n        'SPACE': 'toggle',\\n        'ARROW_DOWN': 'next',\\n        'ARROW_UP': 'previous'\\n      });\\n    }\\n\\n    /**\\n     * Initializes the accordion by animating the preset active pane(s).\\n     * @private\\n     */\\n\\n\\n    _createClass(Accordion, [{\\n      key: '_init',\\n      value: function _init() {\\n        this.$element.attr('role', 'tablist');\\n        this.$tabs = this.$element.children('li, [data-accordion-item]');\\n\\n        this.$tabs.each(function (idx, el) {\\n          var $el = $(el),\\n              $content = $el.children('[data-tab-content]'),\\n              id = $content[0].id || Foundation.GetYoDigits(6, 'accordion'),\\n              linkId = el.id || id + '-label';\\n\\n          $el.find('a:first').attr({\\n            'aria-controls': id,\\n            'role': 'tab',\\n            'id': linkId,\\n            'aria-expanded': false,\\n            'aria-selected': false\\n          });\\n\\n          $content.attr({ 'role': 'tabpanel', 'aria-labelledby': linkId, 'aria-hidden': true, 'id': id });\\n        });\\n        var $initActive = this.$element.find('.is-active').children('[data-tab-content]');\\n        if ($initActive.length) {\\n          this.down($initActive, true);\\n        }\\n        this._events();\\n      }\\n\\n      /**\\n       * Adds event handlers for items within the accordion.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_events',\\n      value: function _events() {\\n        var _this = this;\\n\\n        this.$tabs.each(function () {\\n          var $elem = $(this);\\n          var $tabContent = $elem.children('[data-tab-content]');\\n          if ($tabContent.length) {\\n            $elem.children('a').off('click.zf.accordion keydown.zf.accordion').on('click.zf.accordion', function (e) {\\n              // $(this).children('a').on('click.zf.accordion', function(e) {\\n              e.preventDefault();\\n              if ($elem.hasClass('is-active')) {\\n                if (_this.options.allowAllClosed || $elem.siblings().hasClass('is-active')) {\\n                  _this.up($tabContent);\\n                }\\n              } else {\\n                _this.down($tabContent);\\n              }\\n            }).on('keydown.zf.accordion', function (e) {\\n              Foundation.Keyboard.handleKey(e, 'Accordion', {\\n                toggle: function () {\\n                  _this.toggle($tabContent);\\n                },\\n                next: function () {\\n                  var $a = $elem.next().find('a').focus();\\n                  if (!_this.options.multiExpand) {\\n                    $a.trigger('click.zf.accordion');\\n                  }\\n                },\\n                previous: function () {\\n                  var $a = $elem.prev().find('a').focus();\\n                  if (!_this.options.multiExpand) {\\n                    $a.trigger('click.zf.accordion');\\n                  }\\n                },\\n                handled: function () {\\n                  e.preventDefault();\\n                  e.stopPropagation();\\n                }\\n              });\\n            });\\n          }\\n        });\\n      }\\n\\n      /**\\n       * Toggles the selected content pane's open/close state.\\n       * @param {jQuery} $target - jQuery object of the pane to toggle.\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'toggle',\\n      value: function toggle($target) {\\n        if ($target.parent().hasClass('is-active')) {\\n          if (this.options.allowAllClosed || $target.parent().siblings().hasClass('is-active')) {\\n            this.up($target);\\n          } else {\\n            return;\\n          }\\n        } else {\\n          this.down($target);\\n        }\\n      }\\n\\n      /**\\n       * Opens the accordion tab defined by `$target`.\\n       * @param {jQuery} $target - Accordion pane to open.\\n       * @param {Boolean} firstTime - flag to determine if reflow should happen.\\n       * @fires Accordion#down\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'down',\\n      value: function down($target, firstTime) {\\n        var _this2 = this;\\n\\n        if (!this.options.multiExpand && !firstTime) {\\n          var $currentActive = this.$element.children('.is-active').children('[data-tab-content]');\\n          if ($currentActive.length) {\\n            this.up($currentActive);\\n          }\\n        }\\n\\n        $target.attr('aria-hidden', false).parent('[data-tab-content]').addBack().parent().addClass('is-active');\\n\\n        $target.slideDown(this.options.slideSpeed, function () {\\n          /**\\n           * Fires when the tab is done opening.\\n           * @event Accordion#down\\n           */\\n          _this2.$element.trigger('down.zf.accordion', [$target]);\\n        });\\n\\n        $('#' + $target.attr('aria-labelledby')).attr({\\n          'aria-expanded': true,\\n          'aria-selected': true\\n        });\\n      }\\n\\n      /**\\n       * Closes the tab defined by `$target`.\\n       * @param {jQuery} $target - Accordion tab to close.\\n       * @fires Accordion#up\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'up',\\n      value: function up($target) {\\n        var $aunts = $target.parent().siblings(),\\n            _this = this;\\n        var canClose = this.options.multiExpand ? $aunts.hasClass('is-active') : $target.parent().hasClass('is-active');\\n\\n        if (!this.options.allowAllClosed && !canClose) {\\n          return;\\n        }\\n\\n        // Foundation.Move(this.options.slideSpeed, $target, function(){\\n        $target.slideUp(_this.options.slideSpeed, function () {\\n          /**\\n           * Fires when the tab is done collapsing up.\\n           * @event Accordion#up\\n           */\\n          _this.$element.trigger('up.zf.accordion', [$target]);\\n        });\\n        // });\\n\\n        $target.attr('aria-hidden', true).parent().removeClass('is-active');\\n\\n        $('#' + $target.attr('aria-labelledby')).attr({\\n          'aria-expanded': false,\\n          'aria-selected': false\\n        });\\n      }\\n\\n      /**\\n       * Destroys an instance of an accordion.\\n       * @fires Accordion#destroyed\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'destroy',\\n      value: function destroy() {\\n        this.$element.find('[data-tab-content]').stop(true).slideUp(0).css('display', '');\\n        this.$element.find('a').off('.zf.accordion');\\n\\n        Foundation.unregisterPlugin(this);\\n      }\\n    }]);\\n\\n    return Accordion;\\n  }();\\n\\n  Accordion.defaults = {\\n    /**\\n     * Amount of time to animate the opening of an accordion pane.\\n     * @option\\n     * @example 250\\n     */\\n    slideSpeed: 250,\\n    /**\\n     * Allow the accordion to have multiple open panes.\\n     * @option\\n     * @example false\\n     */\\n    multiExpand: false,\\n    /**\\n     * Allow the accordion to close all panes.\\n     * @option\\n     * @example false\\n     */\\n    allowAllClosed: false\\n  };\\n\\n  // Window exports\\n  Foundation.plugin(Accordion, 'Accordion');\\n}(jQuery);\\n'use strict';\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n!function ($) {\\n\\n  /**\\n   * AccordionMenu module.\\n   * @module foundation.accordionMenu\\n   * @requires foundation.util.keyboard\\n   * @requires foundation.util.motion\\n   * @requires foundation.util.nest\\n   */\\n\\n  var AccordionMenu = function () {\\n    /**\\n     * Creates a new instance of an accordion menu.\\n     * @class\\n     * @fires AccordionMenu#init\\n     * @param {jQuery} element - jQuery object to make into an accordion menu.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n\\n    function AccordionMenu(element, options) {\\n      _classCallCheck(this, AccordionMenu);\\n\\n      this.$element = element;\\n      this.options = $.extend({}, AccordionMenu.defaults, this.$element.data(), options);\\n\\n      Foundation.Nest.Feather(this.$element, 'accordion');\\n\\n      this._init();\\n\\n      Foundation.registerPlugin(this, 'AccordionMenu');\\n      Foundation.Keyboard.register('AccordionMenu', {\\n        'ENTER': 'toggle',\\n        'SPACE': 'toggle',\\n        'ARROW_RIGHT': 'open',\\n        'ARROW_UP': 'up',\\n        'ARROW_DOWN': 'down',\\n        'ARROW_LEFT': 'close',\\n        'ESCAPE': 'closeAll',\\n        'TAB': 'down',\\n        'SHIFT_TAB': 'up'\\n      });\\n    }\\n\\n    /**\\n     * Initializes the accordion menu by hiding all nested menus.\\n     * @private\\n     */\\n\\n\\n    _createClass(AccordionMenu, [{\\n      key: '_init',\\n      value: function _init() {\\n        this.$element.find('[data-submenu]').not('.is-active').slideUp(0); //.find('a').css('padding-left', '1rem');\\n        this.$element.attr({\\n          'role': 'tablist',\\n          'aria-multiselectable': this.options.multiOpen\\n        });\\n\\n        this.$menuLinks = this.$element.find('.is-accordion-submenu-parent');\\n        this.$menuLinks.each(function () {\\n          var linkId = this.id || Foundation.GetYoDigits(6, 'acc-menu-link'),\\n              $elem = $(this),\\n              $sub = $elem.children('[data-submenu]'),\\n              subId = $sub[0].id || Foundation.GetYoDigits(6, 'acc-menu'),\\n              isActive = $sub.hasClass('is-active');\\n          $elem.attr({\\n            'aria-controls': subId,\\n            'aria-expanded': isActive,\\n            'role': 'tab',\\n            'id': linkId\\n          });\\n          $sub.attr({\\n            'aria-labelledby': linkId,\\n            'aria-hidden': !isActive,\\n            'role': 'tabpanel',\\n            'id': subId\\n          });\\n        });\\n        var initPanes = this.$element.find('.is-active');\\n        if (initPanes.length) {\\n          var _this = this;\\n          initPanes.each(function () {\\n            _this.down($(this));\\n          });\\n        }\\n        this._events();\\n      }\\n\\n      /**\\n       * Adds event handlers for items within the menu.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_events',\\n      value: function _events() {\\n        var _this = this;\\n\\n        this.$element.find('li').each(function () {\\n          var $submenu = $(this).children('[data-submenu]');\\n\\n          if ($submenu.length) {\\n            $(this).children('a').off('click.zf.accordionMenu').on('click.zf.accordionMenu', function (e) {\\n              e.preventDefault();\\n\\n              _this.toggle($submenu);\\n            });\\n          }\\n        }).on('keydown.zf.accordionmenu', function (e) {\\n          var $element = $(this),\\n              $elements = $element.parent('ul').children('li'),\\n              $prevElement,\\n              $nextElement,\\n              $target = $element.children('[data-submenu]');\\n\\n          $elements.each(function (i) {\\n            if ($(this).is($element)) {\\n              $prevElement = $elements.eq(Math.max(0, i - 1)).find('a').first();\\n              $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1)).find('a').first();\\n\\n              if ($(this).children('[data-submenu]:visible').length) {\\n                // has open sub menu\\n                $nextElement = $element.find('li:first-child').find('a').first();\\n              }\\n              if ($(this).is(':first-child')) {\\n                // is first element of sub menu\\n                $prevElement = $element.parents('li').first().find('a').first();\\n              } else if ($prevElement.children('[data-submenu]:visible').length) {\\n                // if previous element has open sub menu\\n                $prevElement = $prevElement.find('li:last-child').find('a').first();\\n              }\\n              if ($(this).is(':last-child')) {\\n                // is last element of sub menu\\n                $nextElement = $element.parents('li').first().next('li').find('a').first();\\n              }\\n\\n              return;\\n            }\\n          });\\n          Foundation.Keyboard.handleKey(e, 'AccordionMenu', {\\n            open: function () {\\n              if ($target.is(':hidden')) {\\n                _this.down($target);\\n                $target.find('li').first().find('a').first().focus();\\n              }\\n            },\\n            close: function () {\\n              if ($target.length && !$target.is(':hidden')) {\\n                // close active sub of this item\\n                _this.up($target);\\n              } else if ($element.parent('[data-submenu]').length) {\\n                // close currently open sub\\n                _this.up($element.parent('[data-submenu]'));\\n                $element.parents('li').first().find('a').first().focus();\\n              }\\n            },\\n            up: function () {\\n              $prevElement.attr('tabindex', -1).focus();\\n              return true;\\n            },\\n            down: function () {\\n              $nextElement.attr('tabindex', -1).focus();\\n              return true;\\n            },\\n            toggle: function () {\\n              if ($element.children('[data-submenu]').length) {\\n                _this.toggle($element.children('[data-submenu]'));\\n              }\\n            },\\n            closeAll: function () {\\n              _this.hideAll();\\n            },\\n            handled: function (preventDefault) {\\n              if (preventDefault) {\\n                e.preventDefault();\\n              }\\n              e.stopImmediatePropagation();\\n            }\\n          });\\n        }); //.attr('tabindex', 0);\\n      }\\n\\n      /**\\n       * Closes all panes of the menu.\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'hideAll',\\n      value: function hideAll() {\\n        this.$element.find('[data-submenu]').slideUp(this.options.slideSpeed);\\n      }\\n\\n      /**\\n       * Toggles the open/close state of a submenu.\\n       * @function\\n       * @param {jQuery} $target - the submenu to toggle\\n       */\\n\\n    }, {\\n      key: 'toggle',\\n      value: function toggle($target) {\\n        if (!$target.is(':animated')) {\\n          if (!$target.is(':hidden')) {\\n            this.up($target);\\n          } else {\\n            this.down($target);\\n          }\\n        }\\n      }\\n\\n      /**\\n       * Opens the sub-menu defined by `$target`.\\n       * @param {jQuery} $target - Sub-menu to open.\\n       * @fires AccordionMenu#down\\n       */\\n\\n    }, {\\n      key: 'down',\\n      value: function down($target) {\\n        var _this = this;\\n\\n        if (!this.options.multiOpen) {\\n          this.up(this.$element.find('.is-active').not($target.parentsUntil(this.$element).add($target)));\\n        }\\n\\n        $target.addClass('is-active').attr({ 'aria-hidden': false }).parent('.is-accordion-submenu-parent').attr({ 'aria-expanded': true });\\n\\n        //Foundation.Move(this.options.slideSpeed, $target, function() {\\n        $target.slideDown(_this.options.slideSpeed, function () {\\n          /**\\n           * Fires when the menu is done opening.\\n           * @event AccordionMenu#down\\n           */\\n          _this.$element.trigger('down.zf.accordionMenu', [$target]);\\n        });\\n        //});\\n      }\\n\\n      /**\\n       * Closes the sub-menu defined by `$target`. All sub-menus inside the target will be closed as well.\\n       * @param {jQuery} $target - Sub-menu to close.\\n       * @fires AccordionMenu#up\\n       */\\n\\n    }, {\\n      key: 'up',\\n      value: function up($target) {\\n        var _this = this;\\n        //Foundation.Move(this.options.slideSpeed, $target, function(){\\n        $target.slideUp(_this.options.slideSpeed, function () {\\n          /**\\n           * Fires when the menu is done collapsing up.\\n           * @event AccordionMenu#up\\n           */\\n          _this.$element.trigger('up.zf.accordionMenu', [$target]);\\n        });\\n        //});\\n\\n        var $menus = $target.find('[data-submenu]').slideUp(0).addBack().attr('aria-hidden', true);\\n\\n        $menus.parent('.is-accordion-submenu-parent').attr('aria-expanded', false);\\n      }\\n\\n      /**\\n       * Destroys an instance of accordion menu.\\n       * @fires AccordionMenu#destroyed\\n       */\\n\\n    }, {\\n      key: 'destroy',\\n      value: function destroy() {\\n        this.$element.find('[data-submenu]').slideDown(0).css('display', '');\\n        this.$element.find('a').off('click.zf.accordionMenu');\\n\\n        Foundation.Nest.Burn(this.$element, 'accordion');\\n        Foundation.unregisterPlugin(this);\\n      }\\n    }]);\\n\\n    return AccordionMenu;\\n  }();\\n\\n  AccordionMenu.defaults = {\\n    /**\\n     * Amount of time to animate the opening of a submenu in ms.\\n     * @option\\n     * @example 250\\n     */\\n    slideSpeed: 250,\\n    /**\\n     * Allow the menu to have multiple open panes.\\n     * @option\\n     * @example true\\n     */\\n    multiOpen: true\\n  };\\n\\n  // Window exports\\n  Foundation.plugin(AccordionMenu, 'AccordionMenu');\\n}(jQuery);\\n'use strict';\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n!function ($) {\\n\\n  /**\\n   * Drilldown module.\\n   * @module foundation.drilldown\\n   * @requires foundation.util.keyboard\\n   * @requires foundation.util.motion\\n   * @requires foundation.util.nest\\n   */\\n\\n  var Drilldown = function () {\\n    /**\\n     * Creates a new instance of a drilldown menu.\\n     * @class\\n     * @param {jQuery} element - jQuery object to make into an accordion menu.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n\\n    function Drilldown(element, options) {\\n      _classCallCheck(this, Drilldown);\\n\\n      this.$element = element;\\n      this.options = $.extend({}, Drilldown.defaults, this.$element.data(), options);\\n\\n      Foundation.Nest.Feather(this.$element, 'drilldown');\\n\\n      this._init();\\n\\n      Foundation.registerPlugin(this, 'Drilldown');\\n      Foundation.Keyboard.register('Drilldown', {\\n        'ENTER': 'open',\\n        'SPACE': 'open',\\n        'ARROW_RIGHT': 'next',\\n        'ARROW_UP': 'up',\\n        'ARROW_DOWN': 'down',\\n        'ARROW_LEFT': 'previous',\\n        'ESCAPE': 'close',\\n        'TAB': 'down',\\n        'SHIFT_TAB': 'up'\\n      });\\n    }\\n\\n    /**\\n     * Initializes the drilldown by creating jQuery collections of elements\\n     * @private\\n     */\\n\\n\\n    _createClass(Drilldown, [{\\n      key: '_init',\\n      value: function _init() {\\n        this.$submenuAnchors = this.$element.find('li.is-drilldown-submenu-parent').children('a');\\n        this.$submenus = this.$submenuAnchors.parent('li').children('[data-submenu]');\\n        this.$menuItems = this.$element.find('li').not('.js-drilldown-back').attr('role', 'menuitem').find('a');\\n\\n        this._prepareMenu();\\n\\n        this._keyboardEvents();\\n      }\\n\\n      /**\\n       * prepares drilldown menu by setting attributes to links and elements\\n       * sets a min height to prevent content jumping\\n       * wraps the element if not already wrapped\\n       * @private\\n       * @function\\n       */\\n\\n    }, {\\n      key: '_prepareMenu',\\n      value: function _prepareMenu() {\\n        var _this = this;\\n        // if(!this.options.holdOpen){\\n        //   this._menuLinkEvents();\\n        // }\\n        this.$submenuAnchors.each(function () {\\n          var $link = $(this);\\n          var $sub = $link.parent();\\n          if (_this.options.parentLink) {\\n            $link.clone().prependTo($sub.children('[data-submenu]')).wrap('<li class=\\\"is-submenu-parent-item is-submenu-item is-drilldown-submenu-item\\\" role=\\\"menu-item\\\"></li>');\\n          }\\n          $link.data('savedHref', $link.attr('href')).removeAttr('href');\\n          $link.children('[data-submenu]').attr({\\n            'aria-hidden': true,\\n            'tabindex': 0,\\n            'role': 'menu'\\n          });\\n          _this._events($link);\\n        });\\n        this.$submenus.each(function () {\\n          var $menu = $(this),\\n              $back = $menu.find('.js-drilldown-back');\\n          if (!$back.length) {\\n            $menu.prepend(_this.options.backButton);\\n          }\\n          _this._back($menu);\\n        });\\n        if (!this.$element.parent().hasClass('is-drilldown')) {\\n          this.$wrapper = $(this.options.wrapper).addClass('is-drilldown');\\n          this.$wrapper = this.$element.wrap(this.$wrapper).parent().css(this._getMaxDims());\\n        }\\n      }\\n\\n      /**\\n       * Adds event handlers to elements in the menu.\\n       * @function\\n       * @private\\n       * @param {jQuery} $elem - the current menu item to add handlers to.\\n       */\\n\\n    }, {\\n      key: '_events',\\n      value: function _events($elem) {\\n        var _this = this;\\n\\n        $elem.off('click.zf.drilldown').on('click.zf.drilldown', function (e) {\\n          if ($(e.target).parentsUntil('ul', 'li').hasClass('is-drilldown-submenu-parent')) {\\n            e.stopImmediatePropagation();\\n            e.preventDefault();\\n          }\\n\\n          // if(e.target !== e.currentTarget.firstElementChild){\\n          //   return false;\\n          // }\\n          _this._show($elem.parent('li'));\\n\\n          if (_this.options.closeOnClick) {\\n            var $body = $('body');\\n            $body.off('.zf.drilldown').on('click.zf.drilldown', function (e) {\\n              if (e.target === _this.$element[0] || $.contains(_this.$element[0], e.target)) {\\n                return;\\n              }\\n              e.preventDefault();\\n              _this._hideAll();\\n              $body.off('.zf.drilldown');\\n            });\\n          }\\n        });\\n      }\\n\\n      /**\\n       * Adds keydown event listener to `li`'s in the menu.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_keyboardEvents',\\n      value: function _keyboardEvents() {\\n        var _this = this;\\n\\n        this.$menuItems.add(this.$element.find('.js-drilldown-back > a')).on('keydown.zf.drilldown', function (e) {\\n\\n          var $element = $(this),\\n              $elements = $element.parent('li').parent('ul').children('li').children('a'),\\n              $prevElement,\\n              $nextElement;\\n\\n          $elements.each(function (i) {\\n            if ($(this).is($element)) {\\n              $prevElement = $elements.eq(Math.max(0, i - 1));\\n              $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1));\\n              return;\\n            }\\n          });\\n\\n          Foundation.Keyboard.handleKey(e, 'Drilldown', {\\n            next: function () {\\n              if ($element.is(_this.$submenuAnchors)) {\\n                _this._show($element.parent('li'));\\n                $element.parent('li').one(Foundation.transitionend($element), function () {\\n                  $element.parent('li').find('ul li a').filter(_this.$menuItems).first().focus();\\n                });\\n                return true;\\n              }\\n            },\\n            previous: function () {\\n              _this._hide($element.parent('li').parent('ul'));\\n              $element.parent('li').parent('ul').one(Foundation.transitionend($element), function () {\\n                setTimeout(function () {\\n                  $element.parent('li').parent('ul').parent('li').children('a').first().focus();\\n                }, 1);\\n              });\\n              return true;\\n            },\\n            up: function () {\\n              $prevElement.focus();\\n              return true;\\n            },\\n            down: function () {\\n              $nextElement.focus();\\n              return true;\\n            },\\n            close: function () {\\n              _this._back();\\n              //_this.$menuItems.first().focus(); // focus to first element\\n            },\\n            open: function () {\\n              if (!$element.is(_this.$menuItems)) {\\n                // not menu item means back button\\n                _this._hide($element.parent('li').parent('ul'));\\n                $element.parent('li').parent('ul').one(Foundation.transitionend($element), function () {\\n                  setTimeout(function () {\\n                    $element.parent('li').parent('ul').parent('li').children('a').first().focus();\\n                  }, 1);\\n                });\\n              } else if ($element.is(_this.$submenuAnchors)) {\\n                _this._show($element.parent('li'));\\n                $element.parent('li').one(Foundation.transitionend($element), function () {\\n                  $element.parent('li').find('ul li a').filter(_this.$menuItems).first().focus();\\n                });\\n              }\\n              return true;\\n            },\\n            handled: function (preventDefault) {\\n              if (preventDefault) {\\n                e.preventDefault();\\n              }\\n              e.stopImmediatePropagation();\\n            }\\n          });\\n        }); // end keyboardAccess\\n      }\\n\\n      /**\\n       * Closes all open elements, and returns to root menu.\\n       * @function\\n       * @fires Drilldown#closed\\n       */\\n\\n    }, {\\n      key: '_hideAll',\\n      value: function _hideAll() {\\n        var $elem = this.$element.find('.is-drilldown-submenu.is-active').addClass('is-closing');\\n        $elem.one(Foundation.transitionend($elem), function (e) {\\n          $elem.removeClass('is-active is-closing');\\n        });\\n        /**\\n         * Fires when the menu is fully closed.\\n         * @event Drilldown#closed\\n         */\\n        this.$element.trigger('closed.zf.drilldown');\\n      }\\n\\n      /**\\n       * Adds event listener for each `back` button, and closes open menus.\\n       * @function\\n       * @fires Drilldown#back\\n       * @param {jQuery} $elem - the current sub-menu to add `back` event.\\n       */\\n\\n    }, {\\n      key: '_back',\\n      value: function _back($elem) {\\n        var _this = this;\\n        $elem.off('click.zf.drilldown');\\n        $elem.children('.js-drilldown-back').on('click.zf.drilldown', function (e) {\\n          e.stopImmediatePropagation();\\n          // console.log('mouseup on back');\\n          _this._hide($elem);\\n        });\\n      }\\n\\n      /**\\n       * Adds event listener to menu items w/o submenus to close open menus on click.\\n       * @function\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_menuLinkEvents',\\n      value: function _menuLinkEvents() {\\n        var _this = this;\\n        this.$menuItems.not('.is-drilldown-submenu-parent').off('click.zf.drilldown').on('click.zf.drilldown', function (e) {\\n          // e.stopImmediatePropagation();\\n          setTimeout(function () {\\n            _this._hideAll();\\n          }, 0);\\n        });\\n      }\\n\\n      /**\\n       * Opens a submenu.\\n       * @function\\n       * @fires Drilldown#open\\n       * @param {jQuery} $elem - the current element with a submenu to open, i.e. the `li` tag.\\n       */\\n\\n    }, {\\n      key: '_show',\\n      value: function _show($elem) {\\n        $elem.children('[data-submenu]').addClass('is-active');\\n        /**\\n         * Fires when the submenu has opened.\\n         * @event Drilldown#open\\n         */\\n        this.$element.trigger('open.zf.drilldown', [$elem]);\\n      }\\n    }, {\\n      key: '_hide',\\n\\n\\n      /**\\n       * Hides a submenu\\n       * @function\\n       * @fires Drilldown#hide\\n       * @param {jQuery} $elem - the current sub-menu to hide, i.e. the `ul` tag.\\n       */\\n      value: function _hide($elem) {\\n        var _this = this;\\n        $elem.addClass('is-closing').one(Foundation.transitionend($elem), function () {\\n          $elem.removeClass('is-active is-closing');\\n          $elem.blur();\\n        });\\n        /**\\n         * Fires when the submenu has closed.\\n         * @event Drilldown#hide\\n         */\\n        $elem.trigger('hide.zf.drilldown', [$elem]);\\n      }\\n\\n      /**\\n       * Iterates through the nested menus to calculate the min-height, and max-width for the menu.\\n       * Prevents content jumping.\\n       * @function\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_getMaxDims',\\n      value: function _getMaxDims() {\\n        var max = 0,\\n            result = {};\\n        this.$submenus.add(this.$element).each(function () {\\n          var numOfElems = $(this).children('li').length;\\n          max = numOfElems > max ? numOfElems : max;\\n        });\\n\\n        result['min-height'] = max * this.$menuItems[0].getBoundingClientRect().height + 'px';\\n        result['max-width'] = this.$element[0].getBoundingClientRect().width + 'px';\\n\\n        return result;\\n      }\\n\\n      /**\\n       * Destroys the Drilldown Menu\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'destroy',\\n      value: function destroy() {\\n        this._hideAll();\\n        Foundation.Nest.Burn(this.$element, 'drilldown');\\n        this.$element.unwrap().find('.js-drilldown-back, .is-submenu-parent-item').remove().end().find('.is-active, .is-closing, .is-drilldown-submenu').removeClass('is-active is-closing is-drilldown-submenu').end().find('[data-submenu]').removeAttr('aria-hidden tabindex role');\\n        this.$submenuAnchors.each(function () {\\n          $(this).off('.zf.drilldown');\\n        });\\n        this.$element.find('a').each(function () {\\n          var $link = $(this);\\n          if ($link.data('savedHref')) {\\n            $link.attr('href', $link.data('savedHref')).removeData('savedHref');\\n          } else {\\n            return;\\n          }\\n        });\\n        Foundation.unregisterPlugin(this);\\n      }\\n    }]);\\n\\n    return Drilldown;\\n  }();\\n\\n  Drilldown.defaults = {\\n    /**\\n     * Markup used for JS generated back button. Prepended to submenu lists and deleted on `destroy` method, 'js-drilldown-back' class required. Remove the backslash (`\\\\`) if copy and pasting.\\n     * @option\\n     * @example '<\\\\li><\\\\a>Back<\\\\/a><\\\\/li>'\\n     */\\n    backButton: '<li class=\\\"js-drilldown-back\\\"><a tabindex=\\\"0\\\">Back</a></li>',\\n    /**\\n     * Markup used to wrap drilldown menu. Use a class name for independent styling; the JS applied class: `is-drilldown` is required. Remove the backslash (`\\\\`) if copy and pasting.\\n     * @option\\n     * @example '<\\\\div class=\\\"is-drilldown\\\"><\\\\/div>'\\n     */\\n    wrapper: '<div></div>',\\n    /**\\n     * Adds the parent link to the submenu.\\n     * @option\\n     * @example false\\n     */\\n    parentLink: false,\\n    /**\\n     * Allow the menu to return to root list on body click.\\n     * @option\\n     * @example false\\n     */\\n    closeOnClick: false\\n    // holdOpen: false\\n  };\\n\\n  // Window exports\\n  Foundation.plugin(Drilldown, 'Drilldown');\\n}(jQuery);\\n'use strict';\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n!function ($) {\\n\\n  /**\\n   * Dropdown module.\\n   * @module foundation.dropdown\\n   * @requires foundation.util.keyboard\\n   * @requires foundation.util.box\\n   * @requires foundation.util.triggers\\n   */\\n\\n  var Dropdown = function () {\\n    /**\\n     * Creates a new instance of a dropdown.\\n     * @class\\n     * @param {jQuery} element - jQuery object to make into a dropdown.\\n     *        Object should be of the dropdown panel, rather than its anchor.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n\\n    function Dropdown(element, options) {\\n      _classCallCheck(this, Dropdown);\\n\\n      this.$element = element;\\n      this.options = $.extend({}, Dropdown.defaults, this.$element.data(), options);\\n      this._init();\\n\\n      Foundation.registerPlugin(this, 'Dropdown');\\n      Foundation.Keyboard.register('Dropdown', {\\n        'ENTER': 'open',\\n        'SPACE': 'open',\\n        'ESCAPE': 'close',\\n        'TAB': 'tab_forward',\\n        'SHIFT_TAB': 'tab_backward'\\n      });\\n    }\\n\\n    /**\\n     * Initializes the plugin by setting/checking options and attributes, adding helper variables, and saving the anchor.\\n     * @function\\n     * @private\\n     */\\n\\n\\n    _createClass(Dropdown, [{\\n      key: '_init',\\n      value: function _init() {\\n        var $id = this.$element.attr('id');\\n\\n        this.$anchor = $('[data-toggle=\\\"' + $id + '\\\"]') || $('[data-open=\\\"' + $id + '\\\"]');\\n        this.$anchor.attr({\\n          'aria-controls': $id,\\n          'data-is-focus': false,\\n          'data-yeti-box': $id,\\n          'aria-haspopup': true,\\n          'aria-expanded': false\\n\\n        });\\n\\n        this.options.positionClass = this.getPositionClass();\\n        this.counter = 4;\\n        this.usedPositions = [];\\n        this.$element.attr({\\n          'aria-hidden': 'true',\\n          'data-yeti-box': $id,\\n          'data-resize': $id,\\n          'aria-labelledby': this.$anchor[0].id || Foundation.GetYoDigits(6, 'dd-anchor')\\n        });\\n        this._events();\\n      }\\n\\n      /**\\n       * Helper function to determine current orientation of dropdown pane.\\n       * @function\\n       * @returns {String} position - string value of a position class.\\n       */\\n\\n    }, {\\n      key: 'getPositionClass',\\n      value: function getPositionClass() {\\n        var verticalPosition = this.$element[0].className.match(/(top|left|right|bottom)/g);\\n        verticalPosition = verticalPosition ? verticalPosition[0] : '';\\n        var horizontalPosition = /float-(\\\\S+)\\\\s/.exec(this.$anchor[0].className);\\n        horizontalPosition = horizontalPosition ? horizontalPosition[1] : '';\\n        var position = horizontalPosition ? horizontalPosition + ' ' + verticalPosition : verticalPosition;\\n        return position;\\n      }\\n\\n      /**\\n       * Adjusts the dropdown panes orientation by adding/removing positioning classes.\\n       * @function\\n       * @private\\n       * @param {String} position - position class to remove.\\n       */\\n\\n    }, {\\n      key: '_reposition',\\n      value: function _reposition(position) {\\n        this.usedPositions.push(position ? position : 'bottom');\\n        //default, try switching to opposite side\\n        if (!position && this.usedPositions.indexOf('top') < 0) {\\n          this.$element.addClass('top');\\n        } else if (position === 'top' && this.usedPositions.indexOf('bottom') < 0) {\\n          this.$element.removeClass(position);\\n        } else if (position === 'left' && this.usedPositions.indexOf('right') < 0) {\\n          this.$element.removeClass(position).addClass('right');\\n        } else if (position === 'right' && this.usedPositions.indexOf('left') < 0) {\\n          this.$element.removeClass(position).addClass('left');\\n        }\\n\\n        //if default change didn't work, try bottom or left first\\n        else if (!position && this.usedPositions.indexOf('top') > -1 && this.usedPositions.indexOf('left') < 0) {\\n            this.$element.addClass('left');\\n          } else if (position === 'top' && this.usedPositions.indexOf('bottom') > -1 && this.usedPositions.indexOf('left') < 0) {\\n            this.$element.removeClass(position).addClass('left');\\n          } else if (position === 'left' && this.usedPositions.indexOf('right') > -1 && this.usedPositions.indexOf('bottom') < 0) {\\n            this.$element.removeClass(position);\\n          } else if (position === 'right' && this.usedPositions.indexOf('left') > -1 && this.usedPositions.indexOf('bottom') < 0) {\\n            this.$element.removeClass(position);\\n          }\\n          //if nothing cleared, set to bottom\\n          else {\\n              this.$element.removeClass(position);\\n            }\\n        this.classChanged = true;\\n        this.counter--;\\n      }\\n\\n      /**\\n       * Sets the position and orientation of the dropdown pane, checks for collisions.\\n       * Recursively calls itself if a collision is detected, with a new position class.\\n       * @function\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_setPosition',\\n      value: function _setPosition() {\\n        if (this.$anchor.attr('aria-expanded') === 'false') {\\n          return false;\\n        }\\n        var position = this.getPositionClass(),\\n            $eleDims = Foundation.Box.GetDimensions(this.$element),\\n            $anchorDims = Foundation.Box.GetDimensions(this.$anchor),\\n            _this = this,\\n            direction = position === 'left' ? 'left' : position === 'right' ? 'left' : 'top',\\n            param = direction === 'top' ? 'height' : 'width',\\n            offset = param === 'height' ? this.options.vOffset : this.options.hOffset;\\n\\n        if ($eleDims.width >= $eleDims.windowDims.width || !this.counter && !Foundation.Box.ImNotTouchingYou(this.$element)) {\\n          this.$element.offset(Foundation.Box.GetOffsets(this.$element, this.$anchor, 'center bottom', this.options.vOffset, this.options.hOffset, true)).css({\\n            'width': $eleDims.windowDims.width - this.options.hOffset * 2,\\n            'height': 'auto'\\n          });\\n          this.classChanged = true;\\n          return false;\\n        }\\n\\n        this.$element.offset(Foundation.Box.GetOffsets(this.$element, this.$anchor, position, this.options.vOffset, this.options.hOffset));\\n\\n        while (!Foundation.Box.ImNotTouchingYou(this.$element, false, true) && this.counter) {\\n          this._reposition(position);\\n          this._setPosition();\\n        }\\n      }\\n\\n      /**\\n       * Adds event listeners to the element utilizing the triggers utility library.\\n       * @function\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_events',\\n      value: function _events() {\\n        var _this = this;\\n        this.$element.on({\\n          'open.zf.trigger': this.open.bind(this),\\n          'close.zf.trigger': this.close.bind(this),\\n          'toggle.zf.trigger': this.toggle.bind(this),\\n          'resizeme.zf.trigger': this._setPosition.bind(this)\\n        });\\n\\n        if (this.options.hover) {\\n          this.$anchor.off('mouseenter.zf.dropdown mouseleave.zf.dropdown').on('mouseenter.zf.dropdown', function () {\\n            clearTimeout(_this.timeout);\\n            _this.timeout = setTimeout(function () {\\n              _this.open();\\n              _this.$anchor.data('hover', true);\\n            }, _this.options.hoverDelay);\\n          }).on('mouseleave.zf.dropdown', function () {\\n            clearTimeout(_this.timeout);\\n            _this.timeout = setTimeout(function () {\\n              _this.close();\\n              _this.$anchor.data('hover', false);\\n            }, _this.options.hoverDelay);\\n          });\\n          if (this.options.hoverPane) {\\n            this.$element.off('mouseenter.zf.dropdown mouseleave.zf.dropdown').on('mouseenter.zf.dropdown', function () {\\n              clearTimeout(_this.timeout);\\n            }).on('mouseleave.zf.dropdown', function () {\\n              clearTimeout(_this.timeout);\\n              _this.timeout = setTimeout(function () {\\n                _this.close();\\n                _this.$anchor.data('hover', false);\\n              }, _this.options.hoverDelay);\\n            });\\n          }\\n        }\\n        this.$anchor.add(this.$element).on('keydown.zf.dropdown', function (e) {\\n\\n          var $target = $(this),\\n              visibleFocusableElements = Foundation.Keyboard.findFocusable(_this.$element);\\n\\n          Foundation.Keyboard.handleKey(e, 'Dropdown', {\\n            tab_forward: function () {\\n              if (_this.$element.find(':focus').is(visibleFocusableElements.eq(-1))) {\\n                // left modal downwards, setting focus to first element\\n                if (_this.options.trapFocus) {\\n                  // if focus shall be trapped\\n                  visibleFocusableElements.eq(0).focus();\\n                  e.preventDefault();\\n                } else {\\n                  // if focus is not trapped, close dropdown on focus out\\n                  _this.close();\\n                }\\n              }\\n            },\\n            tab_backward: function () {\\n              if (_this.$element.find(':focus').is(visibleFocusableElements.eq(0)) || _this.$element.is(':focus')) {\\n                // left modal upwards, setting focus to last element\\n                if (_this.options.trapFocus) {\\n                  // if focus shall be trapped\\n                  visibleFocusableElements.eq(-1).focus();\\n                  e.preventDefault();\\n                } else {\\n                  // if focus is not trapped, close dropdown on focus out\\n                  _this.close();\\n                }\\n              }\\n            },\\n            open: function () {\\n              if ($target.is(_this.$anchor)) {\\n                _this.open();\\n                _this.$element.attr('tabindex', -1).focus();\\n                e.preventDefault();\\n              }\\n            },\\n            close: function () {\\n              _this.close();\\n              _this.$anchor.focus();\\n            }\\n          });\\n        });\\n      }\\n\\n      /**\\n       * Adds an event handler to the body to close any dropdowns on a click.\\n       * @function\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_addBodyHandler',\\n      value: function _addBodyHandler() {\\n        var $body = $(document.body).not(this.$element),\\n            _this = this;\\n        $body.off('click.zf.dropdown').on('click.zf.dropdown', function (e) {\\n          if (_this.$anchor.is(e.target) || _this.$anchor.find(e.target).length) {\\n            return;\\n          }\\n          if (_this.$element.find(e.target).length) {\\n            return;\\n          }\\n          _this.close();\\n          $body.off('click.zf.dropdown');\\n        });\\n      }\\n\\n      /**\\n       * Opens the dropdown pane, and fires a bubbling event to close other dropdowns.\\n       * @function\\n       * @fires Dropdown#closeme\\n       * @fires Dropdown#show\\n       */\\n\\n    }, {\\n      key: 'open',\\n      value: function open() {\\n        // var _this = this;\\n        /**\\n         * Fires to close other open dropdowns\\n         * @event Dropdown#closeme\\n         */\\n        this.$element.trigger('closeme.zf.dropdown', this.$element.attr('id'));\\n        this.$anchor.addClass('hover').attr({ 'aria-expanded': true });\\n        // this.$element/*.show()*/;\\n        this._setPosition();\\n        this.$element.addClass('is-open').attr({ 'aria-hidden': false });\\n\\n        if (this.options.autoFocus) {\\n          var $focusable = Foundation.Keyboard.findFocusable(this.$element);\\n          if ($focusable.length) {\\n            $focusable.eq(0).focus();\\n          }\\n        }\\n\\n        if (this.options.closeOnClick) {\\n          this._addBodyHandler();\\n        }\\n\\n        /**\\n         * Fires once the dropdown is visible.\\n         * @event Dropdown#show\\n         */\\n        this.$element.trigger('show.zf.dropdown', [this.$element]);\\n      }\\n\\n      /**\\n       * Closes the open dropdown pane.\\n       * @function\\n       * @fires Dropdown#hide\\n       */\\n\\n    }, {\\n      key: 'close',\\n      value: function close() {\\n        if (!this.$element.hasClass('is-open')) {\\n          return false;\\n        }\\n        this.$element.removeClass('is-open').attr({ 'aria-hidden': true });\\n\\n        this.$anchor.removeClass('hover').attr('aria-expanded', false);\\n\\n        if (this.classChanged) {\\n          var curPositionClass = this.getPositionClass();\\n          if (curPositionClass) {\\n            this.$element.removeClass(curPositionClass);\\n          }\\n          this.$element.addClass(this.options.positionClass)\\n          /*.hide()*/.css({ height: '', width: '' });\\n          this.classChanged = false;\\n          this.counter = 4;\\n          this.usedPositions.length = 0;\\n        }\\n        this.$element.trigger('hide.zf.dropdown', [this.$element]);\\n      }\\n\\n      /**\\n       * Toggles the dropdown pane's visibility.\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'toggle',\\n      value: function toggle() {\\n        if (this.$element.hasClass('is-open')) {\\n          if (this.$anchor.data('hover')) return;\\n          this.close();\\n        } else {\\n          this.open();\\n        }\\n      }\\n\\n      /**\\n       * Destroys the dropdown.\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'destroy',\\n      value: function destroy() {\\n        this.$element.off('.zf.trigger').hide();\\n        this.$anchor.off('.zf.dropdown');\\n\\n        Foundation.unregisterPlugin(this);\\n      }\\n    }]);\\n\\n    return Dropdown;\\n  }();\\n\\n  Dropdown.defaults = {\\n    /**\\n     * Amount of time to delay opening a submenu on hover event.\\n     * @option\\n     * @example 250\\n     */\\n    hoverDelay: 250,\\n    /**\\n     * Allow submenus to open on hover events\\n     * @option\\n     * @example false\\n     */\\n    hover: false,\\n    /**\\n     * Don't close dropdown when hovering over dropdown pane\\n     * @option\\n     * @example true\\n     */\\n    hoverPane: false,\\n    /**\\n     * Number of pixels between the dropdown pane and the triggering element on open.\\n     * @option\\n     * @example 1\\n     */\\n    vOffset: 1,\\n    /**\\n     * Number of pixels between the dropdown pane and the triggering element on open.\\n     * @option\\n     * @example 1\\n     */\\n    hOffset: 1,\\n    /**\\n     * Class applied to adjust open position. JS will test and fill this in.\\n     * @option\\n     * @example 'top'\\n     */\\n    positionClass: '',\\n    /**\\n     * Allow the plugin to trap focus to the dropdown pane if opened with keyboard commands.\\n     * @option\\n     * @example false\\n     */\\n    trapFocus: false,\\n    /**\\n     * Allow the plugin to set focus to the first focusable element within the pane, regardless of method of opening.\\n     * @option\\n     * @example true\\n     */\\n    autoFocus: false,\\n    /**\\n     * Allows a click on the body to close the dropdown.\\n     * @option\\n     * @example false\\n     */\\n    closeOnClick: false\\n  };\\n\\n  // Window exports\\n  Foundation.plugin(Dropdown, 'Dropdown');\\n}(jQuery);\\n'use strict';\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n!function ($) {\\n\\n  /**\\n   * DropdownMenu module.\\n   * @module foundation.dropdown-menu\\n   * @requires foundation.util.keyboard\\n   * @requires foundation.util.box\\n   * @requires foundation.util.nest\\n   */\\n\\n  var DropdownMenu = function () {\\n    /**\\n     * Creates a new instance of DropdownMenu.\\n     * @class\\n     * @fires DropdownMenu#init\\n     * @param {jQuery} element - jQuery object to make into a dropdown menu.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n\\n    function DropdownMenu(element, options) {\\n      _classCallCheck(this, DropdownMenu);\\n\\n      this.$element = element;\\n      this.options = $.extend({}, DropdownMenu.defaults, this.$element.data(), options);\\n\\n      Foundation.Nest.Feather(this.$element, 'dropdown');\\n      this._init();\\n\\n      Foundation.registerPlugin(this, 'DropdownMenu');\\n      Foundation.Keyboard.register('DropdownMenu', {\\n        'ENTER': 'open',\\n        'SPACE': 'open',\\n        'ARROW_RIGHT': 'next',\\n        'ARROW_UP': 'up',\\n        'ARROW_DOWN': 'down',\\n        'ARROW_LEFT': 'previous',\\n        'ESCAPE': 'close'\\n      });\\n    }\\n\\n    /**\\n     * Initializes the plugin, and calls _prepareMenu\\n     * @private\\n     * @function\\n     */\\n\\n\\n    _createClass(DropdownMenu, [{\\n      key: '_init',\\n      value: function _init() {\\n        var subs = this.$element.find('li.is-dropdown-submenu-parent');\\n        this.$element.children('.is-dropdown-submenu-parent').children('.is-dropdown-submenu').addClass('first-sub');\\n\\n        this.$menuItems = this.$element.find('[role=\\\"menuitem\\\"]');\\n        this.$tabs = this.$element.children('[role=\\\"menuitem\\\"]');\\n        this.$tabs.find('ul.is-dropdown-submenu').addClass(this.options.verticalClass);\\n\\n        if (this.$element.hasClass(this.options.rightClass) || this.options.alignment === 'right' || Foundation.rtl() || this.$element.parents('.top-bar-right').is('*')) {\\n          this.options.alignment = 'right';\\n          subs.addClass('opens-left');\\n        } else {\\n          subs.addClass('opens-right');\\n        }\\n        this.changed = false;\\n        this._events();\\n      }\\n    }, {\\n      key: '_events',\\n\\n      /**\\n       * Adds event listeners to elements within the menu\\n       * @private\\n       * @function\\n       */\\n      value: function _events() {\\n        var _this = this,\\n            hasTouch = 'ontouchstart' in window || typeof window.ontouchstart !== 'undefined',\\n            parClass = 'is-dropdown-submenu-parent';\\n\\n        // used for onClick and in the keyboard handlers\\n        var handleClickFn = function (e) {\\n          var $elem = $(e.target).parentsUntil('ul', '.' + parClass),\\n              hasSub = $elem.hasClass(parClass),\\n              hasClicked = $elem.attr('data-is-click') === 'true',\\n              $sub = $elem.children('.is-dropdown-submenu');\\n\\n          if (hasSub) {\\n            if (hasClicked) {\\n              if (!_this.options.closeOnClick || !_this.options.clickOpen && !hasTouch || _this.options.forceFollow && hasTouch) {\\n                return;\\n              } else {\\n                e.stopImmediatePropagation();\\n                e.preventDefault();\\n                _this._hide($elem);\\n              }\\n            } else {\\n              e.preventDefault();\\n              e.stopImmediatePropagation();\\n              _this._show($elem.children('.is-dropdown-submenu'));\\n              $elem.add($elem.parentsUntil(_this.$element, '.' + parClass)).attr('data-is-click', true);\\n            }\\n          } else {\\n            return;\\n          }\\n        };\\n\\n        if (this.options.clickOpen || hasTouch) {\\n          this.$menuItems.on('click.zf.dropdownmenu touchstart.zf.dropdownmenu', handleClickFn);\\n        }\\n\\n        if (!this.options.disableHover) {\\n          this.$menuItems.on('mouseenter.zf.dropdownmenu', function (e) {\\n            var $elem = $(this),\\n                hasSub = $elem.hasClass(parClass);\\n\\n            if (hasSub) {\\n              clearTimeout(_this.delay);\\n              _this.delay = setTimeout(function () {\\n                _this._show($elem.children('.is-dropdown-submenu'));\\n              }, _this.options.hoverDelay);\\n            }\\n          }).on('mouseleave.zf.dropdownmenu', function (e) {\\n            var $elem = $(this),\\n                hasSub = $elem.hasClass(parClass);\\n            if (hasSub && _this.options.autoclose) {\\n              if ($elem.attr('data-is-click') === 'true' && _this.options.clickOpen) {\\n                return false;\\n              }\\n\\n              clearTimeout(_this.delay);\\n              _this.delay = setTimeout(function () {\\n                _this._hide($elem);\\n              }, _this.options.closingTime);\\n            }\\n          });\\n        }\\n        this.$menuItems.on('keydown.zf.dropdownmenu', function (e) {\\n          var $element = $(e.target).parentsUntil('ul', '[role=\\\"menuitem\\\"]'),\\n              isTab = _this.$tabs.index($element) > -1,\\n              $elements = isTab ? _this.$tabs : $element.siblings('li').add($element),\\n              $prevElement,\\n              $nextElement;\\n\\n          $elements.each(function (i) {\\n            if ($(this).is($element)) {\\n              $prevElement = $elements.eq(i - 1);\\n              $nextElement = $elements.eq(i + 1);\\n              return;\\n            }\\n          });\\n\\n          var nextSibling = function () {\\n            if (!$element.is(':last-child')) {\\n              $nextElement.children('a:first').focus();\\n              e.preventDefault();\\n            }\\n          },\\n              prevSibling = function () {\\n            $prevElement.children('a:first').focus();\\n            e.preventDefault();\\n          },\\n              openSub = function () {\\n            var $sub = $element.children('ul.is-dropdown-submenu');\\n            if ($sub.length) {\\n              _this._show($sub);\\n              $element.find('li > a:first').focus();\\n              e.preventDefault();\\n            } else {\\n              return;\\n            }\\n          },\\n              closeSub = function () {\\n            //if ($element.is(':first-child')) {\\n            var close = $element.parent('ul').parent('li');\\n            close.children('a:first').focus();\\n            _this._hide(close);\\n            e.preventDefault();\\n            //}\\n          };\\n          var functions = {\\n            open: openSub,\\n            close: function () {\\n              _this._hide(_this.$element);\\n              _this.$menuItems.find('a:first').focus(); // focus to first element\\n              e.preventDefault();\\n            },\\n            handled: function () {\\n              e.stopImmediatePropagation();\\n            }\\n          };\\n\\n          if (isTab) {\\n            if (_this.$element.hasClass(_this.options.verticalClass)) {\\n              // vertical menu\\n              if (_this.options.alignment === 'left') {\\n                // left aligned\\n                $.extend(functions, {\\n                  down: nextSibling,\\n                  up: prevSibling,\\n                  next: openSub,\\n                  previous: closeSub\\n                });\\n              } else {\\n                // right aligned\\n                $.extend(functions, {\\n                  down: nextSibling,\\n                  up: prevSibling,\\n                  next: closeSub,\\n                  previous: openSub\\n                });\\n              }\\n            } else {\\n              // horizontal menu\\n              $.extend(functions, {\\n                next: nextSibling,\\n                previous: prevSibling,\\n                down: openSub,\\n                up: closeSub\\n              });\\n            }\\n          } else {\\n            // not tabs -> one sub\\n            if (_this.options.alignment === 'left') {\\n              // left aligned\\n              $.extend(functions, {\\n                next: openSub,\\n                previous: closeSub,\\n                down: nextSibling,\\n                up: prevSibling\\n              });\\n            } else {\\n              // right aligned\\n              $.extend(functions, {\\n                next: closeSub,\\n                previous: openSub,\\n                down: nextSibling,\\n                up: prevSibling\\n              });\\n            }\\n          }\\n          Foundation.Keyboard.handleKey(e, 'DropdownMenu', functions);\\n        });\\n      }\\n\\n      /**\\n       * Adds an event handler to the body to close any dropdowns on a click.\\n       * @function\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_addBodyHandler',\\n      value: function _addBodyHandler() {\\n        var $body = $(document.body),\\n            _this = this;\\n        $body.off('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu').on('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu', function (e) {\\n          var $link = _this.$element.find(e.target);\\n          if ($link.length) {\\n            return;\\n          }\\n\\n          _this._hide();\\n          $body.off('mouseup.zf.dropdownmenu touchend.zf.dropdownmenu');\\n        });\\n      }\\n\\n      /**\\n       * Opens a dropdown pane, and checks for collisions first.\\n       * @param {jQuery} $sub - ul element that is a submenu to show\\n       * @function\\n       * @private\\n       * @fires DropdownMenu#show\\n       */\\n\\n    }, {\\n      key: '_show',\\n      value: function _show($sub) {\\n        var idx = this.$tabs.index(this.$tabs.filter(function (i, el) {\\n          return $(el).find($sub).length > 0;\\n        }));\\n        var $sibs = $sub.parent('li.is-dropdown-submenu-parent').siblings('li.is-dropdown-submenu-parent');\\n        this._hide($sibs, idx);\\n        $sub.css('visibility', 'hidden').addClass('js-dropdown-active').attr({ 'aria-hidden': false }).parent('li.is-dropdown-submenu-parent').addClass('is-active').attr({ 'aria-expanded': true });\\n        var clear = Foundation.Box.ImNotTouchingYou($sub, null, true);\\n        if (!clear) {\\n          var oldClass = this.options.alignment === 'left' ? '-right' : '-left',\\n              $parentLi = $sub.parent('.is-dropdown-submenu-parent');\\n          $parentLi.removeClass('opens' + oldClass).addClass('opens-' + this.options.alignment);\\n          clear = Foundation.Box.ImNotTouchingYou($sub, null, true);\\n          if (!clear) {\\n            $parentLi.removeClass('opens-' + this.options.alignment).addClass('opens-inner');\\n          }\\n          this.changed = true;\\n        }\\n        $sub.css('visibility', '');\\n        if (this.options.closeOnClick) {\\n          this._addBodyHandler();\\n        }\\n        /**\\n         * Fires when the new dropdown pane is visible.\\n         * @event DropdownMenu#show\\n         */\\n        this.$element.trigger('show.zf.dropdownmenu', [$sub]);\\n      }\\n\\n      /**\\n       * Hides a single, currently open dropdown pane, if passed a parameter, otherwise, hides everything.\\n       * @function\\n       * @param {jQuery} $elem - element with a submenu to hide\\n       * @param {Number} idx - index of the $tabs collection to hide\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_hide',\\n      value: function _hide($elem, idx) {\\n        var $toClose;\\n        if ($elem && $elem.length) {\\n          $toClose = $elem;\\n        } else if (idx !== undefined) {\\n          $toClose = this.$tabs.not(function (i, el) {\\n            return i === idx;\\n          });\\n        } else {\\n          $toClose = this.$element;\\n        }\\n        var somethingToClose = $toClose.hasClass('is-active') || $toClose.find('.is-active').length > 0;\\n\\n        if (somethingToClose) {\\n          $toClose.find('li.is-active').add($toClose).attr({\\n            'aria-expanded': false,\\n            'data-is-click': false\\n          }).removeClass('is-active');\\n\\n          $toClose.find('ul.js-dropdown-active').attr({\\n            'aria-hidden': true\\n          }).removeClass('js-dropdown-active');\\n\\n          if (this.changed || $toClose.find('opens-inner').length) {\\n            var oldClass = this.options.alignment === 'left' ? 'right' : 'left';\\n            $toClose.find('li.is-dropdown-submenu-parent').add($toClose).removeClass('opens-inner opens-' + this.options.alignment).addClass('opens-' + oldClass);\\n            this.changed = false;\\n          }\\n          /**\\n           * Fires when the open menus are closed.\\n           * @event DropdownMenu#hide\\n           */\\n          this.$element.trigger('hide.zf.dropdownmenu', [$toClose]);\\n        }\\n      }\\n\\n      /**\\n       * Destroys the plugin.\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'destroy',\\n      value: function destroy() {\\n        this.$menuItems.off('.zf.dropdownmenu').removeAttr('data-is-click').removeClass('is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner');\\n        $(document.body).off('.zf.dropdownmenu');\\n        Foundation.Nest.Burn(this.$element, 'dropdown');\\n        Foundation.unregisterPlugin(this);\\n      }\\n    }]);\\n\\n    return DropdownMenu;\\n  }();\\n\\n  /**\\n   * Default settings for plugin\\n   */\\n\\n\\n  DropdownMenu.defaults = {\\n    /**\\n     * Disallows hover events from opening submenus\\n     * @option\\n     * @example false\\n     */\\n    disableHover: false,\\n    /**\\n     * Allow a submenu to automatically close on a mouseleave event, if not clicked open.\\n     * @option\\n     * @example true\\n     */\\n    autoclose: true,\\n    /**\\n     * Amount of time to delay opening a submenu on hover event.\\n     * @option\\n     * @example 50\\n     */\\n    hoverDelay: 50,\\n    /**\\n     * Allow a submenu to open/remain open on parent click event. Allows cursor to move away from menu.\\n     * @option\\n     * @example true\\n     */\\n    clickOpen: false,\\n    /**\\n     * Amount of time to delay closing a submenu on a mouseleave event.\\n     * @option\\n     * @example 500\\n     */\\n\\n    closingTime: 500,\\n    /**\\n     * Position of the menu relative to what direction the submenus should open. Handled by JS.\\n     * @option\\n     * @example 'left'\\n     */\\n    alignment: 'left',\\n    /**\\n     * Allow clicks on the body to close any open submenus.\\n     * @option\\n     * @example true\\n     */\\n    closeOnClick: true,\\n    /**\\n     * Class applied to vertical oriented menus, Foundation default is `vertical`. Update this if using your own class.\\n     * @option\\n     * @example 'vertical'\\n     */\\n    verticalClass: 'vertical',\\n    /**\\n     * Class applied to right-side oriented menus, Foundation default is `align-right`. Update this if using your own class.\\n     * @option\\n     * @example 'align-right'\\n     */\\n    rightClass: 'align-right',\\n    /**\\n     * Boolean to force overide the clicking of links to perform default action, on second touch event for mobile.\\n     * @option\\n     * @example false\\n     */\\n    forceFollow: true\\n  };\\n\\n  // Window exports\\n  Foundation.plugin(DropdownMenu, 'DropdownMenu');\\n}(jQuery);\\n'use strict';\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n!function ($) {\\n\\n  /**\\n   * Equalizer module.\\n   * @module foundation.equalizer\\n   */\\n\\n  var Equalizer = function () {\\n    /**\\n     * Creates a new instance of Equalizer.\\n     * @class\\n     * @fires Equalizer#init\\n     * @param {Object} element - jQuery object to add the trigger to.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n\\n    function Equalizer(element, options) {\\n      _classCallCheck(this, Equalizer);\\n\\n      this.$element = element;\\n      this.options = $.extend({}, Equalizer.defaults, this.$element.data(), options);\\n\\n      this._init();\\n\\n      Foundation.registerPlugin(this, 'Equalizer');\\n    }\\n\\n    /**\\n     * Initializes the Equalizer plugin and calls functions to get equalizer functioning on load.\\n     * @private\\n     */\\n\\n\\n    _createClass(Equalizer, [{\\n      key: '_init',\\n      value: function _init() {\\n        var eqId = this.$element.attr('data-equalizer') || '';\\n        var $watched = this.$element.find('[data-equalizer-watch=\\\"' + eqId + '\\\"]');\\n\\n        this.$watched = $watched.length ? $watched : this.$element.find('[data-equalizer-watch]');\\n        this.$element.attr('data-resize', eqId || Foundation.GetYoDigits(6, 'eq'));\\n\\n        this.hasNested = this.$element.find('[data-equalizer]').length > 0;\\n        this.isNested = this.$element.parentsUntil(document.body, '[data-equalizer]').length > 0;\\n        this.isOn = false;\\n        this._bindHandler = {\\n          onResizeMeBound: this._onResizeMe.bind(this),\\n          onPostEqualizedBound: this._onPostEqualized.bind(this)\\n        };\\n\\n        var imgs = this.$element.find('img');\\n        var tooSmall;\\n        if (this.options.equalizeOn) {\\n          tooSmall = this._checkMQ();\\n          $(window).on('changed.zf.mediaquery', this._checkMQ.bind(this));\\n        } else {\\n          this._events();\\n        }\\n        if (tooSmall !== undefined && tooSmall === false || tooSmall === undefined) {\\n          if (imgs.length) {\\n            Foundation.onImagesLoaded(imgs, this._reflow.bind(this));\\n          } else {\\n            this._reflow();\\n          }\\n        }\\n      }\\n\\n      /**\\n       * Removes event listeners if the breakpoint is too small.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_pauseEvents',\\n      value: function _pauseEvents() {\\n        this.isOn = false;\\n        this.$element.off({\\n          '.zf.equalizer': this._bindHandler.onPostEqualizedBound,\\n          'resizeme.zf.trigger': this._bindHandler.onResizeMeBound\\n        });\\n      }\\n\\n      /**\\n       * function to handle $elements resizeme.zf.trigger, with bound this on _bindHandler.onResizeMeBound\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_onResizeMe',\\n      value: function _onResizeMe(e) {\\n        this._reflow();\\n      }\\n\\n      /**\\n       * function to handle $elements postequalized.zf.equalizer, with bound this on _bindHandler.onPostEqualizedBound\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_onPostEqualized',\\n      value: function _onPostEqualized(e) {\\n        if (e.target !== this.$element[0]) {\\n          this._reflow();\\n        }\\n      }\\n\\n      /**\\n       * Initializes events for Equalizer.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_events',\\n      value: function _events() {\\n        var _this = this;\\n        this._pauseEvents();\\n        if (this.hasNested) {\\n          this.$element.on('postequalized.zf.equalizer', this._bindHandler.onPostEqualizedBound);\\n        } else {\\n          this.$element.on('resizeme.zf.trigger', this._bindHandler.onResizeMeBound);\\n        }\\n        this.isOn = true;\\n      }\\n\\n      /**\\n       * Checks the current breakpoint to the minimum required size.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_checkMQ',\\n      value: function _checkMQ() {\\n        var tooSmall = !Foundation.MediaQuery.atLeast(this.options.equalizeOn);\\n        if (tooSmall) {\\n          if (this.isOn) {\\n            this._pauseEvents();\\n            this.$watched.css('height', 'auto');\\n          }\\n        } else {\\n          if (!this.isOn) {\\n            this._events();\\n          }\\n        }\\n        return tooSmall;\\n      }\\n\\n      /**\\n       * A noop version for the plugin\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_killswitch',\\n      value: function _killswitch() {\\n        return;\\n      }\\n\\n      /**\\n       * Calls necessary functions to update Equalizer upon DOM change\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_reflow',\\n      value: function _reflow() {\\n        if (!this.options.equalizeOnStack) {\\n          if (this._isStacked()) {\\n            this.$watched.css('height', 'auto');\\n            return false;\\n          }\\n        }\\n        if (this.options.equalizeByRow) {\\n          this.getHeightsByRow(this.applyHeightByRow.bind(this));\\n        } else {\\n          this.getHeights(this.applyHeight.bind(this));\\n        }\\n      }\\n\\n      /**\\n       * Manually determines if the first 2 elements are *NOT* stacked.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_isStacked',\\n      value: function _isStacked() {\\n        return this.$watched[0].getBoundingClientRect().top !== this.$watched[1].getBoundingClientRect().top;\\n      }\\n\\n      /**\\n       * Finds the outer heights of children contained within an Equalizer parent and returns them in an array\\n       * @param {Function} cb - A non-optional callback to return the heights array to.\\n       * @returns {Array} heights - An array of heights of children within Equalizer container\\n       */\\n\\n    }, {\\n      key: 'getHeights',\\n      value: function getHeights(cb) {\\n        var heights = [];\\n        for (var i = 0, len = this.$watched.length; i < len; i++) {\\n          this.$watched[i].style.height = 'auto';\\n          heights.push(this.$watched[i].offsetHeight);\\n        }\\n        cb(heights);\\n      }\\n\\n      /**\\n       * Finds the outer heights of children contained within an Equalizer parent and returns them in an array\\n       * @param {Function} cb - A non-optional callback to return the heights array to.\\n       * @returns {Array} groups - An array of heights of children within Equalizer container grouped by row with element,height and max as last child\\n       */\\n\\n    }, {\\n      key: 'getHeightsByRow',\\n      value: function getHeightsByRow(cb) {\\n        var lastElTopOffset = this.$watched.length ? this.$watched.first().offset().top : 0,\\n            groups = [],\\n            group = 0;\\n        //group by Row\\n        groups[group] = [];\\n        for (var i = 0, len = this.$watched.length; i < len; i++) {\\n          this.$watched[i].style.height = 'auto';\\n          //maybe could use this.$watched[i].offsetTop\\n          var elOffsetTop = $(this.$watched[i]).offset().top;\\n          if (elOffsetTop != lastElTopOffset) {\\n            group++;\\n            groups[group] = [];\\n            lastElTopOffset = elOffsetTop;\\n          }\\n          groups[group].push([this.$watched[i], this.$watched[i].offsetHeight]);\\n        }\\n\\n        for (var j = 0, ln = groups.length; j < ln; j++) {\\n          var heights = $(groups[j]).map(function () {\\n            return this[1];\\n          }).get();\\n          var max = Math.max.apply(null, heights);\\n          groups[j].push(max);\\n        }\\n        cb(groups);\\n      }\\n\\n      /**\\n       * Changes the CSS height property of each child in an Equalizer parent to match the tallest\\n       * @param {array} heights - An array of heights of children within Equalizer container\\n       * @fires Equalizer#preequalized\\n       * @fires Equalizer#postequalized\\n       */\\n\\n    }, {\\n      key: 'applyHeight',\\n      value: function applyHeight(heights) {\\n        var max = Math.max.apply(null, heights);\\n        /**\\n         * Fires before the heights are applied\\n         * @event Equalizer#preequalized\\n         */\\n        this.$element.trigger('preequalized.zf.equalizer');\\n\\n        this.$watched.css('height', max);\\n\\n        /**\\n         * Fires when the heights have been applied\\n         * @event Equalizer#postequalized\\n         */\\n        this.$element.trigger('postequalized.zf.equalizer');\\n      }\\n\\n      /**\\n       * Changes the CSS height property of each child in an Equalizer parent to match the tallest by row\\n       * @param {array} groups - An array of heights of children within Equalizer container grouped by row with element,height and max as last child\\n       * @fires Equalizer#preequalized\\n       * @fires Equalizer#preequalizedRow\\n       * @fires Equalizer#postequalizedRow\\n       * @fires Equalizer#postequalized\\n       */\\n\\n    }, {\\n      key: 'applyHeightByRow',\\n      value: function applyHeightByRow(groups) {\\n        /**\\n         * Fires before the heights are applied\\n         */\\n        this.$element.trigger('preequalized.zf.equalizer');\\n        for (var i = 0, len = groups.length; i < len; i++) {\\n          var groupsILength = groups[i].length,\\n              max = groups[i][groupsILength - 1];\\n          if (groupsILength <= 2) {\\n            $(groups[i][0][0]).css({ 'height': 'auto' });\\n            continue;\\n          }\\n          /**\\n            * Fires before the heights per row are applied\\n            * @event Equalizer#preequalizedRow\\n            */\\n          this.$element.trigger('preequalizedrow.zf.equalizer');\\n          for (var j = 0, lenJ = groupsILength - 1; j < lenJ; j++) {\\n            $(groups[i][j][0]).css({ 'height': max });\\n          }\\n          /**\\n            * Fires when the heights per row have been applied\\n            * @event Equalizer#postequalizedRow\\n            */\\n          this.$element.trigger('postequalizedrow.zf.equalizer');\\n        }\\n        /**\\n         * Fires when the heights have been applied\\n         */\\n        this.$element.trigger('postequalized.zf.equalizer');\\n      }\\n\\n      /**\\n       * Destroys an instance of Equalizer.\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'destroy',\\n      value: function destroy() {\\n        this._pauseEvents();\\n        this.$watched.css('height', 'auto');\\n\\n        Foundation.unregisterPlugin(this);\\n      }\\n    }]);\\n\\n    return Equalizer;\\n  }();\\n\\n  /**\\n   * Default settings for plugin\\n   */\\n\\n\\n  Equalizer.defaults = {\\n    /**\\n     * Enable height equalization when stacked on smaller screens.\\n     * @option\\n     * @example true\\n     */\\n    equalizeOnStack: true,\\n    /**\\n     * Enable height equalization row by row.\\n     * @option\\n     * @example false\\n     */\\n    equalizeByRow: false,\\n    /**\\n     * String representing the minimum breakpoint size the plugin should equalize heights on.\\n     * @option\\n     * @example 'medium'\\n     */\\n    equalizeOn: ''\\n  };\\n\\n  // Window exports\\n  Foundation.plugin(Equalizer, 'Equalizer');\\n}(jQuery);\\n'use strict';\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n!function ($) {\\n\\n  /**\\n   * Interchange module.\\n   * @module foundation.interchange\\n   * @requires foundation.util.mediaQuery\\n   * @requires foundation.util.timerAndImageLoader\\n   */\\n\\n  var Interchange = function () {\\n    /**\\n     * Creates a new instance of Interchange.\\n     * @class\\n     * @fires Interchange#init\\n     * @param {Object} element - jQuery object to add the trigger to.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n\\n    function Interchange(element, options) {\\n      _classCallCheck(this, Interchange);\\n\\n      this.$element = element;\\n      this.options = $.extend({}, Interchange.defaults, options);\\n      this.rules = [];\\n      this.currentPath = '';\\n\\n      this._init();\\n      this._events();\\n\\n      Foundation.registerPlugin(this, 'Interchange');\\n    }\\n\\n    /**\\n     * Initializes the Interchange plugin and calls functions to get interchange functioning on load.\\n     * @function\\n     * @private\\n     */\\n\\n\\n    _createClass(Interchange, [{\\n      key: '_init',\\n      value: function _init() {\\n        this._addBreakpoints();\\n        this._generateRules();\\n        this._reflow();\\n      }\\n\\n      /**\\n       * Initializes events for Interchange.\\n       * @function\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_events',\\n      value: function _events() {\\n        $(window).on('resize.zf.interchange', Foundation.util.throttle(this._reflow.bind(this), 50));\\n      }\\n\\n      /**\\n       * Calls necessary functions to update Interchange upon DOM change\\n       * @function\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_reflow',\\n      value: function _reflow() {\\n        var match;\\n\\n        // Iterate through each rule, but only save the last match\\n        for (var i in this.rules) {\\n          if (this.rules.hasOwnProperty(i)) {\\n            var rule = this.rules[i];\\n\\n            if (window.matchMedia(rule.query).matches) {\\n              match = rule;\\n            }\\n          }\\n        }\\n\\n        if (match) {\\n          this.replace(match.path);\\n        }\\n      }\\n\\n      /**\\n       * Gets the Foundation breakpoints and adds them to the Interchange.SPECIAL_QUERIES object.\\n       * @function\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_addBreakpoints',\\n      value: function _addBreakpoints() {\\n        for (var i in Foundation.MediaQuery.queries) {\\n          if (Foundation.MediaQuery.queries.hasOwnProperty(i)) {\\n            var query = Foundation.MediaQuery.queries[i];\\n            Interchange.SPECIAL_QUERIES[query.name] = query.value;\\n          }\\n        }\\n      }\\n\\n      /**\\n       * Checks the Interchange element for the provided media query + content pairings\\n       * @function\\n       * @private\\n       * @param {Object} element - jQuery object that is an Interchange instance\\n       * @returns {Array} scenarios - Array of objects that have 'mq' and 'path' keys with corresponding keys\\n       */\\n\\n    }, {\\n      key: '_generateRules',\\n      value: function _generateRules(element) {\\n        var rulesList = [];\\n        var rules;\\n\\n        if (this.options.rules) {\\n          rules = this.options.rules;\\n        } else {\\n          rules = this.$element.data('interchange').match(/\\\\[.*?\\\\]/g);\\n        }\\n\\n        for (var i in rules) {\\n          if (rules.hasOwnProperty(i)) {\\n            var rule = rules[i].slice(1, -1).split(', ');\\n            var path = rule.slice(0, -1).join('');\\n            var query = rule[rule.length - 1];\\n\\n            if (Interchange.SPECIAL_QUERIES[query]) {\\n              query = Interchange.SPECIAL_QUERIES[query];\\n            }\\n\\n            rulesList.push({\\n              path: path,\\n              query: query\\n            });\\n          }\\n        }\\n\\n        this.rules = rulesList;\\n      }\\n\\n      /**\\n       * Update the `src` property of an image, or change the HTML of a container, to the specified path.\\n       * @function\\n       * @param {String} path - Path to the image or HTML partial.\\n       * @fires Interchange#replaced\\n       */\\n\\n    }, {\\n      key: 'replace',\\n      value: function replace(path) {\\n        if (this.currentPath === path) return;\\n\\n        var _this = this,\\n            trigger = 'replaced.zf.interchange';\\n\\n        // Replacing images\\n        if (this.$element[0].nodeName === 'IMG') {\\n          this.$element.attr('src', path).load(function () {\\n            _this.currentPath = path;\\n          }).trigger(trigger);\\n        }\\n        // Replacing background images\\n        else if (path.match(/\\\\.(gif|jpg|jpeg|png|svg|tiff)([?#].*)?/i)) {\\n            this.$element.css({ 'background-image': 'url(' + path + ')' }).trigger(trigger);\\n          }\\n          // Replacing HTML\\n          else {\\n              $.get(path, function (response) {\\n                _this.$element.html(response).trigger(trigger);\\n                $(response).foundation();\\n                _this.currentPath = path;\\n              });\\n            }\\n\\n        /**\\n         * Fires when content in an Interchange element is done being loaded.\\n         * @event Interchange#replaced\\n         */\\n        // this.$element.trigger('replaced.zf.interchange');\\n      }\\n\\n      /**\\n       * Destroys an instance of interchange.\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'destroy',\\n      value: function destroy() {\\n        //TODO this.\\n      }\\n    }]);\\n\\n    return Interchange;\\n  }();\\n\\n  /**\\n   * Default settings for plugin\\n   */\\n\\n\\n  Interchange.defaults = {\\n    /**\\n     * Rules to be applied to Interchange elements. Set with the `data-interchange` array notation.\\n     * @option\\n     */\\n    rules: null\\n  };\\n\\n  Interchange.SPECIAL_QUERIES = {\\n    'landscape': 'screen and (orientation: landscape)',\\n    'portrait': 'screen and (orientation: portrait)',\\n    'retina': 'only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)'\\n  };\\n\\n  // Window exports\\n  Foundation.plugin(Interchange, 'Interchange');\\n}(jQuery);\\n'use strict';\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n!function ($) {\\n\\n  /**\\n   * Magellan module.\\n   * @module foundation.magellan\\n   */\\n\\n  var Magellan = function () {\\n    /**\\n     * Creates a new instance of Magellan.\\n     * @class\\n     * @fires Magellan#init\\n     * @param {Object} element - jQuery object to add the trigger to.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n\\n    function Magellan(element, options) {\\n      _classCallCheck(this, Magellan);\\n\\n      this.$element = element;\\n      this.options = $.extend({}, Magellan.defaults, this.$element.data(), options);\\n\\n      this._init();\\n\\n      Foundation.registerPlugin(this, 'Magellan');\\n    }\\n\\n    /**\\n     * Initializes the Magellan plugin and calls functions to get equalizer functioning on load.\\n     * @private\\n     */\\n\\n\\n    _createClass(Magellan, [{\\n      key: '_init',\\n      value: function _init() {\\n        var id = this.$element[0].id || Foundation.GetYoDigits(6, 'magellan');\\n        var _this = this;\\n        this.$targets = $('[data-magellan-target]');\\n        this.$links = this.$element.find('a');\\n        this.$element.attr({\\n          'data-resize': id,\\n          'data-scroll': id,\\n          'id': id\\n        });\\n        this.$active = $();\\n        this.scrollPos = parseInt(window.pageYOffset, 10);\\n\\n        this._events();\\n      }\\n\\n      /**\\n       * Calculates an array of pixel values that are the demarcation lines between locations on the page.\\n       * Can be invoked if new elements are added or the size of a location changes.\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'calcPoints',\\n      value: function calcPoints() {\\n        var _this = this,\\n            body = document.body,\\n            html = document.documentElement;\\n\\n        this.points = [];\\n        this.winHeight = Math.round(Math.max(window.innerHeight, html.clientHeight));\\n        this.docHeight = Math.round(Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight));\\n\\n        this.$targets.each(function () {\\n          var $tar = $(this),\\n              pt = Math.round($tar.offset().top - _this.options.threshold);\\n          $tar.targetPoint = pt;\\n          _this.points.push(pt);\\n        });\\n      }\\n\\n      /**\\n       * Initializes events for Magellan.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_events',\\n      value: function _events() {\\n        var _this = this,\\n            $body = $('html, body'),\\n            opts = {\\n          duration: _this.options.animationDuration,\\n          easing: _this.options.animationEasing\\n        };\\n        $(window).one('load', function () {\\n          if (_this.options.deepLinking) {\\n            if (location.hash) {\\n              _this.scrollToLoc(location.hash);\\n            }\\n          }\\n          _this.calcPoints();\\n          _this._updateActive();\\n        });\\n\\n        this.$element.on({\\n          'resizeme.zf.trigger': this.reflow.bind(this),\\n          'scrollme.zf.trigger': this._updateActive.bind(this)\\n        }).on('click.zf.magellan', 'a[href^=\\\"#\\\"]', function (e) {\\n          e.preventDefault();\\n          var arrival = this.getAttribute('href');\\n          _this.scrollToLoc(arrival);\\n        });\\n      }\\n\\n      /**\\n       * Function to scroll to a given location on the page.\\n       * @param {String} loc - a properly formatted jQuery id selector. Example: '#foo'\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'scrollToLoc',\\n      value: function scrollToLoc(loc) {\\n        var scrollPos = Math.round($(loc).offset().top - this.options.threshold / 2 - this.options.barOffset);\\n\\n        $('html, body').stop(true).animate({ scrollTop: scrollPos }, this.options.animationDuration, this.options.animationEasing);\\n      }\\n\\n      /**\\n       * Calls necessary functions to update Magellan upon DOM change\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'reflow',\\n      value: function reflow() {\\n        this.calcPoints();\\n        this._updateActive();\\n      }\\n\\n      /**\\n       * Updates the visibility of an active location link, and updates the url hash for the page, if deepLinking enabled.\\n       * @private\\n       * @function\\n       * @fires Magellan#update\\n       */\\n\\n    }, {\\n      key: '_updateActive',\\n      value: function _updateActive() /*evt, elem, scrollPos*/{\\n        var winPos = /*scrollPos ||*/parseInt(window.pageYOffset, 10),\\n            curIdx;\\n\\n        if (winPos + this.winHeight === this.docHeight) {\\n          curIdx = this.points.length - 1;\\n        } else if (winPos < this.points[0]) {\\n          curIdx = 0;\\n        } else {\\n          var isDown = this.scrollPos < winPos,\\n              _this = this,\\n              curVisible = this.points.filter(function (p, i) {\\n            return isDown ? p - _this.options.barOffset <= winPos : p - _this.options.barOffset - _this.options.threshold <= winPos;\\n          });\\n          curIdx = curVisible.length ? curVisible.length - 1 : 0;\\n        }\\n\\n        this.$active.removeClass(this.options.activeClass);\\n        this.$active = this.$links.eq(curIdx).addClass(this.options.activeClass);\\n\\n        if (this.options.deepLinking) {\\n          var hash = this.$active[0].getAttribute('href');\\n          if (window.history.pushState) {\\n            window.history.pushState(null, null, hash);\\n          } else {\\n            window.location.hash = hash;\\n          }\\n        }\\n\\n        this.scrollPos = winPos;\\n        /**\\n         * Fires when magellan is finished updating to the new active element.\\n         * @event Magellan#update\\n         */\\n        this.$element.trigger('update.zf.magellan', [this.$active]);\\n      }\\n\\n      /**\\n       * Destroys an instance of Magellan and resets the url of the window.\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'destroy',\\n      value: function destroy() {\\n        this.$element.off('.zf.trigger .zf.magellan').find('.' + this.options.activeClass).removeClass(this.options.activeClass);\\n\\n        if (this.options.deepLinking) {\\n          var hash = this.$active[0].getAttribute('href');\\n          window.location.hash.replace(hash, '');\\n        }\\n\\n        Foundation.unregisterPlugin(this);\\n      }\\n    }]);\\n\\n    return Magellan;\\n  }();\\n\\n  /**\\n   * Default settings for plugin\\n   */\\n\\n\\n  Magellan.defaults = {\\n    /**\\n     * Amount of time, in ms, the animated scrolling should take between locations.\\n     * @option\\n     * @example 500\\n     */\\n    animationDuration: 500,\\n    /**\\n     * Animation style to use when scrolling between locations.\\n     * @option\\n     * @example 'ease-in-out'\\n     */\\n    animationEasing: 'linear',\\n    /**\\n     * Number of pixels to use as a marker for location changes.\\n     * @option\\n     * @example 50\\n     */\\n    threshold: 50,\\n    /**\\n     * Class applied to the active locations link on the magellan container.\\n     * @option\\n     * @example 'active'\\n     */\\n    activeClass: 'active',\\n    /**\\n     * Allows the script to manipulate the url of the current page, and if supported, alter the history.\\n     * @option\\n     * @example true\\n     */\\n    deepLinking: false,\\n    /**\\n     * Number of pixels to offset the scroll of the page on item click if using a sticky nav bar.\\n     * @option\\n     * @example 25\\n     */\\n    barOffset: 0\\n  };\\n\\n  // Window exports\\n  Foundation.plugin(Magellan, 'Magellan');\\n}(jQuery);\\n'use strict';\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n!function ($) {\\n\\n  /**\\n   * OffCanvas module.\\n   * @module foundation.offcanvas\\n   * @requires foundation.util.mediaQuery\\n   * @requires foundation.util.triggers\\n   * @requires foundation.util.motion\\n   */\\n\\n  var OffCanvas = function () {\\n    /**\\n     * Creates a new instance of an off-canvas wrapper.\\n     * @class\\n     * @fires OffCanvas#init\\n     * @param {Object} element - jQuery object to initialize.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n\\n    function OffCanvas(element, options) {\\n      _classCallCheck(this, OffCanvas);\\n\\n      this.$element = element;\\n      this.options = $.extend({}, OffCanvas.defaults, this.$element.data(), options);\\n      this.$lastTrigger = $();\\n      this.$triggers = $();\\n\\n      this._init();\\n      this._events();\\n\\n      Foundation.registerPlugin(this, 'OffCanvas');\\n    }\\n\\n    /**\\n     * Initializes the off-canvas wrapper by adding the exit overlay (if needed).\\n     * @function\\n     * @private\\n     */\\n\\n\\n    _createClass(OffCanvas, [{\\n      key: '_init',\\n      value: function _init() {\\n        var id = this.$element.attr('id');\\n\\n        this.$element.attr('aria-hidden', 'true');\\n\\n        // Find triggers that affect this element and add aria-expanded to them\\n        this.$triggers = $(document).find('[data-open=\\\"' + id + '\\\"], [data-close=\\\"' + id + '\\\"], [data-toggle=\\\"' + id + '\\\"]').attr('aria-expanded', 'false').attr('aria-controls', id);\\n\\n        // Add a close trigger over the body if necessary\\n        if (this.options.closeOnClick) {\\n          if ($('.js-off-canvas-exit').length) {\\n            this.$exiter = $('.js-off-canvas-exit');\\n          } else {\\n            var exiter = document.createElement('div');\\n            exiter.setAttribute('class', 'js-off-canvas-exit');\\n            $('[data-off-canvas-content]').append(exiter);\\n\\n            this.$exiter = $(exiter);\\n          }\\n        }\\n\\n        this.options.isRevealed = this.options.isRevealed || new RegExp(this.options.revealClass, 'g').test(this.$element[0].className);\\n\\n        if (this.options.isRevealed) {\\n          this.options.revealOn = this.options.revealOn || this.$element[0].className.match(/(reveal-for-medium|reveal-for-large)/g)[0].split('-')[2];\\n          this._setMQChecker();\\n        }\\n        if (!this.options.transitionTime) {\\n          this.options.transitionTime = parseFloat(window.getComputedStyle($('[data-off-canvas-wrapper]')[0]).transitionDuration) * 1000;\\n        }\\n      }\\n\\n      /**\\n       * Adds event handlers to the off-canvas wrapper and the exit overlay.\\n       * @function\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_events',\\n      value: function _events() {\\n        this.$element.off('.zf.trigger .zf.offcanvas').on({\\n          'open.zf.trigger': this.open.bind(this),\\n          'close.zf.trigger': this.close.bind(this),\\n          'toggle.zf.trigger': this.toggle.bind(this),\\n          'keydown.zf.offcanvas': this._handleKeyboard.bind(this)\\n        });\\n\\n        if (this.options.closeOnClick && this.$exiter.length) {\\n          this.$exiter.on({ 'click.zf.offcanvas': this.close.bind(this) });\\n        }\\n      }\\n\\n      /**\\n       * Applies event listener for elements that will reveal at certain breakpoints.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_setMQChecker',\\n      value: function _setMQChecker() {\\n        var _this = this;\\n\\n        $(window).on('changed.zf.mediaquery', function () {\\n          if (Foundation.MediaQuery.atLeast(_this.options.revealOn)) {\\n            _this.reveal(true);\\n          } else {\\n            _this.reveal(false);\\n          }\\n        }).one('load.zf.offcanvas', function () {\\n          if (Foundation.MediaQuery.atLeast(_this.options.revealOn)) {\\n            _this.reveal(true);\\n          }\\n        });\\n      }\\n\\n      /**\\n       * Handles the revealing/hiding the off-canvas at breakpoints, not the same as open.\\n       * @param {Boolean} isRevealed - true if element should be revealed.\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'reveal',\\n      value: function reveal(isRevealed) {\\n        var $closer = this.$element.find('[data-close]');\\n        if (isRevealed) {\\n          this.close();\\n          this.isRevealed = true;\\n          // if (!this.options.forceTop) {\\n          //   var scrollPos = parseInt(window.pageYOffset);\\n          //   this.$element[0].style.transform = 'translate(0,' + scrollPos + 'px)';\\n          // }\\n          // if (this.options.isSticky) { this._stick(); }\\n          this.$element.off('open.zf.trigger toggle.zf.trigger');\\n          if ($closer.length) {\\n            $closer.hide();\\n          }\\n        } else {\\n          this.isRevealed = false;\\n          // if (this.options.isSticky || !this.options.forceTop) {\\n          //   this.$element[0].style.transform = '';\\n          //   $(window).off('scroll.zf.offcanvas');\\n          // }\\n          this.$element.on({\\n            'open.zf.trigger': this.open.bind(this),\\n            'toggle.zf.trigger': this.toggle.bind(this)\\n          });\\n          if ($closer.length) {\\n            $closer.show();\\n          }\\n        }\\n      }\\n\\n      /**\\n       * Opens the off-canvas menu.\\n       * @function\\n       * @param {Object} event - Event object passed from listener.\\n       * @param {jQuery} trigger - element that triggered the off-canvas to open.\\n       * @fires OffCanvas#opened\\n       */\\n\\n    }, {\\n      key: 'open',\\n      value: function open(event, trigger) {\\n        if (this.$element.hasClass('is-open') || this.isRevealed) {\\n          return;\\n        }\\n        var _this = this,\\n            $body = $(document.body);\\n\\n        if (this.options.forceTop) {\\n          $('body').scrollTop(0);\\n        }\\n        // window.pageYOffset = 0;\\n\\n        // if (!this.options.forceTop) {\\n        //   var scrollPos = parseInt(window.pageYOffset);\\n        //   this.$element[0].style.transform = 'translate(0,' + scrollPos + 'px)';\\n        //   if (this.$exiter.length) {\\n        //     this.$exiter[0].style.transform = 'translate(0,' + scrollPos + 'px)';\\n        //   }\\n        // }\\n        /**\\n         * Fires when the off-canvas menu opens.\\n         * @event OffCanvas#opened\\n         */\\n        Foundation.Move(this.options.transitionTime, this.$element, function () {\\n          $('[data-off-canvas-wrapper]').addClass('is-off-canvas-open is-open-' + _this.options.position);\\n\\n          _this.$element.addClass('is-open');\\n\\n          // if (_this.options.isSticky) {\\n          //   _this._stick();\\n          // }\\n        });\\n\\n        this.$triggers.attr('aria-expanded', 'true');\\n        this.$element.attr('aria-hidden', 'false').trigger('opened.zf.offcanvas');\\n\\n        if (this.options.closeOnClick) {\\n          this.$exiter.addClass('is-visible');\\n        }\\n\\n        if (trigger) {\\n          this.$lastTrigger = trigger;\\n        }\\n\\n        if (this.options.autoFocus) {\\n          this.$element.one(Foundation.transitionend(this.$element), function () {\\n            _this.$element.find('a, button').eq(0).focus();\\n          });\\n        }\\n\\n        if (this.options.trapFocus) {\\n          $('[data-off-canvas-content]').attr('tabindex', '-1');\\n          this._trapFocus();\\n        }\\n      }\\n\\n      /**\\n       * Traps focus within the offcanvas on open.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_trapFocus',\\n      value: function _trapFocus() {\\n        var focusable = Foundation.Keyboard.findFocusable(this.$element),\\n            first = focusable.eq(0),\\n            last = focusable.eq(-1);\\n\\n        focusable.off('.zf.offcanvas').on('keydown.zf.offcanvas', function (e) {\\n          if (e.which === 9 || e.keycode === 9) {\\n            if (e.target === last[0] && !e.shiftKey) {\\n              e.preventDefault();\\n              first.focus();\\n            }\\n            if (e.target === first[0] && e.shiftKey) {\\n              e.preventDefault();\\n              last.focus();\\n            }\\n          }\\n        });\\n      }\\n\\n      /**\\n       * Allows the offcanvas to appear sticky utilizing translate properties.\\n       * @private\\n       */\\n      // OffCanvas.prototype._stick = function() {\\n      //   var elStyle = this.$element[0].style;\\n      //\\n      //   if (this.options.closeOnClick) {\\n      //     var exitStyle = this.$exiter[0].style;\\n      //   }\\n      //\\n      //   $(window).on('scroll.zf.offcanvas', function(e) {\\n      //     console.log(e);\\n      //     var pageY = window.pageYOffset;\\n      //     elStyle.transform = 'translate(0,' + pageY + 'px)';\\n      //     if (exitStyle !== undefined) { exitStyle.transform = 'translate(0,' + pageY + 'px)'; }\\n      //   });\\n      //   // this.$element.trigger('stuck.zf.offcanvas');\\n      // };\\n      /**\\n       * Closes the off-canvas menu.\\n       * @function\\n       * @param {Function} cb - optional cb to fire after closure.\\n       * @fires OffCanvas#closed\\n       */\\n\\n    }, {\\n      key: 'close',\\n      value: function close(cb) {\\n        if (!this.$element.hasClass('is-open') || this.isRevealed) {\\n          return;\\n        }\\n\\n        var _this = this;\\n\\n        //  Foundation.Move(this.options.transitionTime, this.$element, function() {\\n        $('[data-off-canvas-wrapper]').removeClass('is-off-canvas-open is-open-' + _this.options.position);\\n        _this.$element.removeClass('is-open');\\n        // Foundation._reflow();\\n        // });\\n        this.$element.attr('aria-hidden', 'true')\\n        /**\\n         * Fires when the off-canvas menu opens.\\n         * @event OffCanvas#closed\\n         */\\n        .trigger('closed.zf.offcanvas');\\n        // if (_this.options.isSticky || !_this.options.forceTop) {\\n        //   setTimeout(function() {\\n        //     _this.$element[0].style.transform = '';\\n        //     $(window).off('scroll.zf.offcanvas');\\n        //   }, this.options.transitionTime);\\n        // }\\n        if (this.options.closeOnClick) {\\n          this.$exiter.removeClass('is-visible');\\n        }\\n\\n        this.$triggers.attr('aria-expanded', 'false');\\n        if (this.options.trapFocus) {\\n          $('[data-off-canvas-content]').removeAttr('tabindex');\\n        }\\n      }\\n\\n      /**\\n       * Toggles the off-canvas menu open or closed.\\n       * @function\\n       * @param {Object} event - Event object passed from listener.\\n       * @param {jQuery} trigger - element that triggered the off-canvas to open.\\n       */\\n\\n    }, {\\n      key: 'toggle',\\n      value: function toggle(event, trigger) {\\n        if (this.$element.hasClass('is-open')) {\\n          this.close(event, trigger);\\n        } else {\\n          this.open(event, trigger);\\n        }\\n      }\\n\\n      /**\\n       * Handles keyboard input when detected. When the escape key is pressed, the off-canvas menu closes, and focus is restored to the element that opened the menu.\\n       * @function\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_handleKeyboard',\\n      value: function _handleKeyboard(event) {\\n        if (event.which !== 27) return;\\n\\n        event.stopPropagation();\\n        event.preventDefault();\\n        this.close();\\n        this.$lastTrigger.focus();\\n      }\\n\\n      /**\\n       * Destroys the offcanvas plugin.\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'destroy',\\n      value: function destroy() {\\n        this.close();\\n        this.$element.off('.zf.trigger .zf.offcanvas');\\n        this.$exiter.off('.zf.offcanvas');\\n\\n        Foundation.unregisterPlugin(this);\\n      }\\n    }]);\\n\\n    return OffCanvas;\\n  }();\\n\\n  OffCanvas.defaults = {\\n    /**\\n     * Allow the user to click outside of the menu to close it.\\n     * @option\\n     * @example true\\n     */\\n    closeOnClick: true,\\n\\n    /**\\n     * Amount of time in ms the open and close transition requires. If none selected, pulls from body style.\\n     * @option\\n     * @example 500\\n     */\\n    transitionTime: 0,\\n\\n    /**\\n     * Direction the offcanvas opens from. Determines class applied to body.\\n     * @option\\n     * @example left\\n     */\\n    position: 'left',\\n\\n    /**\\n     * Force the page to scroll to top on open.\\n     * @option\\n     * @example true\\n     */\\n    forceTop: true,\\n\\n    /**\\n     * Allow the offcanvas to remain open for certain breakpoints.\\n     * @option\\n     * @example false\\n     */\\n    isRevealed: false,\\n\\n    /**\\n     * Breakpoint at which to reveal. JS will use a RegExp to target standard classes, if changing classnames, pass your class with the `revealClass` option.\\n     * @option\\n     * @example reveal-for-large\\n     */\\n    revealOn: null,\\n\\n    /**\\n     * Force focus to the offcanvas on open. If true, will focus the opening trigger on close.\\n     * @option\\n     * @example true\\n     */\\n    autoFocus: true,\\n\\n    /**\\n     * Class used to force an offcanvas to remain open. Foundation defaults for this are `reveal-for-large` & `reveal-for-medium`.\\n     * @option\\n     * TODO improve the regex testing for this.\\n     * @example reveal-for-large\\n     */\\n    revealClass: 'reveal-for-',\\n\\n    /**\\n     * Triggers optional focus trapping when opening an offcanvas. Sets tabindex of [data-off-canvas-content] to -1 for accessibility purposes.\\n     * @option\\n     * @example true\\n     */\\n    trapFocus: false\\n  };\\n\\n  // Window exports\\n  Foundation.plugin(OffCanvas, 'OffCanvas');\\n}(jQuery);\\n'use strict';\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n!function ($) {\\n\\n  /**\\n   * Orbit module.\\n   * @module foundation.orbit\\n   * @requires foundation.util.keyboard\\n   * @requires foundation.util.motion\\n   * @requires foundation.util.timerAndImageLoader\\n   * @requires foundation.util.touch\\n   */\\n\\n  var Orbit = function () {\\n    /**\\n    * Creates a new instance of an orbit carousel.\\n    * @class\\n    * @param {jQuery} element - jQuery object to make into an Orbit Carousel.\\n    * @param {Object} options - Overrides to the default plugin settings.\\n    */\\n\\n    function Orbit(element, options) {\\n      _classCallCheck(this, Orbit);\\n\\n      this.$element = element;\\n      this.options = $.extend({}, Orbit.defaults, this.$element.data(), options);\\n\\n      this._init();\\n\\n      Foundation.registerPlugin(this, 'Orbit');\\n      Foundation.Keyboard.register('Orbit', {\\n        'ltr': {\\n          'ARROW_RIGHT': 'next',\\n          'ARROW_LEFT': 'previous'\\n        },\\n        'rtl': {\\n          'ARROW_LEFT': 'next',\\n          'ARROW_RIGHT': 'previous'\\n        }\\n      });\\n    }\\n\\n    /**\\n    * Initializes the plugin by creating jQuery collections, setting attributes, and starting the animation.\\n    * @function\\n    * @private\\n    */\\n\\n\\n    _createClass(Orbit, [{\\n      key: '_init',\\n      value: function _init() {\\n        this.$wrapper = this.$element.find('.' + this.options.containerClass);\\n        this.$slides = this.$element.find('.' + this.options.slideClass);\\n        var $images = this.$element.find('img'),\\n            initActive = this.$slides.filter('.is-active');\\n\\n        if (!initActive.length) {\\n          this.$slides.eq(0).addClass('is-active');\\n        }\\n\\n        if (!this.options.useMUI) {\\n          this.$slides.addClass('no-motionui');\\n        }\\n\\n        if ($images.length) {\\n          Foundation.onImagesLoaded($images, this._prepareForOrbit.bind(this));\\n        } else {\\n          this._prepareForOrbit(); //hehe\\n        }\\n\\n        if (this.options.bullets) {\\n          this._loadBullets();\\n        }\\n\\n        this._events();\\n\\n        if (this.options.autoPlay && this.$slides.length > 1) {\\n          this.geoSync();\\n        }\\n\\n        if (this.options.accessible) {\\n          // allow wrapper to be focusable to enable arrow navigation\\n          this.$wrapper.attr('tabindex', 0);\\n        }\\n      }\\n\\n      /**\\n      * Creates a jQuery collection of bullets, if they are being used.\\n      * @function\\n      * @private\\n      */\\n\\n    }, {\\n      key: '_loadBullets',\\n      value: function _loadBullets() {\\n        this.$bullets = this.$element.find('.' + this.options.boxOfBullets).find('button');\\n      }\\n\\n      /**\\n      * Sets a `timer` object on the orbit, and starts the counter for the next slide.\\n      * @function\\n      */\\n\\n    }, {\\n      key: 'geoSync',\\n      value: function geoSync() {\\n        var _this = this;\\n        this.timer = new Foundation.Timer(this.$element, {\\n          duration: this.options.timerDelay,\\n          infinite: false\\n        }, function () {\\n          _this.changeSlide(true);\\n        });\\n        this.timer.start();\\n      }\\n\\n      /**\\n      * Sets wrapper and slide heights for the orbit.\\n      * @function\\n      * @private\\n      */\\n\\n    }, {\\n      key: '_prepareForOrbit',\\n      value: function _prepareForOrbit() {\\n        var _this = this;\\n        this._setWrapperHeight(function (max) {\\n          _this._setSlideHeight(max);\\n        });\\n      }\\n\\n      /**\\n      * Calulates the height of each slide in the collection, and uses the tallest one for the wrapper height.\\n      * @function\\n      * @private\\n      * @param {Function} cb - a callback function to fire when complete.\\n      */\\n\\n    }, {\\n      key: '_setWrapperHeight',\\n      value: function _setWrapperHeight(cb) {\\n        //rewrite this to `for` loop\\n        var max = 0,\\n            temp,\\n            counter = 0;\\n\\n        this.$slides.each(function () {\\n          temp = this.getBoundingClientRect().height;\\n          $(this).attr('data-slide', counter);\\n\\n          if (counter) {\\n            //if not the first slide, set css position and display property\\n            $(this).css({ 'position': 'relative', 'display': 'none' });\\n          }\\n          max = temp > max ? temp : max;\\n          counter++;\\n        });\\n\\n        if (counter === this.$slides.length) {\\n          this.$wrapper.css({ 'height': max }); //only change the wrapper height property once.\\n          cb(max); //fire callback with max height dimension.\\n        }\\n      }\\n\\n      /**\\n      * Sets the max-height of each slide.\\n      * @function\\n      * @private\\n      */\\n\\n    }, {\\n      key: '_setSlideHeight',\\n      value: function _setSlideHeight(height) {\\n        this.$slides.each(function () {\\n          $(this).css('max-height', height);\\n        });\\n      }\\n\\n      /**\\n      * Adds event listeners to basically everything within the element.\\n      * @function\\n      * @private\\n      */\\n\\n    }, {\\n      key: '_events',\\n      value: function _events() {\\n        var _this = this;\\n\\n        //***************************************\\n        //**Now using custom event - thanks to:**\\n        //**      Yohai Ararat of Toronto      **\\n        //***************************************\\n        if (this.$slides.length > 1) {\\n\\n          if (this.options.swipe) {\\n            this.$slides.off('swipeleft.zf.orbit swiperight.zf.orbit').on('swipeleft.zf.orbit', function (e) {\\n              e.preventDefault();\\n              _this.changeSlide(true);\\n            }).on('swiperight.zf.orbit', function (e) {\\n              e.preventDefault();\\n              _this.changeSlide(false);\\n            });\\n          }\\n          //***************************************\\n\\n          if (this.options.autoPlay) {\\n            this.$slides.on('click.zf.orbit', function () {\\n              _this.$element.data('clickedOn', _this.$element.data('clickedOn') ? false : true);\\n              _this.timer[_this.$element.data('clickedOn') ? 'pause' : 'start']();\\n            });\\n\\n            if (this.options.pauseOnHover) {\\n              this.$element.on('mouseenter.zf.orbit', function () {\\n                _this.timer.pause();\\n              }).on('mouseleave.zf.orbit', function () {\\n                if (!_this.$element.data('clickedOn')) {\\n                  _this.timer.start();\\n                }\\n              });\\n            }\\n          }\\n\\n          if (this.options.navButtons) {\\n            var $controls = this.$element.find('.' + this.options.nextClass + ', .' + this.options.prevClass);\\n            $controls.attr('tabindex', 0)\\n            //also need to handle enter/return and spacebar key presses\\n            .on('click.zf.orbit touchend.zf.orbit', function (e) {\\n              e.preventDefault();\\n              _this.changeSlide($(this).hasClass(_this.options.nextClass));\\n            });\\n          }\\n\\n          if (this.options.bullets) {\\n            this.$bullets.on('click.zf.orbit touchend.zf.orbit', function () {\\n              if (/is-active/g.test(this.className)) {\\n                return false;\\n              } //if this is active, kick out of function.\\n              var idx = $(this).data('slide'),\\n                  ltr = idx > _this.$slides.filter('.is-active').data('slide'),\\n                  $slide = _this.$slides.eq(idx);\\n\\n              _this.changeSlide(ltr, $slide, idx);\\n            });\\n          }\\n\\n          this.$wrapper.add(this.$bullets).on('keydown.zf.orbit', function (e) {\\n            // handle keyboard event with keyboard util\\n            Foundation.Keyboard.handleKey(e, 'Orbit', {\\n              next: function () {\\n                _this.changeSlide(true);\\n              },\\n              previous: function () {\\n                _this.changeSlide(false);\\n              },\\n              handled: function () {\\n                // if bullet is focused, make sure focus moves\\n                if ($(e.target).is(_this.$bullets)) {\\n                  _this.$bullets.filter('.is-active').focus();\\n                }\\n              }\\n            });\\n          });\\n        }\\n      }\\n\\n      /**\\n      * Changes the current slide to a new one.\\n      * @function\\n      * @param {Boolean} isLTR - flag if the slide should move left to right.\\n      * @param {jQuery} chosenSlide - the jQuery element of the slide to show next, if one is selected.\\n      * @param {Number} idx - the index of the new slide in its collection, if one chosen.\\n      * @fires Orbit#slidechange\\n      */\\n\\n    }, {\\n      key: 'changeSlide',\\n      value: function changeSlide(isLTR, chosenSlide, idx) {\\n        var $curSlide = this.$slides.filter('.is-active').eq(0);\\n\\n        if (/mui/g.test($curSlide[0].className)) {\\n          return false;\\n        } //if the slide is currently animating, kick out of the function\\n\\n        var $firstSlide = this.$slides.first(),\\n            $lastSlide = this.$slides.last(),\\n            dirIn = isLTR ? 'Right' : 'Left',\\n            dirOut = isLTR ? 'Left' : 'Right',\\n            _this = this,\\n            $newSlide;\\n\\n        if (!chosenSlide) {\\n          //most of the time, this will be auto played or clicked from the navButtons.\\n          $newSlide = isLTR ? //if wrapping enabled, check to see if there is a `next` or `prev` sibling, if not, select the first or last slide to fill in. if wrapping not enabled, attempt to select `next` or `prev`, if there's nothing there, the function will kick out on next step. CRAZY NESTED TERNARIES!!!!!\\n          this.options.infiniteWrap ? $curSlide.next('.' + this.options.slideClass).length ? $curSlide.next('.' + this.options.slideClass) : $firstSlide : $curSlide.next('.' + this.options.slideClass) : //pick next slide if moving left to right\\n          this.options.infiniteWrap ? $curSlide.prev('.' + this.options.slideClass).length ? $curSlide.prev('.' + this.options.slideClass) : $lastSlide : $curSlide.prev('.' + this.options.slideClass); //pick prev slide if moving right to left\\n        } else {\\n            $newSlide = chosenSlide;\\n          }\\n\\n        if ($newSlide.length) {\\n          if (this.options.bullets) {\\n            idx = idx || this.$slides.index($newSlide); //grab index to update bullets\\n            this._updateBullets(idx);\\n          }\\n\\n          if (this.options.useMUI) {\\n            Foundation.Motion.animateIn($newSlide.addClass('is-active').css({ 'position': 'absolute', 'top': 0 }), this.options['animInFrom' + dirIn], function () {\\n              $newSlide.css({ 'position': 'relative', 'display': 'block' }).attr('aria-live', 'polite');\\n            });\\n\\n            Foundation.Motion.animateOut($curSlide.removeClass('is-active'), this.options['animOutTo' + dirOut], function () {\\n              $curSlide.removeAttr('aria-live');\\n              if (_this.options.autoPlay && !_this.timer.isPaused) {\\n                _this.timer.restart();\\n              }\\n              //do stuff?\\n            });\\n          } else {\\n              $curSlide.removeClass('is-active is-in').removeAttr('aria-live').hide();\\n              $newSlide.addClass('is-active is-in').attr('aria-live', 'polite').show();\\n              if (this.options.autoPlay && !this.timer.isPaused) {\\n                this.timer.restart();\\n              }\\n            }\\n          /**\\n          * Triggers when the slide has finished animating in.\\n          * @event Orbit#slidechange\\n          */\\n          this.$element.trigger('slidechange.zf.orbit', [$newSlide]);\\n        }\\n      }\\n\\n      /**\\n      * Updates the active state of the bullets, if displayed.\\n      * @function\\n      * @private\\n      * @param {Number} idx - the index of the current slide.\\n      */\\n\\n    }, {\\n      key: '_updateBullets',\\n      value: function _updateBullets(idx) {\\n        var $oldBullet = this.$element.find('.' + this.options.boxOfBullets).find('.is-active').removeClass('is-active').blur(),\\n            span = $oldBullet.find('span:last').detach(),\\n            $newBullet = this.$bullets.eq(idx).addClass('is-active').append(span);\\n      }\\n\\n      /**\\n      * Destroys the carousel and hides the element.\\n      * @function\\n      */\\n\\n    }, {\\n      key: 'destroy',\\n      value: function destroy() {\\n        this.$element.off('.zf.orbit').find('*').off('.zf.orbit').end().hide();\\n        Foundation.unregisterPlugin(this);\\n      }\\n    }]);\\n\\n    return Orbit;\\n  }();\\n\\n  Orbit.defaults = {\\n    /**\\n    * Tells the JS to look for and loadBullets.\\n    * @option\\n    * @example true\\n    */\\n    bullets: true,\\n    /**\\n    * Tells the JS to apply event listeners to nav buttons\\n    * @option\\n    * @example true\\n    */\\n    navButtons: true,\\n    /**\\n    * motion-ui animation class to apply\\n    * @option\\n    * @example 'slide-in-right'\\n    */\\n    animInFromRight: 'slide-in-right',\\n    /**\\n    * motion-ui animation class to apply\\n    * @option\\n    * @example 'slide-out-right'\\n    */\\n    animOutToRight: 'slide-out-right',\\n    /**\\n    * motion-ui animation class to apply\\n    * @option\\n    * @example 'slide-in-left'\\n    *\\n    */\\n    animInFromLeft: 'slide-in-left',\\n    /**\\n    * motion-ui animation class to apply\\n    * @option\\n    * @example 'slide-out-left'\\n    */\\n    animOutToLeft: 'slide-out-left',\\n    /**\\n    * Allows Orbit to automatically animate on page load.\\n    * @option\\n    * @example true\\n    */\\n    autoPlay: true,\\n    /**\\n    * Amount of time, in ms, between slide transitions\\n    * @option\\n    * @example 5000\\n    */\\n    timerDelay: 5000,\\n    /**\\n    * Allows Orbit to infinitely loop through the slides\\n    * @option\\n    * @example true\\n    */\\n    infiniteWrap: true,\\n    /**\\n    * Allows the Orbit slides to bind to swipe events for mobile, requires an additional util library\\n    * @option\\n    * @example true\\n    */\\n    swipe: true,\\n    /**\\n    * Allows the timing function to pause animation on hover.\\n    * @option\\n    * @example true\\n    */\\n    pauseOnHover: true,\\n    /**\\n    * Allows Orbit to bind keyboard events to the slider, to animate frames with arrow keys\\n    * @option\\n    * @example true\\n    */\\n    accessible: true,\\n    /**\\n    * Class applied to the container of Orbit\\n    * @option\\n    * @example 'orbit-container'\\n    */\\n    containerClass: 'orbit-container',\\n    /**\\n    * Class applied to individual slides.\\n    * @option\\n    * @example 'orbit-slide'\\n    */\\n    slideClass: 'orbit-slide',\\n    /**\\n    * Class applied to the bullet container. You're welcome.\\n    * @option\\n    * @example 'orbit-bullets'\\n    */\\n    boxOfBullets: 'orbit-bullets',\\n    /**\\n    * Class applied to the `next` navigation button.\\n    * @option\\n    * @example 'orbit-next'\\n    */\\n    nextClass: 'orbit-next',\\n    /**\\n    * Class applied to the `previous` navigation button.\\n    * @option\\n    * @example 'orbit-previous'\\n    */\\n    prevClass: 'orbit-previous',\\n    /**\\n    * Boolean to flag the js to use motion ui classes or not. Default to true for backwards compatability.\\n    * @option\\n    * @example true\\n    */\\n    useMUI: true\\n  };\\n\\n  // Window exports\\n  Foundation.plugin(Orbit, 'Orbit');\\n}(jQuery);\\n'use strict';\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n!function ($) {\\n\\n  /**\\n   * ResponsiveMenu module.\\n   * @module foundation.responsiveMenu\\n   * @requires foundation.util.triggers\\n   * @requires foundation.util.mediaQuery\\n   * @requires foundation.util.accordionMenu\\n   * @requires foundation.util.drilldown\\n   * @requires foundation.util.dropdown-menu\\n   */\\n\\n  var ResponsiveMenu = function () {\\n    /**\\n     * Creates a new instance of a responsive menu.\\n     * @class\\n     * @fires ResponsiveMenu#init\\n     * @param {jQuery} element - jQuery object to make into a dropdown menu.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n\\n    function ResponsiveMenu(element, options) {\\n      _classCallCheck(this, ResponsiveMenu);\\n\\n      this.$element = $(element);\\n      this.rules = this.$element.data('responsive-menu');\\n      this.currentMq = null;\\n      this.currentPlugin = null;\\n\\n      this._init();\\n      this._events();\\n\\n      Foundation.registerPlugin(this, 'ResponsiveMenu');\\n    }\\n\\n    /**\\n     * Initializes the Menu by parsing the classes from the 'data-ResponsiveMenu' attribute on the element.\\n     * @function\\n     * @private\\n     */\\n\\n\\n    _createClass(ResponsiveMenu, [{\\n      key: '_init',\\n      value: function _init() {\\n        // The first time an Interchange plugin is initialized, this.rules is converted from a string of \\\"classes\\\" to an object of rules\\n        if (typeof this.rules === 'string') {\\n          var rulesTree = {};\\n\\n          // Parse rules from \\\"classes\\\" pulled from data attribute\\n          var rules = this.rules.split(' ');\\n\\n          // Iterate through every rule found\\n          for (var i = 0; i < rules.length; i++) {\\n            var rule = rules[i].split('-');\\n            var ruleSize = rule.length > 1 ? rule[0] : 'small';\\n            var rulePlugin = rule.length > 1 ? rule[1] : rule[0];\\n\\n            if (MenuPlugins[rulePlugin] !== null) {\\n              rulesTree[ruleSize] = MenuPlugins[rulePlugin];\\n            }\\n          }\\n\\n          this.rules = rulesTree;\\n        }\\n\\n        if (!$.isEmptyObject(this.rules)) {\\n          this._checkMediaQueries();\\n        }\\n      }\\n\\n      /**\\n       * Initializes events for the Menu.\\n       * @function\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_events',\\n      value: function _events() {\\n        var _this = this;\\n\\n        $(window).on('changed.zf.mediaquery', function () {\\n          _this._checkMediaQueries();\\n        });\\n        // $(window).on('resize.zf.ResponsiveMenu', function() {\\n        //   _this._checkMediaQueries();\\n        // });\\n      }\\n\\n      /**\\n       * Checks the current screen width against available media queries. If the media query has changed, and the plugin needed has changed, the plugins will swap out.\\n       * @function\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_checkMediaQueries',\\n      value: function _checkMediaQueries() {\\n        var matchedMq,\\n            _this = this;\\n        // Iterate through each rule and find the last matching rule\\n        $.each(this.rules, function (key) {\\n          if (Foundation.MediaQuery.atLeast(key)) {\\n            matchedMq = key;\\n          }\\n        });\\n\\n        // No match? No dice\\n        if (!matchedMq) return;\\n\\n        // Plugin already initialized? We good\\n        if (this.currentPlugin instanceof this.rules[matchedMq].plugin) return;\\n\\n        // Remove existing plugin-specific CSS classes\\n        $.each(MenuPlugins, function (key, value) {\\n          _this.$element.removeClass(value.cssClass);\\n        });\\n\\n        // Add the CSS class for the new plugin\\n        this.$element.addClass(this.rules[matchedMq].cssClass);\\n\\n        // Create an instance of the new plugin\\n        if (this.currentPlugin) this.currentPlugin.destroy();\\n        this.currentPlugin = new this.rules[matchedMq].plugin(this.$element, {});\\n      }\\n\\n      /**\\n       * Destroys the instance of the current plugin on this element, as well as the window resize handler that switches the plugins out.\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'destroy',\\n      value: function destroy() {\\n        this.currentPlugin.destroy();\\n        $(window).off('.zf.ResponsiveMenu');\\n        Foundation.unregisterPlugin(this);\\n      }\\n    }]);\\n\\n    return ResponsiveMenu;\\n  }();\\n\\n  ResponsiveMenu.defaults = {};\\n\\n  // The plugin matches the plugin classes with these plugin instances.\\n  var MenuPlugins = {\\n    dropdown: {\\n      cssClass: 'dropdown',\\n      plugin: Foundation._plugins['dropdown-menu'] || null\\n    },\\n    drilldown: {\\n      cssClass: 'drilldown',\\n      plugin: Foundation._plugins['drilldown'] || null\\n    },\\n    accordion: {\\n      cssClass: 'accordion-menu',\\n      plugin: Foundation._plugins['accordion-menu'] || null\\n    }\\n  };\\n\\n  // Window exports\\n  Foundation.plugin(ResponsiveMenu, 'ResponsiveMenu');\\n}(jQuery);\\n'use strict';\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n!function ($) {\\n\\n  /**\\n   * ResponsiveToggle module.\\n   * @module foundation.responsiveToggle\\n   * @requires foundation.util.mediaQuery\\n   */\\n\\n  var ResponsiveToggle = function () {\\n    /**\\n     * Creates a new instance of Tab Bar.\\n     * @class\\n     * @fires ResponsiveToggle#init\\n     * @param {jQuery} element - jQuery object to attach tab bar functionality to.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n\\n    function ResponsiveToggle(element, options) {\\n      _classCallCheck(this, ResponsiveToggle);\\n\\n      this.$element = $(element);\\n      this.options = $.extend({}, ResponsiveToggle.defaults, this.$element.data(), options);\\n\\n      this._init();\\n      this._events();\\n\\n      Foundation.registerPlugin(this, 'ResponsiveToggle');\\n    }\\n\\n    /**\\n     * Initializes the tab bar by finding the target element, toggling element, and running update().\\n     * @function\\n     * @private\\n     */\\n\\n\\n    _createClass(ResponsiveToggle, [{\\n      key: '_init',\\n      value: function _init() {\\n        var targetID = this.$element.data('responsive-toggle');\\n        if (!targetID) {\\n          console.error('Your tab bar needs an ID of a Menu as the value of data-tab-bar.');\\n        }\\n\\n        this.$targetMenu = $('#' + targetID);\\n        this.$toggler = this.$element.find('[data-toggle]');\\n\\n        this._update();\\n      }\\n\\n      /**\\n       * Adds necessary event handlers for the tab bar to work.\\n       * @function\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_events',\\n      value: function _events() {\\n        var _this = this;\\n\\n        this._updateMqHandler = this._update.bind(this);\\n\\n        $(window).on('changed.zf.mediaquery', this._updateMqHandler);\\n\\n        this.$toggler.on('click.zf.responsiveToggle', this.toggleMenu.bind(this));\\n      }\\n\\n      /**\\n       * Checks the current media query to determine if the tab bar should be visible or hidden.\\n       * @function\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_update',\\n      value: function _update() {\\n        // Mobile\\n        if (!Foundation.MediaQuery.atLeast(this.options.hideFor)) {\\n          this.$element.show();\\n          this.$targetMenu.hide();\\n        }\\n\\n        // Desktop\\n        else {\\n            this.$element.hide();\\n            this.$targetMenu.show();\\n          }\\n      }\\n\\n      /**\\n       * Toggles the element attached to the tab bar. The toggle only happens if the screen is small enough to allow it.\\n       * @function\\n       * @fires ResponsiveToggle#toggled\\n       */\\n\\n    }, {\\n      key: 'toggleMenu',\\n      value: function toggleMenu() {\\n        if (!Foundation.MediaQuery.atLeast(this.options.hideFor)) {\\n          this.$targetMenu.toggle(0);\\n\\n          /**\\n           * Fires when the element attached to the tab bar toggles.\\n           * @event ResponsiveToggle#toggled\\n           */\\n          this.$element.trigger('toggled.zf.responsiveToggle');\\n        }\\n      }\\n    }, {\\n      key: 'destroy',\\n      value: function destroy() {\\n        this.$element.off('.zf.responsiveToggle');\\n        this.$toggler.off('.zf.responsiveToggle');\\n\\n        $(window).off('changed.zf.mediaquery', this._updateMqHandler);\\n\\n        Foundation.unregisterPlugin(this);\\n      }\\n    }]);\\n\\n    return ResponsiveToggle;\\n  }();\\n\\n  ResponsiveToggle.defaults = {\\n    /**\\n     * The breakpoint after which the menu is always shown, and the tab bar is hidden.\\n     * @option\\n     * @example 'medium'\\n     */\\n    hideFor: 'medium'\\n  };\\n\\n  // Window exports\\n  Foundation.plugin(ResponsiveToggle, 'ResponsiveToggle');\\n}(jQuery);\\n'use strict';\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n!function ($) {\\n\\n  /**\\n   * Reveal module.\\n   * @module foundation.reveal\\n   * @requires foundation.util.keyboard\\n   * @requires foundation.util.box\\n   * @requires foundation.util.triggers\\n   * @requires foundation.util.mediaQuery\\n   * @requires foundation.util.motion if using animations\\n   */\\n\\n  var Reveal = function () {\\n    /**\\n     * Creates a new instance of Reveal.\\n     * @class\\n     * @param {jQuery} element - jQuery object to use for the modal.\\n     * @param {Object} options - optional parameters.\\n     */\\n\\n    function Reveal(element, options) {\\n      _classCallCheck(this, Reveal);\\n\\n      this.$element = element;\\n      this.options = $.extend({}, Reveal.defaults, this.$element.data(), options);\\n      this._init();\\n\\n      Foundation.registerPlugin(this, 'Reveal');\\n      Foundation.Keyboard.register('Reveal', {\\n        'ENTER': 'open',\\n        'SPACE': 'open',\\n        'ESCAPE': 'close',\\n        'TAB': 'tab_forward',\\n        'SHIFT_TAB': 'tab_backward'\\n      });\\n    }\\n\\n    /**\\n     * Initializes the modal by adding the overlay and close buttons, (if selected).\\n     * @private\\n     */\\n\\n\\n    _createClass(Reveal, [{\\n      key: '_init',\\n      value: function _init() {\\n        this.id = this.$element.attr('id');\\n        this.isActive = false;\\n        this.cached = { mq: Foundation.MediaQuery.current };\\n        this.isMobile = mobileSniff();\\n\\n        this.$anchor = $('[data-open=\\\"' + this.id + '\\\"]').length ? $('[data-open=\\\"' + this.id + '\\\"]') : $('[data-toggle=\\\"' + this.id + '\\\"]');\\n        this.$anchor.attr({\\n          'aria-controls': this.id,\\n          'aria-haspopup': true,\\n          'tabindex': 0\\n        });\\n\\n        if (this.options.fullScreen || this.$element.hasClass('full')) {\\n          this.options.fullScreen = true;\\n          this.options.overlay = false;\\n        }\\n        if (this.options.overlay && !this.$overlay) {\\n          this.$overlay = this._makeOverlay(this.id);\\n        }\\n\\n        this.$element.attr({\\n          'role': 'dialog',\\n          'aria-hidden': true,\\n          'data-yeti-box': this.id,\\n          'data-resize': this.id\\n        });\\n\\n        if (this.$overlay) {\\n          this.$element.detach().appendTo(this.$overlay);\\n        } else {\\n          this.$element.detach().appendTo($('body'));\\n          this.$element.addClass('without-overlay');\\n        }\\n        this._events();\\n        if (this.options.deepLink && window.location.hash === '#' + this.id) {\\n          $(window).one('load.zf.reveal', this.open.bind(this));\\n        }\\n      }\\n\\n      /**\\n       * Creates an overlay div to display behind the modal.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_makeOverlay',\\n      value: function _makeOverlay(id) {\\n        var $overlay = $('<div></div>').addClass('reveal-overlay').appendTo('body');\\n        return $overlay;\\n      }\\n\\n      /**\\n       * Updates position of modal\\n       * TODO:  Figure out if we actually need to cache these values or if it doesn't matter\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_updatePosition',\\n      value: function _updatePosition() {\\n        var width = this.$element.outerWidth();\\n        var outerWidth = $(window).width();\\n        var height = this.$element.outerHeight();\\n        var outerHeight = $(window).height();\\n        var left, top;\\n        if (this.options.hOffset === 'auto') {\\n          left = parseInt((outerWidth - width) / 2, 10);\\n        } else {\\n          left = parseInt(this.options.hOffset, 10);\\n        }\\n        if (this.options.vOffset === 'auto') {\\n          if (height > outerHeight) {\\n            top = parseInt(Math.min(100, outerHeight / 10), 10);\\n          } else {\\n            top = parseInt((outerHeight - height) / 4, 10);\\n          }\\n        } else {\\n          top = parseInt(this.options.vOffset, 10);\\n        }\\n        this.$element.css({ top: top + 'px' });\\n        // only worry about left if we don't have an overlay or we havea  horizontal offset,\\n        // otherwise we're perfectly in the middle\\n        if (!this.$overlay || this.options.hOffset !== 'auto') {\\n          this.$element.css({ left: left + 'px' });\\n          this.$element.css({ margin: '0px' });\\n        }\\n      }\\n\\n      /**\\n       * Adds event handlers for the modal.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_events',\\n      value: function _events() {\\n        var _this2 = this;\\n\\n        var _this = this;\\n\\n        this.$element.on({\\n          'open.zf.trigger': this.open.bind(this),\\n          'close.zf.trigger': function (event, $element) {\\n            if (event.target === _this.$element[0] || $(event.target).parents('[data-closable]')[0] === $element) {\\n              // only close reveal when it's explicitly called\\n              return _this2.close.apply(_this2);\\n            }\\n          },\\n          'toggle.zf.trigger': this.toggle.bind(this),\\n          'resizeme.zf.trigger': function () {\\n            _this._updatePosition();\\n          }\\n        });\\n\\n        if (this.$anchor.length) {\\n          this.$anchor.on('keydown.zf.reveal', function (e) {\\n            if (e.which === 13 || e.which === 32) {\\n              e.stopPropagation();\\n              e.preventDefault();\\n              _this.open();\\n            }\\n          });\\n        }\\n\\n        if (this.options.closeOnClick && this.options.overlay) {\\n          this.$overlay.off('.zf.reveal').on('click.zf.reveal', function (e) {\\n            if (e.target === _this.$element[0] || $.contains(_this.$element[0], e.target)) {\\n              return;\\n            }\\n            _this.close();\\n          });\\n        }\\n        if (this.options.deepLink) {\\n          $(window).on('popstate.zf.reveal:' + this.id, this._handleState.bind(this));\\n        }\\n      }\\n\\n      /**\\n       * Handles modal methods on back/forward button clicks or any other event that triggers popstate.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_handleState',\\n      value: function _handleState(e) {\\n        if (window.location.hash === '#' + this.id && !this.isActive) {\\n          this.open();\\n        } else {\\n          this.close();\\n        }\\n      }\\n\\n      /**\\n       * Opens the modal controlled by `this.$anchor`, and closes all others by default.\\n       * @function\\n       * @fires Reveal#closeme\\n       * @fires Reveal#open\\n       */\\n\\n    }, {\\n      key: 'open',\\n      value: function open() {\\n        var _this3 = this;\\n\\n        if (this.options.deepLink) {\\n          var hash = '#' + this.id;\\n\\n          if (window.history.pushState) {\\n            window.history.pushState(null, null, hash);\\n          } else {\\n            window.location.hash = hash;\\n          }\\n        }\\n\\n        this.isActive = true;\\n\\n        // Make elements invisible, but remove display: none so we can get size and positioning\\n        this.$element.css({ 'visibility': 'hidden' }).show().scrollTop(0);\\n        if (this.options.overlay) {\\n          this.$overlay.css({ 'visibility': 'hidden' }).show();\\n        }\\n\\n        this._updatePosition();\\n\\n        this.$element.hide().css({ 'visibility': '' });\\n\\n        if (this.$overlay) {\\n          this.$overlay.css({ 'visibility': '' }).hide();\\n          if (this.$element.hasClass('fast')) {\\n            this.$overlay.addClass('fast');\\n          } else if (this.$element.hasClass('slow')) {\\n            this.$overlay.addClass('slow');\\n          }\\n        }\\n\\n        if (!this.options.multipleOpened) {\\n          /**\\n           * Fires immediately before the modal opens.\\n           * Closes any other modals that are currently open\\n           * @event Reveal#closeme\\n           */\\n          this.$element.trigger('closeme.zf.reveal', this.id);\\n        }\\n        // Motion UI method of reveal\\n        if (this.options.animationIn) {\\n          var _this;\\n\\n          (function () {\\n            var afterAnimationFocus = function () {\\n              _this.$element.attr({\\n                'aria-hidden': false,\\n                'tabindex': -1\\n              }).focus();\\n              console.log('focus');\\n            };\\n\\n            _this = _this3;\\n\\n            if (_this3.options.overlay) {\\n              Foundation.Motion.animateIn(_this3.$overlay, 'fade-in');\\n            }\\n            Foundation.Motion.animateIn(_this3.$element, _this3.options.animationIn, function () {\\n              _this3.focusableElements = Foundation.Keyboard.findFocusable(_this3.$element);\\n              afterAnimationFocus();\\n            });\\n          })();\\n        }\\n        // jQuery method of reveal\\n        else {\\n            if (this.options.overlay) {\\n              this.$overlay.show(0);\\n            }\\n            this.$element.show(this.options.showDelay);\\n          }\\n\\n        // handle accessibility\\n        this.$element.attr({\\n          'aria-hidden': false,\\n          'tabindex': -1\\n        }).focus();\\n\\n        /**\\n         * Fires when the modal has successfully opened.\\n         * @event Reveal#open\\n         */\\n        this.$element.trigger('open.zf.reveal');\\n\\n        if (this.isMobile) {\\n          this.originalScrollPos = window.pageYOffset;\\n          $('html, body').addClass('is-reveal-open');\\n        } else {\\n          $('body').addClass('is-reveal-open');\\n        }\\n\\n        setTimeout(function () {\\n          _this3._extraHandlers();\\n        }, 0);\\n      }\\n\\n      /**\\n       * Adds extra event handlers for the body and window if necessary.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_extraHandlers',\\n      value: function _extraHandlers() {\\n        var _this = this;\\n        this.focusableElements = Foundation.Keyboard.findFocusable(this.$element);\\n\\n        if (!this.options.overlay && this.options.closeOnClick && !this.options.fullScreen) {\\n          $('body').on('click.zf.reveal', function (e) {\\n            if (e.target === _this.$element[0] || $.contains(_this.$element[0], e.target)) {\\n              return;\\n            }\\n            _this.close();\\n          });\\n        }\\n\\n        if (this.options.closeOnEsc) {\\n          $(window).on('keydown.zf.reveal', function (e) {\\n            Foundation.Keyboard.handleKey(e, 'Reveal', {\\n              close: function () {\\n                if (_this.options.closeOnEsc) {\\n                  _this.close();\\n                  _this.$anchor.focus();\\n                }\\n              }\\n            });\\n          });\\n        }\\n\\n        // lock focus within modal while tabbing\\n        this.$element.on('keydown.zf.reveal', function (e) {\\n          var $target = $(this);\\n          // handle keyboard event with keyboard util\\n          Foundation.Keyboard.handleKey(e, 'Reveal', {\\n            tab_forward: function () {\\n              if (_this.$element.find(':focus').is(_this.focusableElements.eq(-1))) {\\n                // left modal downwards, setting focus to first element\\n                _this.focusableElements.eq(0).focus();\\n                return true;\\n              }\\n              if (_this.focusableElements.length === 0) {\\n                // no focusable elements inside the modal at all, prevent tabbing in general\\n                return true;\\n              }\\n            },\\n            tab_backward: function () {\\n              if (_this.$element.find(':focus').is(_this.focusableElements.eq(0)) || _this.$element.is(':focus')) {\\n                // left modal upwards, setting focus to last element\\n                _this.focusableElements.eq(-1).focus();\\n                return true;\\n              }\\n              if (_this.focusableElements.length === 0) {\\n                // no focusable elements inside the modal at all, prevent tabbing in general\\n                return true;\\n              }\\n            },\\n            open: function () {\\n              if (_this.$element.find(':focus').is(_this.$element.find('[data-close]'))) {\\n                setTimeout(function () {\\n                  // set focus back to anchor if close button has been activated\\n                  _this.$anchor.focus();\\n                }, 1);\\n              } else if ($target.is(_this.focusableElements)) {\\n                // dont't trigger if acual element has focus (i.e. inputs, links, ...)\\n                _this.open();\\n              }\\n            },\\n            close: function () {\\n              if (_this.options.closeOnEsc) {\\n                _this.close();\\n                _this.$anchor.focus();\\n              }\\n            },\\n            handled: function (preventDefault) {\\n              if (preventDefault) {\\n                e.preventDefault();\\n              }\\n            }\\n          });\\n        });\\n      }\\n\\n      /**\\n       * Closes the modal.\\n       * @function\\n       * @fires Reveal#closed\\n       */\\n\\n    }, {\\n      key: 'close',\\n      value: function close() {\\n        if (!this.isActive || !this.$element.is(':visible')) {\\n          return false;\\n        }\\n        var _this = this;\\n\\n        // Motion UI method of hiding\\n        if (this.options.animationOut) {\\n          if (this.options.overlay) {\\n            Foundation.Motion.animateOut(this.$overlay, 'fade-out', finishUp);\\n          } else {\\n            finishUp();\\n          }\\n\\n          Foundation.Motion.animateOut(this.$element, this.options.animationOut);\\n        }\\n        // jQuery method of hiding\\n        else {\\n            if (this.options.overlay) {\\n              this.$overlay.hide(0, finishUp);\\n            } else {\\n              finishUp();\\n            }\\n\\n            this.$element.hide(this.options.hideDelay);\\n          }\\n\\n        // Conditionals to remove extra event listeners added on open\\n        if (this.options.closeOnEsc) {\\n          $(window).off('keydown.zf.reveal');\\n        }\\n\\n        if (!this.options.overlay && this.options.closeOnClick) {\\n          $('body').off('click.zf.reveal');\\n        }\\n\\n        this.$element.off('keydown.zf.reveal');\\n\\n        function finishUp() {\\n          if (_this.isMobile) {\\n            $('html, body').removeClass('is-reveal-open');\\n            if (_this.originalScrollPos) {\\n              $('body').scrollTop(_this.originalScrollPos);\\n              _this.originalScrollPos = null;\\n            }\\n          } else {\\n            $('body').removeClass('is-reveal-open');\\n          }\\n\\n          _this.$element.attr('aria-hidden', true);\\n\\n          /**\\n          * Fires when the modal is done closing.\\n          * @event Reveal#closed\\n          */\\n          _this.$element.trigger('closed.zf.reveal');\\n        }\\n\\n        /**\\n        * Resets the modal content\\n        * This prevents a running video to keep going in the background\\n        */\\n        if (this.options.resetOnClose) {\\n          this.$element.html(this.$element.html());\\n        }\\n\\n        this.isActive = false;\\n        if (_this.options.deepLink) {\\n          if (window.history.replaceState) {\\n            window.history.replaceState(\\\"\\\", document.title, window.location.pathname);\\n          } else {\\n            window.location.hash = '';\\n          }\\n        }\\n      }\\n\\n      /**\\n       * Toggles the open/closed state of a modal.\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'toggle',\\n      value: function toggle() {\\n        if (this.isActive) {\\n          this.close();\\n        } else {\\n          this.open();\\n        }\\n      }\\n    }, {\\n      key: 'destroy',\\n\\n\\n      /**\\n       * Destroys an instance of a modal.\\n       * @function\\n       */\\n      value: function destroy() {\\n        if (this.options.overlay) {\\n          this.$element.appendTo($('body')); // move $element outside of $overlay to prevent error unregisterPlugin()\\n          this.$overlay.hide().off().remove();\\n        }\\n        this.$element.hide().off();\\n        this.$anchor.off('.zf');\\n        $(window).off('.zf.reveal:' + this.id);\\n\\n        Foundation.unregisterPlugin(this);\\n      }\\n    }]);\\n\\n    return Reveal;\\n  }();\\n\\n  Reveal.defaults = {\\n    /**\\n     * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.\\n     * @option\\n     * @example 'slide-in-left'\\n     */\\n    animationIn: '',\\n    /**\\n     * Motion-UI class to use for animated elements. If none used, defaults to simple show/hide.\\n     * @option\\n     * @example 'slide-out-right'\\n     */\\n    animationOut: '',\\n    /**\\n     * Time, in ms, to delay the opening of a modal after a click if no animation used.\\n     * @option\\n     * @example 10\\n     */\\n    showDelay: 0,\\n    /**\\n     * Time, in ms, to delay the closing of a modal after a click if no animation used.\\n     * @option\\n     * @example 10\\n     */\\n    hideDelay: 0,\\n    /**\\n     * Allows a click on the body/overlay to close the modal.\\n     * @option\\n     * @example true\\n     */\\n    closeOnClick: true,\\n    /**\\n     * Allows the modal to close if the user presses the `ESCAPE` key.\\n     * @option\\n     * @example true\\n     */\\n    closeOnEsc: true,\\n    /**\\n     * If true, allows multiple modals to be displayed at once.\\n     * @option\\n     * @example false\\n     */\\n    multipleOpened: false,\\n    /**\\n     * Distance, in pixels, the modal should push down from the top of the screen.\\n     * @option\\n     * @example auto\\n     */\\n    vOffset: 'auto',\\n    /**\\n     * Distance, in pixels, the modal should push in from the side of the screen.\\n     * @option\\n     * @example auto\\n     */\\n    hOffset: 'auto',\\n    /**\\n     * Allows the modal to be fullscreen, completely blocking out the rest of the view. JS checks for this as well.\\n     * @option\\n     * @example false\\n     */\\n    fullScreen: false,\\n    /**\\n     * Percentage of screen height the modal should push up from the bottom of the view.\\n     * @option\\n     * @example 10\\n     */\\n    btmOffsetPct: 10,\\n    /**\\n     * Allows the modal to generate an overlay div, which will cover the view when modal opens.\\n     * @option\\n     * @example true\\n     */\\n    overlay: true,\\n    /**\\n     * Allows the modal to remove and reinject markup on close. Should be true if using video elements w/o using provider's api, otherwise, videos will continue to play in the background.\\n     * @option\\n     * @example false\\n     */\\n    resetOnClose: false,\\n    /**\\n     * Allows the modal to alter the url on open/close, and allows the use of the `back` button to close modals. ALSO, allows a modal to auto-maniacally open on page load IF the hash === the modal's user-set id.\\n     * @option\\n     * @example false\\n     */\\n    deepLink: false\\n  };\\n\\n  // Window exports\\n  Foundation.plugin(Reveal, 'Reveal');\\n\\n  function iPhoneSniff() {\\n    return (/iP(ad|hone|od).*OS/.test(window.navigator.userAgent)\\n    );\\n  }\\n\\n  function androidSniff() {\\n    return (/Android/.test(window.navigator.userAgent)\\n    );\\n  }\\n\\n  function mobileSniff() {\\n    return iPhoneSniff() || androidSniff();\\n  }\\n}(jQuery);\\n'use strict';\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n!function ($) {\\n\\n  /**\\n   * Slider module.\\n   * @module foundation.slider\\n   * @requires foundation.util.motion\\n   * @requires foundation.util.triggers\\n   * @requires foundation.util.keyboard\\n   * @requires foundation.util.touch\\n   */\\n\\n  var Slider = function () {\\n    /**\\n     * Creates a new instance of a drilldown menu.\\n     * @class\\n     * @param {jQuery} element - jQuery object to make into an accordion menu.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n\\n    function Slider(element, options) {\\n      _classCallCheck(this, Slider);\\n\\n      this.$element = element;\\n      this.options = $.extend({}, Slider.defaults, this.$element.data(), options);\\n\\n      this._init();\\n\\n      Foundation.registerPlugin(this, 'Slider');\\n      Foundation.Keyboard.register('Slider', {\\n        'ltr': {\\n          'ARROW_RIGHT': 'increase',\\n          'ARROW_UP': 'increase',\\n          'ARROW_DOWN': 'decrease',\\n          'ARROW_LEFT': 'decrease',\\n          'SHIFT_ARROW_RIGHT': 'increase_fast',\\n          'SHIFT_ARROW_UP': 'increase_fast',\\n          'SHIFT_ARROW_DOWN': 'decrease_fast',\\n          'SHIFT_ARROW_LEFT': 'decrease_fast'\\n        },\\n        'rtl': {\\n          'ARROW_LEFT': 'increase',\\n          'ARROW_RIGHT': 'decrease',\\n          'SHIFT_ARROW_LEFT': 'increase_fast',\\n          'SHIFT_ARROW_RIGHT': 'decrease_fast'\\n        }\\n      });\\n    }\\n\\n    /**\\n     * Initilizes the plugin by reading/setting attributes, creating collections and setting the initial position of the handle(s).\\n     * @function\\n     * @private\\n     */\\n\\n\\n    _createClass(Slider, [{\\n      key: '_init',\\n      value: function _init() {\\n        this.inputs = this.$element.find('input');\\n        this.handles = this.$element.find('[data-slider-handle]');\\n\\n        this.$handle = this.handles.eq(0);\\n        this.$input = this.inputs.length ? this.inputs.eq(0) : $('#' + this.$handle.attr('aria-controls'));\\n        this.$fill = this.$element.find('[data-slider-fill]').css(this.options.vertical ? 'height' : 'width', 0);\\n\\n        var isDbl = false,\\n            _this = this;\\n        if (this.options.disabled || this.$element.hasClass(this.options.disabledClass)) {\\n          this.options.disabled = true;\\n          this.$element.addClass(this.options.disabledClass);\\n        }\\n        if (!this.inputs.length) {\\n          this.inputs = $().add(this.$input);\\n          this.options.binding = true;\\n        }\\n        this._setInitAttr(0);\\n        this._events(this.$handle);\\n\\n        if (this.handles[1]) {\\n          this.options.doubleSided = true;\\n          this.$handle2 = this.handles.eq(1);\\n          this.$input2 = this.inputs.length > 1 ? this.inputs.eq(1) : $('#' + this.$handle2.attr('aria-controls'));\\n\\n          if (!this.inputs[1]) {\\n            this.inputs = this.inputs.add(this.$input2);\\n          }\\n          isDbl = true;\\n\\n          this._setHandlePos(this.$handle, this.options.initialStart, true, function () {\\n\\n            _this._setHandlePos(_this.$handle2, _this.options.initialEnd, true);\\n          });\\n          // this.$handle.triggerHandler('click.zf.slider');\\n          this._setInitAttr(1);\\n          this._events(this.$handle2);\\n        }\\n\\n        if (!isDbl) {\\n          this._setHandlePos(this.$handle, this.options.initialStart, true);\\n        }\\n      }\\n\\n      /**\\n       * Sets the position of the selected handle and fill bar.\\n       * @function\\n       * @private\\n       * @param {jQuery} $hndl - the selected handle to move.\\n       * @param {Number} location - floating point between the start and end values of the slider bar.\\n       * @param {Function} cb - callback function to fire on completion.\\n       * @fires Slider#moved\\n       * @fires Slider#changed\\n       */\\n\\n    }, {\\n      key: '_setHandlePos',\\n      value: function _setHandlePos($hndl, location, noInvert, cb) {\\n        // don't move if the slider has been disabled since its initialization\\n        if (this.$element.hasClass(this.options.disabledClass)) {\\n          return;\\n        }\\n        //might need to alter that slightly for bars that will have odd number selections.\\n        location = parseFloat(location); //on input change events, convert string to number...grumble.\\n\\n        // prevent slider from running out of bounds, if value exceeds the limits set through options, override the value to min/max\\n        if (location < this.options.start) {\\n          location = this.options.start;\\n        } else if (location > this.options.end) {\\n          location = this.options.end;\\n        }\\n\\n        var isDbl = this.options.doubleSided;\\n\\n        if (isDbl) {\\n          //this block is to prevent 2 handles from crossing eachother. Could/should be improved.\\n          if (this.handles.index($hndl) === 0) {\\n            var h2Val = parseFloat(this.$handle2.attr('aria-valuenow'));\\n            location = location >= h2Val ? h2Val - this.options.step : location;\\n          } else {\\n            var h1Val = parseFloat(this.$handle.attr('aria-valuenow'));\\n            location = location <= h1Val ? h1Val + this.options.step : location;\\n          }\\n        }\\n\\n        //this is for single-handled vertical sliders, it adjusts the value to account for the slider being \\\"upside-down\\\"\\n        //for click and drag events, it's weird due to the scale(-1, 1) css property\\n        if (this.options.vertical && !noInvert) {\\n          location = this.options.end - location;\\n        }\\n\\n        var _this = this,\\n            vert = this.options.vertical,\\n            hOrW = vert ? 'height' : 'width',\\n            lOrT = vert ? 'top' : 'left',\\n            handleDim = $hndl[0].getBoundingClientRect()[hOrW],\\n            elemDim = this.$element[0].getBoundingClientRect()[hOrW],\\n\\n        //percentage of bar min/max value based on click or drag point\\n        pctOfBar = percent(location - this.options.start, this.options.end - this.options.start).toFixed(2),\\n\\n        //number of actual pixels to shift the handle, based on the percentage obtained above\\n        pxToMove = (elemDim - handleDim) * pctOfBar,\\n\\n        //percentage of bar to shift the handle\\n        movement = (percent(pxToMove, elemDim) * 100).toFixed(this.options.decimal);\\n        //fixing the decimal value for the location number, is passed to other methods as a fixed floating-point value\\n        location = parseFloat(location.toFixed(this.options.decimal));\\n        // declare empty object for css adjustments, only used with 2 handled-sliders\\n        var css = {};\\n\\n        this._setValues($hndl, location);\\n\\n        // TODO update to calculate based on values set to respective inputs??\\n        if (isDbl) {\\n          var isLeftHndl = this.handles.index($hndl) === 0,\\n\\n          //empty variable, will be used for min-height/width for fill bar\\n          dim,\\n\\n          //percentage w/h of the handle compared to the slider bar\\n          handlePct = ~ ~(percent(handleDim, elemDim) * 100);\\n          //if left handle, the math is slightly different than if it's the right handle, and the left/top property needs to be changed for the fill bar\\n          if (isLeftHndl) {\\n            //left or top percentage value to apply to the fill bar.\\n            css[lOrT] = movement + '%';\\n            //calculate the new min-height/width for the fill bar.\\n            dim = parseFloat(this.$handle2[0].style[lOrT]) - movement + handlePct;\\n            //this callback is necessary to prevent errors and allow the proper placement and initialization of a 2-handled slider\\n            //plus, it means we don't care if 'dim' isNaN on init, it won't be in the future.\\n            if (cb && typeof cb === 'function') {\\n              cb();\\n            } //this is only needed for the initialization of 2 handled sliders\\n          } else {\\n              //just caching the value of the left/bottom handle's left/top property\\n              var handlePos = parseFloat(this.$handle[0].style[lOrT]);\\n              //calculate the new min-height/width for the fill bar. Use isNaN to prevent false positives for numbers <= 0\\n              //based on the percentage of movement of the handle being manipulated, less the opposing handle's left/top position, plus the percentage w/h of the handle itself\\n              dim = movement - (isNaN(handlePos) ? this.options.initialStart / ((this.options.end - this.options.start) / 100) : handlePos) + handlePct;\\n            }\\n          // assign the min-height/width to our css object\\n          css['min-' + hOrW] = dim + '%';\\n        }\\n\\n        this.$element.one('finished.zf.animate', function () {\\n          /**\\n           * Fires when the handle is done moving.\\n           * @event Slider#moved\\n           */\\n          _this.$element.trigger('moved.zf.slider', [$hndl]);\\n        });\\n\\n        //because we don't know exactly how the handle will be moved, check the amount of time it should take to move.\\n        var moveTime = this.$element.data('dragging') ? 1000 / 60 : this.options.moveTime;\\n\\n        Foundation.Move(moveTime, $hndl, function () {\\n          //adjusting the left/top property of the handle, based on the percentage calculated above\\n          $hndl.css(lOrT, movement + '%');\\n\\n          if (!_this.options.doubleSided) {\\n            //if single-handled, a simple method to expand the fill bar\\n            _this.$fill.css(hOrW, pctOfBar * 100 + '%');\\n          } else {\\n            //otherwise, use the css object we created above\\n            _this.$fill.css(css);\\n          }\\n        });\\n\\n        /**\\n         * Fires when the value has not been change for a given time.\\n         * @event Slider#changed\\n         */\\n        clearTimeout(_this.timeout);\\n        _this.timeout = setTimeout(function () {\\n          _this.$element.trigger('changed.zf.slider', [$hndl]);\\n        }, _this.options.changedDelay);\\n      }\\n\\n      /**\\n       * Sets the initial attribute for the slider element.\\n       * @function\\n       * @private\\n       * @param {Number} idx - index of the current handle/input to use.\\n       */\\n\\n    }, {\\n      key: '_setInitAttr',\\n      value: function _setInitAttr(idx) {\\n        var id = this.inputs.eq(idx).attr('id') || Foundation.GetYoDigits(6, 'slider');\\n        this.inputs.eq(idx).attr({\\n          'id': id,\\n          'max': this.options.end,\\n          'min': this.options.start,\\n          'step': this.options.step\\n        });\\n        this.handles.eq(idx).attr({\\n          'role': 'slider',\\n          'aria-controls': id,\\n          'aria-valuemax': this.options.end,\\n          'aria-valuemin': this.options.start,\\n          'aria-valuenow': idx === 0 ? this.options.initialStart : this.options.initialEnd,\\n          'aria-orientation': this.options.vertical ? 'vertical' : 'horizontal',\\n          'tabindex': 0\\n        });\\n      }\\n\\n      /**\\n       * Sets the input and `aria-valuenow` values for the slider element.\\n       * @function\\n       * @private\\n       * @param {jQuery} $handle - the currently selected handle.\\n       * @param {Number} val - floating point of the new value.\\n       */\\n\\n    }, {\\n      key: '_setValues',\\n      value: function _setValues($handle, val) {\\n        var idx = this.options.doubleSided ? this.handles.index($handle) : 0;\\n        this.inputs.eq(idx).val(val);\\n        $handle.attr('aria-valuenow', val);\\n      }\\n\\n      /**\\n       * Handles events on the slider element.\\n       * Calculates the new location of the current handle.\\n       * If there are two handles and the bar was clicked, it determines which handle to move.\\n       * @function\\n       * @private\\n       * @param {Object} e - the `event` object passed from the listener.\\n       * @param {jQuery} $handle - the current handle to calculate for, if selected.\\n       * @param {Number} val - floating point number for the new value of the slider.\\n       * TODO clean this up, there's a lot of repeated code between this and the _setHandlePos fn.\\n       */\\n\\n    }, {\\n      key: '_handleEvent',\\n      value: function _handleEvent(e, $handle, val) {\\n        var value, hasVal;\\n        if (!val) {\\n          //click or drag events\\n          e.preventDefault();\\n          var _this = this,\\n              vertical = this.options.vertical,\\n              param = vertical ? 'height' : 'width',\\n              direction = vertical ? 'top' : 'left',\\n              eventOffset = vertical ? e.pageY : e.pageX,\\n              halfOfHandle = this.$handle[0].getBoundingClientRect()[param] / 2,\\n              barDim = this.$element[0].getBoundingClientRect()[param],\\n              windowScroll = vertical ? $(window).scrollTop() : $(window).scrollLeft();\\n\\n          var elemOffset = this.$element.offset()[direction];\\n\\n          // touch events emulated by the touch util give position relative to screen, add window.scroll to event coordinates...\\n          // best way to guess this is simulated is if clientY == pageY\\n          if (e.clientY === e.pageY) {\\n            eventOffset = eventOffset + windowScroll;\\n          }\\n          var eventFromBar = eventOffset - elemOffset;\\n          var barXY;\\n          if (eventFromBar < 0) {\\n            barXY = 0;\\n          } else if (eventFromBar > barDim) {\\n            barXY = barDim;\\n          } else {\\n            barXY = eventFromBar;\\n          }\\n          offsetPct = percent(barXY, barDim);\\n\\n          value = (this.options.end - this.options.start) * offsetPct + this.options.start;\\n\\n          // turn everything around for RTL, yay math!\\n          if (Foundation.rtl() && !this.options.vertical) {\\n            value = this.options.end - value;\\n          }\\n\\n          value = _this._adjustValue(null, value);\\n          //boolean flag for the setHandlePos fn, specifically for vertical sliders\\n          hasVal = false;\\n\\n          if (!$handle) {\\n            //figure out which handle it is, pass it to the next function.\\n            var firstHndlPos = absPosition(this.$handle, direction, barXY, param),\\n                secndHndlPos = absPosition(this.$handle2, direction, barXY, param);\\n            $handle = firstHndlPos <= secndHndlPos ? this.$handle : this.$handle2;\\n          }\\n        } else {\\n          //change event on input\\n          value = this._adjustValue(null, val);\\n          hasVal = true;\\n        }\\n\\n        this._setHandlePos($handle, value, hasVal);\\n      }\\n\\n      /**\\n       * Adjustes value for handle in regard to step value. returns adjusted value\\n       * @function\\n       * @private\\n       * @param {jQuery} $handle - the selected handle.\\n       * @param {Number} value - value to adjust. used if $handle is falsy\\n       */\\n\\n    }, {\\n      key: '_adjustValue',\\n      value: function _adjustValue($handle, value) {\\n        var val,\\n            step = this.options.step,\\n            div = parseFloat(step / 2),\\n            left,\\n            prev_val,\\n            next_val;\\n        if (!!$handle) {\\n          val = parseFloat($handle.attr('aria-valuenow'));\\n        } else {\\n          val = value;\\n        }\\n        left = val % step;\\n        prev_val = val - left;\\n        next_val = prev_val + step;\\n        if (left === 0) {\\n          return val;\\n        }\\n        val = val >= prev_val + div ? next_val : prev_val;\\n        return val;\\n      }\\n\\n      /**\\n       * Adds event listeners to the slider elements.\\n       * @function\\n       * @private\\n       * @param {jQuery} $handle - the current handle to apply listeners to.\\n       */\\n\\n    }, {\\n      key: '_events',\\n      value: function _events($handle) {\\n        var _this = this,\\n            curHandle,\\n            timer;\\n\\n        this.inputs.off('change.zf.slider').on('change.zf.slider', function (e) {\\n          var idx = _this.inputs.index($(this));\\n          _this._handleEvent(e, _this.handles.eq(idx), $(this).val());\\n        });\\n\\n        if (this.options.clickSelect) {\\n          this.$element.off('click.zf.slider').on('click.zf.slider', function (e) {\\n            if (_this.$element.data('dragging')) {\\n              return false;\\n            }\\n\\n            if (!$(e.target).is('[data-slider-handle]')) {\\n              if (_this.options.doubleSided) {\\n                _this._handleEvent(e);\\n              } else {\\n                _this._handleEvent(e, _this.$handle);\\n              }\\n            }\\n          });\\n        }\\n\\n        if (this.options.draggable) {\\n          this.handles.addTouch();\\n\\n          var $body = $('body');\\n          $handle.off('mousedown.zf.slider').on('mousedown.zf.slider', function (e) {\\n            $handle.addClass('is-dragging');\\n            _this.$fill.addClass('is-dragging'); //\\n            _this.$element.data('dragging', true);\\n\\n            curHandle = $(e.currentTarget);\\n\\n            $body.on('mousemove.zf.slider', function (e) {\\n              e.preventDefault();\\n              _this._handleEvent(e, curHandle);\\n            }).on('mouseup.zf.slider', function (e) {\\n              _this._handleEvent(e, curHandle);\\n\\n              $handle.removeClass('is-dragging');\\n              _this.$fill.removeClass('is-dragging');\\n              _this.$element.data('dragging', false);\\n\\n              $body.off('mousemove.zf.slider mouseup.zf.slider');\\n            });\\n          })\\n          // prevent events triggered by touch\\n          .on('selectstart.zf.slider touchmove.zf.slider', function (e) {\\n            e.preventDefault();\\n          });\\n        }\\n\\n        $handle.off('keydown.zf.slider').on('keydown.zf.slider', function (e) {\\n          var _$handle = $(this),\\n              idx = _this.options.doubleSided ? _this.handles.index(_$handle) : 0,\\n              oldValue = parseFloat(_this.inputs.eq(idx).val()),\\n              newValue;\\n\\n          // handle keyboard event with keyboard util\\n          Foundation.Keyboard.handleKey(e, 'Slider', {\\n            decrease: function () {\\n              newValue = oldValue - _this.options.step;\\n            },\\n            increase: function () {\\n              newValue = oldValue + _this.options.step;\\n            },\\n            decrease_fast: function () {\\n              newValue = oldValue - _this.options.step * 10;\\n            },\\n            increase_fast: function () {\\n              newValue = oldValue + _this.options.step * 10;\\n            },\\n            handled: function () {\\n              // only set handle pos when event was handled specially\\n              e.preventDefault();\\n              _this._setHandlePos(_$handle, newValue, true);\\n            }\\n          });\\n          /*if (newValue) { // if pressed key has special function, update value\\n            e.preventDefault();\\n            _this._setHandlePos(_$handle, newValue);\\n          }*/\\n        });\\n      }\\n\\n      /**\\n       * Destroys the slider plugin.\\n       */\\n\\n    }, {\\n      key: 'destroy',\\n      value: function destroy() {\\n        this.handles.off('.zf.slider');\\n        this.inputs.off('.zf.slider');\\n        this.$element.off('.zf.slider');\\n\\n        Foundation.unregisterPlugin(this);\\n      }\\n    }]);\\n\\n    return Slider;\\n  }();\\n\\n  Slider.defaults = {\\n    /**\\n     * Minimum value for the slider scale.\\n     * @option\\n     * @example 0\\n     */\\n    start: 0,\\n    /**\\n     * Maximum value for the slider scale.\\n     * @option\\n     * @example 100\\n     */\\n    end: 100,\\n    /**\\n     * Minimum value change per change event.\\n     * @option\\n     * @example 1\\n     */\\n    step: 1,\\n    /**\\n     * Value at which the handle/input *(left handle/first input)* should be set to on initialization.\\n     * @option\\n     * @example 0\\n     */\\n    initialStart: 0,\\n    /**\\n     * Value at which the right handle/second input should be set to on initialization.\\n     * @option\\n     * @example 100\\n     */\\n    initialEnd: 100,\\n    /**\\n     * Allows the input to be located outside the container and visible. Set to by the JS\\n     * @option\\n     * @example false\\n     */\\n    binding: false,\\n    /**\\n     * Allows the user to click/tap on the slider bar to select a value.\\n     * @option\\n     * @example true\\n     */\\n    clickSelect: true,\\n    /**\\n     * Set to true and use the `vertical` class to change alignment to vertical.\\n     * @option\\n     * @example false\\n     */\\n    vertical: false,\\n    /**\\n     * Allows the user to drag the slider handle(s) to select a value.\\n     * @option\\n     * @example true\\n     */\\n    draggable: true,\\n    /**\\n     * Disables the slider and prevents event listeners from being applied. Double checked by JS with `disabledClass`.\\n     * @option\\n     * @example false\\n     */\\n    disabled: false,\\n    /**\\n     * Allows the use of two handles. Double checked by the JS. Changes some logic handling.\\n     * @option\\n     * @example false\\n     */\\n    doubleSided: false,\\n    /**\\n     * Potential future feature.\\n     */\\n    // steps: 100,\\n    /**\\n     * Number of decimal places the plugin should go to for floating point precision.\\n     * @option\\n     * @example 2\\n     */\\n    decimal: 2,\\n    /**\\n     * Time delay for dragged elements.\\n     */\\n    // dragDelay: 0,\\n    /**\\n     * Time, in ms, to animate the movement of a slider handle if user clicks/taps on the bar. Needs to be manually set if updating the transition time in the Sass settings.\\n     * @option\\n     * @example 200\\n     */\\n    moveTime: 200, //update this if changing the transition time in the sass\\n    /**\\n     * Class applied to disabled sliders.\\n     * @option\\n     * @example 'disabled'\\n     */\\n    disabledClass: 'disabled',\\n    /**\\n     * Will invert the default layout for a vertical<span data-tooltip title=\\\"who would do this???\\\"> </span>slider.\\n     * @option\\n     * @example false\\n     */\\n    invertVertical: false,\\n    /**\\n     * Milliseconds before the `changed.zf-slider` event is triggered after value change.\\n     * @option\\n     * @example 500\\n     */\\n    changedDelay: 500\\n  };\\n\\n  function percent(frac, num) {\\n    return frac / num;\\n  }\\n  function absPosition($handle, dir, clickPos, param) {\\n    return Math.abs($handle.position()[dir] + $handle[param]() / 2 - clickPos);\\n  }\\n\\n  // Window exports\\n  Foundation.plugin(Slider, 'Slider');\\n}(jQuery);\\n\\n//*********this is in case we go to static, absolute positions instead of dynamic positioning********\\n// this.setSteps(function() {\\n//   _this._events();\\n//   var initStart = _this.options.positions[_this.options.initialStart - 1] || null;\\n//   var initEnd = _this.options.initialEnd ? _this.options.position[_this.options.initialEnd - 1] : null;\\n//   if (initStart || initEnd) {\\n//     _this._handleEvent(initStart, initEnd);\\n//   }\\n// });\\n\\n//***********the other part of absolute positions*************\\n// Slider.prototype.setSteps = function(cb) {\\n//   var posChange = this.$element.outerWidth() / this.options.steps;\\n//   var counter = 0\\n//   while(counter < this.options.steps) {\\n//     if (counter) {\\n//       this.options.positions.push(this.options.positions[counter - 1] + posChange);\\n//     } else {\\n//       this.options.positions.push(posChange);\\n//     }\\n//     counter++;\\n//   }\\n//   cb();\\n// };\\n'use strict';\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n!function ($) {\\n\\n  /**\\n   * Sticky module.\\n   * @module foundation.sticky\\n   * @requires foundation.util.triggers\\n   * @requires foundation.util.mediaQuery\\n   */\\n\\n  var Sticky = function () {\\n    /**\\n     * Creates a new instance of a sticky thing.\\n     * @class\\n     * @param {jQuery} element - jQuery object to make sticky.\\n     * @param {Object} options - options object passed when creating the element programmatically.\\n     */\\n\\n    function Sticky(element, options) {\\n      _classCallCheck(this, Sticky);\\n\\n      this.$element = element;\\n      this.options = $.extend({}, Sticky.defaults, this.$element.data(), options);\\n\\n      this._init();\\n\\n      Foundation.registerPlugin(this, 'Sticky');\\n    }\\n\\n    /**\\n     * Initializes the sticky element by adding classes, getting/setting dimensions, breakpoints and attributes\\n     * @function\\n     * @private\\n     */\\n\\n\\n    _createClass(Sticky, [{\\n      key: '_init',\\n      value: function _init() {\\n        var $parent = this.$element.parent('[data-sticky-container]'),\\n            id = this.$element[0].id || Foundation.GetYoDigits(6, 'sticky'),\\n            _this = this;\\n\\n        if (!$parent.length) {\\n          this.wasWrapped = true;\\n        }\\n        this.$container = $parent.length ? $parent : $(this.options.container).wrapInner(this.$element);\\n        this.$container.addClass(this.options.containerClass);\\n\\n        this.$element.addClass(this.options.stickyClass).attr({ 'data-resize': id });\\n\\n        this.scrollCount = this.options.checkEvery;\\n        this.isStuck = false;\\n        $(window).one('load.zf.sticky', function () {\\n          if (_this.options.anchor !== '') {\\n            _this.$anchor = $('#' + _this.options.anchor);\\n          } else {\\n            _this._parsePoints();\\n          }\\n\\n          _this._setSizes(function () {\\n            _this._calc(false);\\n          });\\n          _this._events(id.split('-').reverse().join('-'));\\n        });\\n      }\\n\\n      /**\\n       * If using multiple elements as anchors, calculates the top and bottom pixel values the sticky thing should stick and unstick on.\\n       * @function\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_parsePoints',\\n      value: function _parsePoints() {\\n        var top = this.options.topAnchor == \\\"\\\" ? 1 : this.options.topAnchor,\\n            btm = this.options.btmAnchor == \\\"\\\" ? document.documentElement.scrollHeight : this.options.btmAnchor,\\n            pts = [top, btm],\\n            breaks = {};\\n        for (var i = 0, len = pts.length; i < len && pts[i]; i++) {\\n          var pt;\\n          if (typeof pts[i] === 'number') {\\n            pt = pts[i];\\n          } else {\\n            var place = pts[i].split(':'),\\n                anchor = $('#' + place[0]);\\n\\n            pt = anchor.offset().top;\\n            if (place[1] && place[1].toLowerCase() === 'bottom') {\\n              pt += anchor[0].getBoundingClientRect().height;\\n            }\\n          }\\n          breaks[i] = pt;\\n        }\\n\\n        this.points = breaks;\\n        return;\\n      }\\n\\n      /**\\n       * Adds event handlers for the scrolling element.\\n       * @private\\n       * @param {String} id - psuedo-random id for unique scroll event listener.\\n       */\\n\\n    }, {\\n      key: '_events',\\n      value: function _events(id) {\\n        var _this = this,\\n            scrollListener = this.scrollListener = 'scroll.zf.' + id;\\n        if (this.isOn) {\\n          return;\\n        }\\n        if (this.canStick) {\\n          this.isOn = true;\\n          $(window).off(scrollListener).on(scrollListener, function (e) {\\n            if (_this.scrollCount === 0) {\\n              _this.scrollCount = _this.options.checkEvery;\\n              _this._setSizes(function () {\\n                _this._calc(false, window.pageYOffset);\\n              });\\n            } else {\\n              _this.scrollCount--;\\n              _this._calc(false, window.pageYOffset);\\n            }\\n          });\\n        }\\n\\n        this.$element.off('resizeme.zf.trigger').on('resizeme.zf.trigger', function (e, el) {\\n          _this._setSizes(function () {\\n            _this._calc(false);\\n            if (_this.canStick) {\\n              if (!_this.isOn) {\\n                _this._events(id);\\n              }\\n            } else if (_this.isOn) {\\n              _this._pauseListeners(scrollListener);\\n            }\\n          });\\n        });\\n      }\\n\\n      /**\\n       * Removes event handlers for scroll and change events on anchor.\\n       * @fires Sticky#pause\\n       * @param {String} scrollListener - unique, namespaced scroll listener attached to `window`\\n       */\\n\\n    }, {\\n      key: '_pauseListeners',\\n      value: function _pauseListeners(scrollListener) {\\n        this.isOn = false;\\n        $(window).off(scrollListener);\\n\\n        /**\\n         * Fires when the plugin is paused due to resize event shrinking the view.\\n         * @event Sticky#pause\\n         * @private\\n         */\\n        this.$element.trigger('pause.zf.sticky');\\n      }\\n\\n      /**\\n       * Called on every `scroll` event and on `_init`\\n       * fires functions based on booleans and cached values\\n       * @param {Boolean} checkSizes - true if plugin should recalculate sizes and breakpoints.\\n       * @param {Number} scroll - current scroll position passed from scroll event cb function. If not passed, defaults to `window.pageYOffset`.\\n       */\\n\\n    }, {\\n      key: '_calc',\\n      value: function _calc(checkSizes, scroll) {\\n        if (checkSizes) {\\n          this._setSizes();\\n        }\\n\\n        if (!this.canStick) {\\n          if (this.isStuck) {\\n            this._removeSticky(true);\\n          }\\n          return false;\\n        }\\n\\n        if (!scroll) {\\n          scroll = window.pageYOffset;\\n        }\\n\\n        if (scroll >= this.topPoint) {\\n          if (scroll <= this.bottomPoint) {\\n            if (!this.isStuck) {\\n              this._setSticky();\\n            }\\n          } else {\\n            if (this.isStuck) {\\n              this._removeSticky(false);\\n            }\\n          }\\n        } else {\\n          if (this.isStuck) {\\n            this._removeSticky(true);\\n          }\\n        }\\n      }\\n\\n      /**\\n       * Causes the $element to become stuck.\\n       * Adds `position: fixed;`, and helper classes.\\n       * @fires Sticky#stuckto\\n       * @function\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_setSticky',\\n      value: function _setSticky() {\\n        var _this = this,\\n            stickTo = this.options.stickTo,\\n            mrgn = stickTo === 'top' ? 'marginTop' : 'marginBottom',\\n            notStuckTo = stickTo === 'top' ? 'bottom' : 'top',\\n            css = {};\\n\\n        css[mrgn] = this.options[mrgn] + 'em';\\n        css[stickTo] = 0;\\n        css[notStuckTo] = 'auto';\\n        css['left'] = this.$container.offset().left + parseInt(window.getComputedStyle(this.$container[0])[\\\"padding-left\\\"], 10);\\n        this.isStuck = true;\\n        this.$element.removeClass('is-anchored is-at-' + notStuckTo).addClass('is-stuck is-at-' + stickTo).css(css)\\n        /**\\n         * Fires when the $element has become `position: fixed;`\\n         * Namespaced to `top` or `bottom`, e.g. `sticky.zf.stuckto:top`\\n         * @event Sticky#stuckto\\n         */\\n        .trigger('sticky.zf.stuckto:' + stickTo);\\n        this.$element.on(\\\"transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd\\\", function () {\\n          _this._setSizes();\\n        });\\n      }\\n\\n      /**\\n       * Causes the $element to become unstuck.\\n       * Removes `position: fixed;`, and helper classes.\\n       * Adds other helper classes.\\n       * @param {Boolean} isTop - tells the function if the $element should anchor to the top or bottom of its $anchor element.\\n       * @fires Sticky#unstuckfrom\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_removeSticky',\\n      value: function _removeSticky(isTop) {\\n        var stickTo = this.options.stickTo,\\n            stickToTop = stickTo === 'top',\\n            css = {},\\n            anchorPt = (this.points ? this.points[1] - this.points[0] : this.anchorHeight) - this.elemHeight,\\n            mrgn = stickToTop ? 'marginTop' : 'marginBottom',\\n            notStuckTo = stickToTop ? 'bottom' : 'top',\\n            topOrBottom = isTop ? 'top' : 'bottom';\\n\\n        css[mrgn] = 0;\\n\\n        css['bottom'] = 'auto';\\n        if (isTop) {\\n          css['top'] = 0;\\n        } else {\\n          css['top'] = anchorPt;\\n        }\\n\\n        css['left'] = '';\\n        this.isStuck = false;\\n        this.$element.removeClass('is-stuck is-at-' + stickTo).addClass('is-anchored is-at-' + topOrBottom).css(css)\\n        /**\\n         * Fires when the $element has become anchored.\\n         * Namespaced to `top` or `bottom`, e.g. `sticky.zf.unstuckfrom:bottom`\\n         * @event Sticky#unstuckfrom\\n         */\\n        .trigger('sticky.zf.unstuckfrom:' + topOrBottom);\\n      }\\n\\n      /**\\n       * Sets the $element and $container sizes for plugin.\\n       * Calls `_setBreakPoints`.\\n       * @param {Function} cb - optional callback function to fire on completion of `_setBreakPoints`.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_setSizes',\\n      value: function _setSizes(cb) {\\n        this.canStick = Foundation.MediaQuery.atLeast(this.options.stickyOn);\\n        if (!this.canStick) {\\n          cb();\\n        }\\n        var _this = this,\\n            newElemWidth = this.$container[0].getBoundingClientRect().width,\\n            comp = window.getComputedStyle(this.$container[0]),\\n            pdng = parseInt(comp['padding-right'], 10);\\n\\n        if (this.$anchor && this.$anchor.length) {\\n          this.anchorHeight = this.$anchor[0].getBoundingClientRect().height;\\n        } else {\\n          this._parsePoints();\\n        }\\n\\n        this.$element.css({\\n          'max-width': newElemWidth - pdng + 'px'\\n        });\\n\\n        var newContainerHeight = this.$element[0].getBoundingClientRect().height || this.containerHeight;\\n        if (this.$element.css(\\\"display\\\") == \\\"none\\\") {\\n          newContainerHeight = 0;\\n        }\\n        this.containerHeight = newContainerHeight;\\n        this.$container.css({\\n          height: newContainerHeight\\n        });\\n        this.elemHeight = newContainerHeight;\\n\\n        if (this.isStuck) {\\n          this.$element.css({ \\\"left\\\": this.$container.offset().left + parseInt(comp['padding-left'], 10) });\\n        }\\n\\n        this._setBreakPoints(newContainerHeight, function () {\\n          if (cb) {\\n            cb();\\n          }\\n        });\\n      }\\n\\n      /**\\n       * Sets the upper and lower breakpoints for the element to become sticky/unsticky.\\n       * @param {Number} elemHeight - px value for sticky.$element height, calculated by `_setSizes`.\\n       * @param {Function} cb - optional callback function to be called on completion.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_setBreakPoints',\\n      value: function _setBreakPoints(elemHeight, cb) {\\n        if (!this.canStick) {\\n          if (cb) {\\n            cb();\\n          } else {\\n            return false;\\n          }\\n        }\\n        var mTop = emCalc(this.options.marginTop),\\n            mBtm = emCalc(this.options.marginBottom),\\n            topPoint = this.points ? this.points[0] : this.$anchor.offset().top,\\n            bottomPoint = this.points ? this.points[1] : topPoint + this.anchorHeight,\\n\\n        // topPoint = this.$anchor.offset().top || this.points[0],\\n        // bottomPoint = topPoint + this.anchorHeight || this.points[1],\\n        winHeight = window.innerHeight;\\n\\n        if (this.options.stickTo === 'top') {\\n          topPoint -= mTop;\\n          bottomPoint -= elemHeight + mTop;\\n        } else if (this.options.stickTo === 'bottom') {\\n          topPoint -= winHeight - (elemHeight + mBtm);\\n          bottomPoint -= winHeight - mBtm;\\n        } else {\\n          //this would be the stickTo: both option... tricky\\n        }\\n\\n        this.topPoint = topPoint;\\n        this.bottomPoint = bottomPoint;\\n\\n        if (cb) {\\n          cb();\\n        }\\n      }\\n\\n      /**\\n       * Destroys the current sticky element.\\n       * Resets the element to the top position first.\\n       * Removes event listeners, JS-added css properties and classes, and unwraps the $element if the JS added the $container.\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'destroy',\\n      value: function destroy() {\\n        this._removeSticky(true);\\n\\n        this.$element.removeClass(this.options.stickyClass + ' is-anchored is-at-top').css({\\n          height: '',\\n          top: '',\\n          bottom: '',\\n          'max-width': ''\\n        }).off('resizeme.zf.trigger');\\n        if (this.$anchor && this.$anchor.length) {\\n          this.$anchor.off('change.zf.sticky');\\n        }\\n        $(window).off(this.scrollListener);\\n\\n        if (this.wasWrapped) {\\n          this.$element.unwrap();\\n        } else {\\n          this.$container.removeClass(this.options.containerClass).css({\\n            height: ''\\n          });\\n        }\\n        Foundation.unregisterPlugin(this);\\n      }\\n    }]);\\n\\n    return Sticky;\\n  }();\\n\\n  Sticky.defaults = {\\n    /**\\n     * Customizable container template. Add your own classes for styling and sizing.\\n     * @option\\n     * @example '&lt;div data-sticky-container class=\\\"small-6 columns\\\"&gt;&lt;/div&gt;'\\n     */\\n    container: '<div data-sticky-container></div>',\\n    /**\\n     * Location in the view the element sticks to.\\n     * @option\\n     * @example 'top'\\n     */\\n    stickTo: 'top',\\n    /**\\n     * If anchored to a single element, the id of that element.\\n     * @option\\n     * @example 'exampleId'\\n     */\\n    anchor: '',\\n    /**\\n     * If using more than one element as anchor points, the id of the top anchor.\\n     * @option\\n     * @example 'exampleId:top'\\n     */\\n    topAnchor: '',\\n    /**\\n     * If using more than one element as anchor points, the id of the bottom anchor.\\n     * @option\\n     * @example 'exampleId:bottom'\\n     */\\n    btmAnchor: '',\\n    /**\\n     * Margin, in `em`'s to apply to the top of the element when it becomes sticky.\\n     * @option\\n     * @example 1\\n     */\\n    marginTop: 1,\\n    /**\\n     * Margin, in `em`'s to apply to the bottom of the element when it becomes sticky.\\n     * @option\\n     * @example 1\\n     */\\n    marginBottom: 1,\\n    /**\\n     * Breakpoint string that is the minimum screen size an element should become sticky.\\n     * @option\\n     * @example 'medium'\\n     */\\n    stickyOn: 'medium',\\n    /**\\n     * Class applied to sticky element, and removed on destruction. Foundation defaults to `sticky`.\\n     * @option\\n     * @example 'sticky'\\n     */\\n    stickyClass: 'sticky',\\n    /**\\n     * Class applied to sticky container. Foundation defaults to `sticky-container`.\\n     * @option\\n     * @example 'sticky-container'\\n     */\\n    containerClass: 'sticky-container',\\n    /**\\n     * Number of scroll events between the plugin's recalculating sticky points. Setting it to `0` will cause it to recalc every scroll event, setting it to `-1` will prevent recalc on scroll.\\n     * @option\\n     * @example 50\\n     */\\n    checkEvery: -1\\n  };\\n\\n  /**\\n   * Helper function to calculate em values\\n   * @param Number {em} - number of em's to calculate into pixels\\n   */\\n  function emCalc(em) {\\n    return parseInt(window.getComputedStyle(document.body, null).fontSize, 10) * em;\\n  }\\n\\n  // Window exports\\n  Foundation.plugin(Sticky, 'Sticky');\\n}(jQuery);\\n'use strict';\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n!function ($) {\\n\\n  /**\\n   * Tabs module.\\n   * @module foundation.tabs\\n   * @requires foundation.util.keyboard\\n   * @requires foundation.util.timerAndImageLoader if tabs contain images\\n   */\\n\\n  var Tabs = function () {\\n    /**\\n     * Creates a new instance of tabs.\\n     * @class\\n     * @fires Tabs#init\\n     * @param {jQuery} element - jQuery object to make into tabs.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n\\n    function Tabs(element, options) {\\n      _classCallCheck(this, Tabs);\\n\\n      this.$element = element;\\n      this.options = $.extend({}, Tabs.defaults, this.$element.data(), options);\\n\\n      this._init();\\n      Foundation.registerPlugin(this, 'Tabs');\\n      Foundation.Keyboard.register('Tabs', {\\n        'ENTER': 'open',\\n        'SPACE': 'open',\\n        'ARROW_RIGHT': 'next',\\n        'ARROW_UP': 'previous',\\n        'ARROW_DOWN': 'next',\\n        'ARROW_LEFT': 'previous'\\n        // 'TAB': 'next',\\n        // 'SHIFT_TAB': 'previous'\\n      });\\n    }\\n\\n    /**\\n     * Initializes the tabs by showing and focusing (if autoFocus=true) the preset active tab.\\n     * @private\\n     */\\n\\n\\n    _createClass(Tabs, [{\\n      key: '_init',\\n      value: function _init() {\\n        var _this = this;\\n\\n        this.$tabTitles = this.$element.find('.' + this.options.linkClass);\\n        this.$tabContent = $('[data-tabs-content=\\\"' + this.$element[0].id + '\\\"]');\\n\\n        this.$tabTitles.each(function () {\\n          var $elem = $(this),\\n              $link = $elem.find('a'),\\n              isActive = $elem.hasClass('is-active'),\\n              hash = $link[0].hash.slice(1),\\n              linkId = $link[0].id ? $link[0].id : hash + '-label',\\n              $tabContent = $('#' + hash);\\n\\n          $elem.attr({ 'role': 'presentation' });\\n\\n          $link.attr({\\n            'role': 'tab',\\n            'aria-controls': hash,\\n            'aria-selected': isActive,\\n            'id': linkId\\n          });\\n\\n          $tabContent.attr({\\n            'role': 'tabpanel',\\n            'aria-hidden': !isActive,\\n            'aria-labelledby': linkId\\n          });\\n\\n          if (isActive && _this.options.autoFocus) {\\n            $link.focus();\\n          }\\n        });\\n\\n        if (this.options.matchHeight) {\\n          var $images = this.$tabContent.find('img');\\n\\n          if ($images.length) {\\n            Foundation.onImagesLoaded($images, this._setHeight.bind(this));\\n          } else {\\n            this._setHeight();\\n          }\\n        }\\n\\n        this._events();\\n      }\\n\\n      /**\\n       * Adds event handlers for items within the tabs.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_events',\\n      value: function _events() {\\n        this._addKeyHandler();\\n        this._addClickHandler();\\n        this._setHeightMqHandler = null;\\n\\n        if (this.options.matchHeight) {\\n          this._setHeightMqHandler = this._setHeight.bind(this);\\n\\n          $(window).on('changed.zf.mediaquery', this._setHeightMqHandler);\\n        }\\n      }\\n\\n      /**\\n       * Adds click handlers for items within the tabs.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_addClickHandler',\\n      value: function _addClickHandler() {\\n        var _this = this;\\n\\n        this.$element.off('click.zf.tabs').on('click.zf.tabs', '.' + this.options.linkClass, function (e) {\\n          e.preventDefault();\\n          e.stopPropagation();\\n          if ($(this).hasClass('is-active')) {\\n            return;\\n          }\\n          _this._handleTabChange($(this));\\n        });\\n      }\\n\\n      /**\\n       * Adds keyboard event handlers for items within the tabs.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_addKeyHandler',\\n      value: function _addKeyHandler() {\\n        var _this = this;\\n        var $firstTab = _this.$element.find('li:first-of-type');\\n        var $lastTab = _this.$element.find('li:last-of-type');\\n\\n        this.$tabTitles.off('keydown.zf.tabs').on('keydown.zf.tabs', function (e) {\\n          if (e.which === 9) return;\\n\\n          var $element = $(this),\\n              $elements = $element.parent('ul').children('li'),\\n              $prevElement,\\n              $nextElement;\\n\\n          $elements.each(function (i) {\\n            if ($(this).is($element)) {\\n              if (_this.options.wrapOnKeys) {\\n                $prevElement = i === 0 ? $elements.last() : $elements.eq(i - 1);\\n                $nextElement = i === $elements.length - 1 ? $elements.first() : $elements.eq(i + 1);\\n              } else {\\n                $prevElement = $elements.eq(Math.max(0, i - 1));\\n                $nextElement = $elements.eq(Math.min(i + 1, $elements.length - 1));\\n              }\\n              return;\\n            }\\n          });\\n\\n          // handle keyboard event with keyboard util\\n          Foundation.Keyboard.handleKey(e, 'Tabs', {\\n            open: function () {\\n              $element.find('[role=\\\"tab\\\"]').focus();\\n              _this._handleTabChange($element);\\n            },\\n            previous: function () {\\n              $prevElement.find('[role=\\\"tab\\\"]').focus();\\n              _this._handleTabChange($prevElement);\\n            },\\n            next: function () {\\n              $nextElement.find('[role=\\\"tab\\\"]').focus();\\n              _this._handleTabChange($nextElement);\\n            },\\n            handled: function () {\\n              e.stopPropagation();\\n              e.preventDefault();\\n            }\\n          });\\n        });\\n      }\\n\\n      /**\\n       * Opens the tab `$targetContent` defined by `$target`.\\n       * @param {jQuery} $target - Tab to open.\\n       * @fires Tabs#change\\n       * @function\\n       */\\n\\n    }, {\\n      key: '_handleTabChange',\\n      value: function _handleTabChange($target) {\\n        var $tabLink = $target.find('[role=\\\"tab\\\"]'),\\n            hash = $tabLink[0].hash,\\n            $targetContent = this.$tabContent.find(hash),\\n            $oldTab = this.$element.find('.' + this.options.linkClass + '.is-active').removeClass('is-active').find('[role=\\\"tab\\\"]').attr({ 'aria-selected': 'false' });\\n\\n        $('#' + $oldTab.attr('aria-controls')).removeClass('is-active').attr({ 'aria-hidden': 'true' });\\n\\n        $target.addClass('is-active');\\n\\n        $tabLink.attr({ 'aria-selected': 'true' });\\n\\n        $targetContent.addClass('is-active').attr({ 'aria-hidden': 'false' });\\n\\n        /**\\n         * Fires when the plugin has successfully changed tabs.\\n         * @event Tabs#change\\n         */\\n        this.$element.trigger('change.zf.tabs', [$target]);\\n      }\\n\\n      /**\\n       * Public method for selecting a content pane to display.\\n       * @param {jQuery | String} elem - jQuery object or string of the id of the pane to display.\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'selectTab',\\n      value: function selectTab(elem) {\\n        var idStr;\\n\\n        if (typeof elem === 'object') {\\n          idStr = elem[0].id;\\n        } else {\\n          idStr = elem;\\n        }\\n\\n        if (idStr.indexOf('#') < 0) {\\n          idStr = '#' + idStr;\\n        }\\n\\n        var $target = this.$tabTitles.find('[href=\\\"' + idStr + '\\\"]').parent('.' + this.options.linkClass);\\n\\n        this._handleTabChange($target);\\n      }\\n    }, {\\n      key: '_setHeight',\\n\\n      /**\\n       * Sets the height of each panel to the height of the tallest panel.\\n       * If enabled in options, gets called on media query change.\\n       * If loading content via external source, can be called directly or with _reflow.\\n       * @function\\n       * @private\\n       */\\n      value: function _setHeight() {\\n        var max = 0;\\n        this.$tabContent.find('.' + this.options.panelClass).css('height', '').each(function () {\\n          var panel = $(this),\\n              isActive = panel.hasClass('is-active');\\n\\n          if (!isActive) {\\n            panel.css({ 'visibility': 'hidden', 'display': 'block' });\\n          }\\n\\n          var temp = this.getBoundingClientRect().height;\\n\\n          if (!isActive) {\\n            panel.css({\\n              'visibility': '',\\n              'display': ''\\n            });\\n          }\\n\\n          max = temp > max ? temp : max;\\n        }).css('height', max + 'px');\\n      }\\n\\n      /**\\n       * Destroys an instance of an tabs.\\n       * @fires Tabs#destroyed\\n       */\\n\\n    }, {\\n      key: 'destroy',\\n      value: function destroy() {\\n        this.$element.find('.' + this.options.linkClass).off('.zf.tabs').hide().end().find('.' + this.options.panelClass).hide();\\n\\n        if (this.options.matchHeight) {\\n          if (this._setHeightMqHandler != null) {\\n            $(window).off('changed.zf.mediaquery', this._setHeightMqHandler);\\n          }\\n        }\\n\\n        Foundation.unregisterPlugin(this);\\n      }\\n    }]);\\n\\n    return Tabs;\\n  }();\\n\\n  Tabs.defaults = {\\n    /**\\n     * Allows the window to scroll to content of active pane on load if set to true.\\n     * @option\\n     * @example false\\n     */\\n    autoFocus: false,\\n\\n    /**\\n     * Allows keyboard input to 'wrap' around the tab links.\\n     * @option\\n     * @example true\\n     */\\n    wrapOnKeys: true,\\n\\n    /**\\n     * Allows the tab content panes to match heights if set to true.\\n     * @option\\n     * @example false\\n     */\\n    matchHeight: false,\\n\\n    /**\\n     * Class applied to `li`'s in tab link list.\\n     * @option\\n     * @example 'tabs-title'\\n     */\\n    linkClass: 'tabs-title',\\n\\n    /**\\n     * Class applied to the content containers.\\n     * @option\\n     * @example 'tabs-panel'\\n     */\\n    panelClass: 'tabs-panel'\\n  };\\n\\n  function checkClass($elem) {\\n    return $elem.hasClass('is-active');\\n  }\\n\\n  // Window exports\\n  Foundation.plugin(Tabs, 'Tabs');\\n}(jQuery);\\n'use strict';\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n!function ($) {\\n\\n  /**\\n   * Toggler module.\\n   * @module foundation.toggler\\n   * @requires foundation.util.motion\\n   * @requires foundation.util.triggers\\n   */\\n\\n  var Toggler = function () {\\n    /**\\n     * Creates a new instance of Toggler.\\n     * @class\\n     * @fires Toggler#init\\n     * @param {Object} element - jQuery object to add the trigger to.\\n     * @param {Object} options - Overrides to the default plugin settings.\\n     */\\n\\n    function Toggler(element, options) {\\n      _classCallCheck(this, Toggler);\\n\\n      this.$element = element;\\n      this.options = $.extend({}, Toggler.defaults, element.data(), options);\\n      this.className = '';\\n\\n      this._init();\\n      this._events();\\n\\n      Foundation.registerPlugin(this, 'Toggler');\\n    }\\n\\n    /**\\n     * Initializes the Toggler plugin by parsing the toggle class from data-toggler, or animation classes from data-animate.\\n     * @function\\n     * @private\\n     */\\n\\n\\n    _createClass(Toggler, [{\\n      key: '_init',\\n      value: function _init() {\\n        var input;\\n        // Parse animation classes if they were set\\n        if (this.options.animate) {\\n          input = this.options.animate.split(' ');\\n\\n          this.animationIn = input[0];\\n          this.animationOut = input[1] || null;\\n        }\\n        // Otherwise, parse toggle class\\n        else {\\n            input = this.$element.data('toggler');\\n            // Allow for a . at the beginning of the string\\n            this.className = input[0] === '.' ? input.slice(1) : input;\\n          }\\n\\n        // Add ARIA attributes to triggers\\n        var id = this.$element[0].id;\\n        $('[data-open=\\\"' + id + '\\\"], [data-close=\\\"' + id + '\\\"], [data-toggle=\\\"' + id + '\\\"]').attr('aria-controls', id);\\n        // If the target is hidden, add aria-hidden\\n        this.$element.attr('aria-expanded', this.$element.is(':hidden') ? false : true);\\n      }\\n\\n      /**\\n       * Initializes events for the toggle trigger.\\n       * @function\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_events',\\n      value: function _events() {\\n        this.$element.off('toggle.zf.trigger').on('toggle.zf.trigger', this.toggle.bind(this));\\n      }\\n\\n      /**\\n       * Toggles the target class on the target element. An event is fired from the original trigger depending on if the resultant state was \\\"on\\\" or \\\"off\\\".\\n       * @function\\n       * @fires Toggler#on\\n       * @fires Toggler#off\\n       */\\n\\n    }, {\\n      key: 'toggle',\\n      value: function toggle() {\\n        this[this.options.animate ? '_toggleAnimate' : '_toggleClass']();\\n      }\\n    }, {\\n      key: '_toggleClass',\\n      value: function _toggleClass() {\\n        this.$element.toggleClass(this.className);\\n\\n        var isOn = this.$element.hasClass(this.className);\\n        if (isOn) {\\n          /**\\n           * Fires if the target element has the class after a toggle.\\n           * @event Toggler#on\\n           */\\n          this.$element.trigger('on.zf.toggler');\\n        } else {\\n          /**\\n           * Fires if the target element does not have the class after a toggle.\\n           * @event Toggler#off\\n           */\\n          this.$element.trigger('off.zf.toggler');\\n        }\\n\\n        this._updateARIA(isOn);\\n      }\\n    }, {\\n      key: '_toggleAnimate',\\n      value: function _toggleAnimate() {\\n        var _this = this;\\n\\n        if (this.$element.is(':hidden')) {\\n          Foundation.Motion.animateIn(this.$element, this.animationIn, function () {\\n            _this._updateARIA(true);\\n            this.trigger('on.zf.toggler');\\n          });\\n        } else {\\n          Foundation.Motion.animateOut(this.$element, this.animationOut, function () {\\n            _this._updateARIA(false);\\n            this.trigger('off.zf.toggler');\\n          });\\n        }\\n      }\\n    }, {\\n      key: '_updateARIA',\\n      value: function _updateARIA(isOn) {\\n        this.$element.attr('aria-expanded', isOn ? true : false);\\n      }\\n\\n      /**\\n       * Destroys the instance of Toggler on the element.\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'destroy',\\n      value: function destroy() {\\n        this.$element.off('.zf.toggler');\\n        Foundation.unregisterPlugin(this);\\n      }\\n    }]);\\n\\n    return Toggler;\\n  }();\\n\\n  Toggler.defaults = {\\n    /**\\n     * Tells the plugin if the element should animated when toggled.\\n     * @option\\n     * @example false\\n     */\\n    animate: false\\n  };\\n\\n  // Window exports\\n  Foundation.plugin(Toggler, 'Toggler');\\n}(jQuery);\\n'use strict';\\n\\nvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\\\"value\\\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\\n\\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\\\"Cannot call a class as a function\\\"); } }\\n\\n!function ($) {\\n\\n  /**\\n   * Tooltip module.\\n   * @module foundation.tooltip\\n   * @requires foundation.util.box\\n   * @requires foundation.util.triggers\\n   */\\n\\n  var Tooltip = function () {\\n    /**\\n     * Creates a new instance of a Tooltip.\\n     * @class\\n     * @fires Tooltip#init\\n     * @param {jQuery} element - jQuery object to attach a tooltip to.\\n     * @param {Object} options - object to extend the default configuration.\\n     */\\n\\n    function Tooltip(element, options) {\\n      _classCallCheck(this, Tooltip);\\n\\n      this.$element = element;\\n      this.options = $.extend({}, Tooltip.defaults, this.$element.data(), options);\\n\\n      this.isActive = false;\\n      this.isClick = false;\\n      this._init();\\n\\n      Foundation.registerPlugin(this, 'Tooltip');\\n    }\\n\\n    /**\\n     * Initializes the tooltip by setting the creating the tip element, adding it's text, setting private variables and setting attributes on the anchor.\\n     * @private\\n     */\\n\\n\\n    _createClass(Tooltip, [{\\n      key: '_init',\\n      value: function _init() {\\n        var elemId = this.$element.attr('aria-describedby') || Foundation.GetYoDigits(6, 'tooltip');\\n\\n        this.options.positionClass = this.options.positionClass || this._getPositionClass(this.$element);\\n        this.options.tipText = this.options.tipText || this.$element.attr('title');\\n        this.template = this.options.template ? $(this.options.template) : this._buildTemplate(elemId);\\n\\n        this.template.appendTo(document.body).text(this.options.tipText).hide();\\n\\n        this.$element.attr({\\n          'title': '',\\n          'aria-describedby': elemId,\\n          'data-yeti-box': elemId,\\n          'data-toggle': elemId,\\n          'data-resize': elemId\\n        }).addClass(this.triggerClass);\\n\\n        //helper variables to track movement on collisions\\n        this.usedPositions = [];\\n        this.counter = 4;\\n        this.classChanged = false;\\n\\n        this._events();\\n      }\\n\\n      /**\\n       * Grabs the current positioning class, if present, and returns the value or an empty string.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_getPositionClass',\\n      value: function _getPositionClass(element) {\\n        if (!element) {\\n          return '';\\n        }\\n        // var position = element.attr('class').match(/top|left|right/g);\\n        var position = element[0].className.match(/\\\\b(top|left|right)\\\\b/g);\\n        position = position ? position[0] : '';\\n        return position;\\n      }\\n    }, {\\n      key: '_buildTemplate',\\n\\n      /**\\n       * builds the tooltip element, adds attributes, and returns the template.\\n       * @private\\n       */\\n      value: function _buildTemplate(id) {\\n        var templateClasses = (this.options.tooltipClass + ' ' + this.options.positionClass + ' ' + this.options.templateClasses).trim();\\n        var $template = $('<div></div>').addClass(templateClasses).attr({\\n          'role': 'tooltip',\\n          'aria-hidden': true,\\n          'data-is-active': false,\\n          'data-is-focus': false,\\n          'id': id\\n        });\\n        return $template;\\n      }\\n\\n      /**\\n       * Function that gets called if a collision event is detected.\\n       * @param {String} position - positioning class to try\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_reposition',\\n      value: function _reposition(position) {\\n        this.usedPositions.push(position ? position : 'bottom');\\n\\n        //default, try switching to opposite side\\n        if (!position && this.usedPositions.indexOf('top') < 0) {\\n          this.template.addClass('top');\\n        } else if (position === 'top' && this.usedPositions.indexOf('bottom') < 0) {\\n          this.template.removeClass(position);\\n        } else if (position === 'left' && this.usedPositions.indexOf('right') < 0) {\\n          this.template.removeClass(position).addClass('right');\\n        } else if (position === 'right' && this.usedPositions.indexOf('left') < 0) {\\n          this.template.removeClass(position).addClass('left');\\n        }\\n\\n        //if default change didn't work, try bottom or left first\\n        else if (!position && this.usedPositions.indexOf('top') > -1 && this.usedPositions.indexOf('left') < 0) {\\n            this.template.addClass('left');\\n          } else if (position === 'top' && this.usedPositions.indexOf('bottom') > -1 && this.usedPositions.indexOf('left') < 0) {\\n            this.template.removeClass(position).addClass('left');\\n          } else if (position === 'left' && this.usedPositions.indexOf('right') > -1 && this.usedPositions.indexOf('bottom') < 0) {\\n            this.template.removeClass(position);\\n          } else if (position === 'right' && this.usedPositions.indexOf('left') > -1 && this.usedPositions.indexOf('bottom') < 0) {\\n            this.template.removeClass(position);\\n          }\\n          //if nothing cleared, set to bottom\\n          else {\\n              this.template.removeClass(position);\\n            }\\n        this.classChanged = true;\\n        this.counter--;\\n      }\\n\\n      /**\\n       * sets the position class of an element and recursively calls itself until there are no more possible positions to attempt, or the tooltip element is no longer colliding.\\n       * if the tooltip is larger than the screen width, default to full width - any user selected margin\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_setPosition',\\n      value: function _setPosition() {\\n        var position = this._getPositionClass(this.template),\\n            $tipDims = Foundation.Box.GetDimensions(this.template),\\n            $anchorDims = Foundation.Box.GetDimensions(this.$element),\\n            direction = position === 'left' ? 'left' : position === 'right' ? 'left' : 'top',\\n            param = direction === 'top' ? 'height' : 'width',\\n            offset = param === 'height' ? this.options.vOffset : this.options.hOffset,\\n            _this = this;\\n\\n        if ($tipDims.width >= $tipDims.windowDims.width || !this.counter && !Foundation.Box.ImNotTouchingYou(this.template)) {\\n          this.template.offset(Foundation.Box.GetOffsets(this.template, this.$element, 'center bottom', this.options.vOffset, this.options.hOffset, true)).css({\\n            // this.$element.offset(Foundation.GetOffsets(this.template, this.$element, 'center bottom', this.options.vOffset, this.options.hOffset, true)).css({\\n            'width': $anchorDims.windowDims.width - this.options.hOffset * 2,\\n            'height': 'auto'\\n          });\\n          return false;\\n        }\\n\\n        this.template.offset(Foundation.Box.GetOffsets(this.template, this.$element, 'center ' + (position || 'bottom'), this.options.vOffset, this.options.hOffset));\\n\\n        while (!Foundation.Box.ImNotTouchingYou(this.template) && this.counter) {\\n          this._reposition(position);\\n          this._setPosition();\\n        }\\n      }\\n\\n      /**\\n       * reveals the tooltip, and fires an event to close any other open tooltips on the page\\n       * @fires Tooltip#closeme\\n       * @fires Tooltip#show\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'show',\\n      value: function show() {\\n        if (this.options.showOn !== 'all' && !Foundation.MediaQuery.atLeast(this.options.showOn)) {\\n          // console.error('The screen is too small to display this tooltip');\\n          return false;\\n        }\\n\\n        var _this = this;\\n        this.template.css('visibility', 'hidden').show();\\n        this._setPosition();\\n\\n        /**\\n         * Fires to close all other open tooltips on the page\\n         * @event Closeme#tooltip\\n         */\\n        this.$element.trigger('closeme.zf.tooltip', this.template.attr('id'));\\n\\n        this.template.attr({\\n          'data-is-active': true,\\n          'aria-hidden': false\\n        });\\n        _this.isActive = true;\\n        // console.log(this.template);\\n        this.template.stop().hide().css('visibility', '').fadeIn(this.options.fadeInDuration, function () {\\n          //maybe do stuff?\\n        });\\n        /**\\n         * Fires when the tooltip is shown\\n         * @event Tooltip#show\\n         */\\n        this.$element.trigger('show.zf.tooltip');\\n      }\\n\\n      /**\\n       * Hides the current tooltip, and resets the positioning class if it was changed due to collision\\n       * @fires Tooltip#hide\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'hide',\\n      value: function hide() {\\n        // console.log('hiding', this.$element.data('yeti-box'));\\n        var _this = this;\\n        this.template.stop().attr({\\n          'aria-hidden': true,\\n          'data-is-active': false\\n        }).fadeOut(this.options.fadeOutDuration, function () {\\n          _this.isActive = false;\\n          _this.isClick = false;\\n          if (_this.classChanged) {\\n            _this.template.removeClass(_this._getPositionClass(_this.template)).addClass(_this.options.positionClass);\\n\\n            _this.usedPositions = [];\\n            _this.counter = 4;\\n            _this.classChanged = false;\\n          }\\n        });\\n        /**\\n         * fires when the tooltip is hidden\\n         * @event Tooltip#hide\\n         */\\n        this.$element.trigger('hide.zf.tooltip');\\n      }\\n\\n      /**\\n       * adds event listeners for the tooltip and its anchor\\n       * TODO combine some of the listeners like focus and mouseenter, etc.\\n       * @private\\n       */\\n\\n    }, {\\n      key: '_events',\\n      value: function _events() {\\n        var _this = this;\\n        var $template = this.template;\\n        var isFocus = false;\\n\\n        if (!this.options.disableHover) {\\n\\n          this.$element.on('mouseenter.zf.tooltip', function (e) {\\n            if (!_this.isActive) {\\n              _this.timeout = setTimeout(function () {\\n                _this.show();\\n              }, _this.options.hoverDelay);\\n            }\\n          }).on('mouseleave.zf.tooltip', function (e) {\\n            clearTimeout(_this.timeout);\\n            if (!isFocus || _this.isClick && !_this.options.clickOpen) {\\n              _this.hide();\\n            }\\n          });\\n        }\\n\\n        if (this.options.clickOpen) {\\n          this.$element.on('mousedown.zf.tooltip', function (e) {\\n            e.stopImmediatePropagation();\\n            if (_this.isClick) {\\n              //_this.hide();\\n              // _this.isClick = false;\\n            } else {\\n                _this.isClick = true;\\n                if ((_this.options.disableHover || !_this.$element.attr('tabindex')) && !_this.isActive) {\\n                  _this.show();\\n                }\\n              }\\n          });\\n        } else {\\n          this.$element.on('mousedown.zf.tooltip', function (e) {\\n            e.stopImmediatePropagation();\\n            _this.isClick = true;\\n          });\\n        }\\n\\n        if (!this.options.disableForTouch) {\\n          this.$element.on('tap.zf.tooltip touchend.zf.tooltip', function (e) {\\n            _this.isActive ? _this.hide() : _this.show();\\n          });\\n        }\\n\\n        this.$element.on({\\n          // 'toggle.zf.trigger': this.toggle.bind(this),\\n          // 'close.zf.trigger': this.hide.bind(this)\\n          'close.zf.trigger': this.hide.bind(this)\\n        });\\n\\n        this.$element.on('focus.zf.tooltip', function (e) {\\n          isFocus = true;\\n          if (_this.isClick) {\\n            // If we're not showing open on clicks, we need to pretend a click-launched focus isn't\\n            // a real focus, otherwise on hover and come back we get bad behavior\\n            if (!_this.options.clickOpen) {\\n              isFocus = false;\\n            }\\n            return false;\\n          } else {\\n            _this.show();\\n          }\\n        }).on('focusout.zf.tooltip', function (e) {\\n          isFocus = false;\\n          _this.isClick = false;\\n          _this.hide();\\n        }).on('resizeme.zf.trigger', function () {\\n          if (_this.isActive) {\\n            _this._setPosition();\\n          }\\n        });\\n      }\\n\\n      /**\\n       * adds a toggle method, in addition to the static show() & hide() functions\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'toggle',\\n      value: function toggle() {\\n        if (this.isActive) {\\n          this.hide();\\n        } else {\\n          this.show();\\n        }\\n      }\\n\\n      /**\\n       * Destroys an instance of tooltip, removes template element from the view.\\n       * @function\\n       */\\n\\n    }, {\\n      key: 'destroy',\\n      value: function destroy() {\\n        this.$element.attr('title', this.template.text()).off('.zf.trigger .zf.tootip')\\n        //  .removeClass('has-tip')\\n        .removeAttr('aria-describedby').removeAttr('data-yeti-box').removeAttr('data-toggle').removeAttr('data-resize');\\n\\n        this.template.remove();\\n\\n        Foundation.unregisterPlugin(this);\\n      }\\n    }]);\\n\\n    return Tooltip;\\n  }();\\n\\n  Tooltip.defaults = {\\n    disableForTouch: false,\\n    /**\\n     * Time, in ms, before a tooltip should open on hover.\\n     * @option\\n     * @example 200\\n     */\\n    hoverDelay: 200,\\n    /**\\n     * Time, in ms, a tooltip should take to fade into view.\\n     * @option\\n     * @example 150\\n     */\\n    fadeInDuration: 150,\\n    /**\\n     * Time, in ms, a tooltip should take to fade out of view.\\n     * @option\\n     * @example 150\\n     */\\n    fadeOutDuration: 150,\\n    /**\\n     * Disables hover events from opening the tooltip if set to true\\n     * @option\\n     * @example false\\n     */\\n    disableHover: false,\\n    /**\\n     * Optional addtional classes to apply to the tooltip template on init.\\n     * @option\\n     * @example 'my-cool-tip-class'\\n     */\\n    templateClasses: '',\\n    /**\\n     * Non-optional class added to tooltip templates. Foundation default is 'tooltip'.\\n     * @option\\n     * @example 'tooltip'\\n     */\\n    tooltipClass: 'tooltip',\\n    /**\\n     * Class applied to the tooltip anchor element.\\n     * @option\\n     * @example 'has-tip'\\n     */\\n    triggerClass: 'has-tip',\\n    /**\\n     * Minimum breakpoint size at which to open the tooltip.\\n     * @option\\n     * @example 'small'\\n     */\\n    showOn: 'small',\\n    /**\\n     * Custom template to be used to generate markup for tooltip.\\n     * @option\\n     * @example '&lt;div class=\\\"tooltip\\\"&gt;&lt;/div&gt;'\\n     */\\n    template: '',\\n    /**\\n     * Text displayed in the tooltip template on open.\\n     * @option\\n     * @example 'Some cool space fact here.'\\n     */\\n    tipText: '',\\n    touchCloseText: 'Tap to close.',\\n    /**\\n     * Allows the tooltip to remain open if triggered with a click or touch event.\\n     * @option\\n     * @example true\\n     */\\n    clickOpen: true,\\n    /**\\n     * Additional positioning classes, set by the JS\\n     * @option\\n     * @example 'top'\\n     */\\n    positionClass: '',\\n    /**\\n     * Distance, in pixels, the template should push away from the anchor on the Y axis.\\n     * @option\\n     * @example 10\\n     */\\n    vOffset: 10,\\n    /**\\n     * Distance, in pixels, the template should push away from the anchor on the X axis, if aligned to a side.\\n     * @option\\n     * @example 12\\n     */\\n    hOffset: 12\\n  };\\n\\n  /**\\n   * TODO utilize resize event trigger\\n   */\\n\\n  // Window exports\\n  Foundation.plugin(Tooltip, 'Tooltip');\\n}(jQuery);\\n\"\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9mb3VuZGF0aW9uLmpzPzdjZGEiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsaUNBQWlDLHFCQUFxQix1Q0FBdUMsb0lBQW9JLDRHQUE0RyxxTEFBcUwsK0NBQStDLE9BQU8sOEpBQThKLE9BQU8sd0ZBQXdGLHFMQUFxTCxvTkFBb04seUlBQXlJLE9BQU8sbVdBQW1XLE9BQU8sOEVBQThFLE9BQU8saUpBQWlKLGlHQUFpRyxzREFBc0QsNERBQTRELGtFQUFrRSxTQUFTLGdEQUFnRCxtREFBbUQsU0FBUyw2SkFBNkosd0NBQXdDLGlCQUFpQixPQUFPLG1SQUFtUixPQUFPLGlKQUFpSiwrRkFBK0Ysa0VBQWtFLDBPQUEwTyxrQ0FBa0MsOEJBQThCLDJEQUEyRCxlQUFlLE9BQU8sb0tBQW9LLE9BQU8scVJBQXFSLHdDQUF3QyxhQUFhLHFCQUFxQixzQ0FBc0MsK0NBQStDLGFBQWEsRUFBRSxXQUFXLE9BQU8sMEZBQTBGLHlDQUF5QywyQ0FBMkMsbUNBQW1DLDREQUE0RCxpQkFBaUIsRUFBRSxlQUFlLHNDQUFzQyw2Q0FBNkMsZ0VBQWdFLGVBQWUseUNBQXlDLDREQUE0RCxlQUFlLGNBQWMsK0JBQStCLFdBQVcsU0FBUyxjQUFjLDZCQUE2QixTQUFTLFVBQVUseUJBQXlCLFNBQVMsT0FBTyxxR0FBcUcsT0FBTyxxR0FBcUcsT0FBTyxtRkFBbUYsT0FBTyx1RkFBdUYsT0FBTyxzRUFBc0UsNkJBQTZCLHNKQUFzSixPQUFPLHlJQUF5SSxPQUFPLGlKQUFpSixhQUFhLHFJQUFxSSx1R0FBdUcsK0NBQStDLFNBQVMsc0hBQXNILGdDQUFnQyxXQUFXLDJCQUEyQixvRkFBb0YsK0VBQStFLHlNQUF5TSxxRkFBcUYsd0RBQXdELGlGQUFpRix1SEFBdUgscUJBQXFCLGFBQWEsNkNBQTZDLDJEQUEyRCw0QkFBNEIsMERBQTBELG1DQUFtQyxpQkFBaUIsRUFBRSw4REFBOEQsZUFBZSxFQUFFLGFBQWEs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V0FBVyxFQUFFLDBKQUEwSixTQUFTLCtMQUErTCxHQUFHLDBEQUEwRCwyQkFBMkIsd0NBQXdDLDhCQUE4Qiw2Q0FBNkMsc0VBQXNFLG9DQUFvQyx3REFBd0QsK0JBQStCLGlCQUFpQiw0QkFBNEIsZUFBZSxhQUFhLDRDQUE0QywwQ0FBMEMsMEVBQTBFLDZCQUE2QixlQUFlLGFBQWEsRUFBRSxXQUFXLHlDQUF5QyxtRUFBbUUsMkNBQTJDLGtDQUFrQywrQkFBK0IseUNBQXlDLGVBQWUsT0FBTyx1Q0FBdUMsNEdBQTRHLGlDQUFpQyxtQkFBbUIsaUJBQWlCLGFBQWEsRUFBRSxXQUFXLE9BQU8sbUVBQW1FLDJDQUEyQyxtQ0FBbUMsYUFBYSxFQUFFLFdBQVcsZ0RBQWdELGlGQUFpRiwyREFBMkQsYUFBYSxFQUFFLFdBQVcsOEJBQThCLGlMQUFpTCxFQUFFLCtEQUErRCwyQkFBMkIsZ0NBQWdDLHFPQUFxTyxnQ0FBZ0MsZUFBZSwyQkFBMkIsYUFBYSxPQUFPLDJCQUEyQixhQUFhLFdBQVcsMENBQTBDLDRCQUE0QixrQ0FBa0MseUJBQXlCLFdBQVcseUNBQXlDLGlDQUFpQyxtQ0FBbUMsYUFBYSxXQUFXLEVBQUUsU0FBUyx5SUFBeUksR0FBRyx3REFBd0QsOEJBQThCLHdCQUF3QixXQUFXLE9BQU8sd0JBQXdCLFdBQVcsU0FBUyx3SUFBd0ksR0FBRywwREFBMEQsd1BBQXdQLG1DQUFtQyw4Q0FBOEMsU0FBUyxPQUFPLEdBQUcsdUJBQXVCLEtBQUssR0FBRywwQkFBMEIsbTFDQUFtMUMseUJBQXlCLElBQUksUUFBUSxxMkJBQXEyQix5SEFBeUgsR0FBRyxTQUFTIiwiZmlsZSI6IjUuanMiLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IFwiIWZ1bmN0aW9uICgkKSB7XFxuXFxuICBcXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuICB2YXIgRk9VTkRBVElPTl9WRVJTSU9OID0gJzYuMi4zJztcXG5cXG4gIC8vIEdsb2JhbCBGb3VuZGF0aW9uIG9iamVjdFxcbiAgLy8gVGhpcyBpcyBhdHRhY2hlZCB0byB0aGUgd2luZG93LCBvciB1c2VkIGFzIGEgbW9kdWxlIGZvciBBTUQvQnJvd3NlcmlmeVxcbiAgdmFyIEZvdW5kYXRpb24gPSB7XFxuICAgIHZlcnNpb246IEZPVU5EQVRJT05fVkVSU0lPTixcXG5cXG4gICAgLyoqXFxuICAgICAqIFN0b3JlcyBpbml0aWFsaXplZCBwbHVnaW5zLlxcbiAgICAgKi9cXG4gICAgX3BsdWdpbnM6IHt9LFxcblxcbiAgICAvKipcXG4gICAgICogU3RvcmVzIGdlbmVyYXRlZCB1bmlxdWUgaWRzIGZvciBwbHVnaW4gaW5zdGFuY2VzXFxuICAgICAqL1xcbiAgICBfdXVpZHM6IFtdLFxcblxcbiAgICAvKipcXG4gICAgICogUmV0dXJucyBhIGJvb2xlYW4gZm9yIFJUTCBzdXBwb3J0XFxuICAgICAqL1xcbiAgICBydGw6IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gJCgnaHRtbCcpLmF0dHIoJ2RpcicpID09PSAncnRsJztcXG4gICAgfSxcXG4gICAgLyoqXFxuICAgICAqIERlZmluZXMgYSBGb3VuZGF0aW9uIHBsdWdpbiwgYWRkaW5nIGl0IHRvIHRoZSBgRm91bmRhdGlvbmAgbmFtZXNwYWNlIGFuZCB0aGUgbGlzdCBvZiBwbHVnaW5zIHRvIGluaXRpYWxpemUgd2hlbiByZWZsb3dpbmcuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gLSBUaGUgY29uc3RydWN0b3Igb2YgdGhlIHBsdWdpbi5cXG4gICAgICovXFxuICAgIHBsdWdpbjogZnVuY3Rpb24gKHBsdWdpbiwgbmFtZSkge1xcbiAgICAgIC8vIE9iamVjdCBrZXkgdG8gdXNlIHdoZW4gYWRkaW5nIHRvIGdsb2JhbCBGb3VuZGF0aW9uIG9iamVjdFxcbiAgICAgIC8vIEV4YW1wbGVzOiBGb3VuZGF0aW9uLlJldmVhbCwgRm91bmRhdGlvbi5PZmZDYW52YXNcXG4gICAgICB2YXIgY2xhc3NOYW1lID0gbmFtZSB8fCBmdW5jdGlvbk5hbWUocGx1Z2luKTtcXG4gICAgICAvLyBPYmplY3Qga2V5IHRvIHVzZSB3aGVuIHN0b3JpbmcgdGhlIHBsdWdpbiwgYWxzbyB1c2VkIHRvIGNyZWF0ZSB0aGUgaWRlbnRpZnlpbmcgZGF0YSBhdHRyaWJ1dGUgZm9yIHRoZSBwbHVnaW5cXG4gICAgICAvLyBFeGFtcGxlczogZGF0YS1yZXZlYWwsIGRhdGEtb2ZmLWNhbnZhc1xcbiAgICAgIHZhciBhdHRyTmFtZSA9IGh5cGhlbmF0ZShjbGFzc05hbWUpO1xcblxcbiAgICAgIC8vIEFkZCB0byB0aGUgRm91bmRhdGlvbiBvYmplY3QgYW5kIHRoZSBwbHVnaW5zIGxpc3QgKGZvciByZWZsb3dpbmcpXFxuICAgICAgdGhpcy5fcGx1Z2luc1thdHRyTmFtZV0gPSB0aGlzW2NsYXNzTmFtZV0gPSBwbHVnaW47XFxuICAgIH0sXFxuICAgIC8qKlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogUG9wdWxhdGVzIHRoZSBfdXVpZHMgYXJyYXkgd2l0aCBwb2ludGVycyB0byBlYWNoIGluZGl2aWR1YWwgcGx1Z2luIGluc3RhbmNlLlxcbiAgICAgKiBBZGRzIHRoZSBgemZQbHVnaW5gIGRhdGEtYXR0cmlidXRlIHRvIHByb2dyYW1tYXRpY2FsbHkgY3JlYXRlZCBwbHVnaW5zIHRvIGFsbG93IHVzZSBvZiAkKHNlbGVjdG9yKS5mb3VuZGF0aW9uKG1ldGhvZCkgY2FsbHMuXFxuICAgICAqIEFsc28gZmlyZXMgdGhlIGluaXRpYWxpemF0aW9uIGV2ZW50IGZvciBlYWNoIHBsdWdpbiwgY29uc29saWRhdGluZyByZXBldGl0aXZlIGNvZGUuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwbHVnaW4gLSBhbiBpbnN0YW5jZSBvZiBhIHBsdWdpbiwgdXN1YWxseSBgdGhpc2AgaW4gY29udGV4dC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSB0aGUgbmFtZSBvZiB0aGUgcGx1Z2luLCBwYXNzZWQgYXMgYSBjYW1lbENhc2VkIHN0cmluZy5cXG4gICAgICogQGZpcmVzIFBsdWdpbiNpbml0XFxuICAgICAqL1xcbiAgICByZWdpc3RlclBsdWdpbjogZnVuY3Rpb24gKHBsdWdpbiwgbmFtZSkge1xcbiAgICAgIHZhciBwbHVnaW5OYW1lID0gbmFtZSA/IGh5cGhlbmF0ZShuYW1lKSA6IGZ1bmN0aW9uTmFtZShwbHVnaW4uY29uc3RydWN0b3IpLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgcGx1Z2luLnV1aWQgPSB0aGlzLkdldFlvRGlnaXRzKDYsIHBsdWdpbk5hbWUpO1xcblxcbiAgICAgIGlmICghcGx1Z2luLiRlbGVtZW50LmF0dHIoJ2RhdGEtJyArIHBsdWdpbk5hbWUpKSB7XFxuICAgICAgICBwbHVnaW4uJGVsZW1lbnQuYXR0cignZGF0YS0nICsgcGx1Z2luTmFtZSwgcGx1Z2luLnV1aWQpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoIXBsdWdpbi4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicpKSB7XFxuICAgICAgICBwbHVnaW4uJGVsZW1lbnQuZGF0YSgnemZQbHVnaW4nLCBwbHVnaW4pO1xcbiAgICAgIH1cXG4gICAgICAvKipcXG4gICAgICAgKiBGaXJlcyB3aGVuIHRoZSBwbHVnaW4gaGFzIGluaXRpYWxpemVkLlxcbiAgICAgICAqIEBldmVudCBQbHVnaW4jaW5pdFxcbiAgICAgICAqL1xcbiAgICAgIHBsdWdpbi4kZWxlbWVudC50cmlnZ2VyKCdpbml0LnpmLicgKyBwbHVnaW5OYW1lKTtcXG5cXG4gICAgICB0aGlzLl91dWlkcy5wdXNoKHBsdWdpbi51dWlkKTtcXG5cXG4gICAgICByZXR1cm47XFxuICAgIH0sXFxuICAgIC8qKlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogUmVtb3ZlcyB0aGUgcGx1Z2lucyB1dWlkIGZyb20gdGhlIF91dWlkcyBhcnJheS5cXG4gICAgICogUmVtb3ZlcyB0aGUgemZQbHVnaW4gZGF0YSBhdHRyaWJ1dGUsIGFzIHdlbGwgYXMgdGhlIGRhdGEtcGx1Z2luLW5hbWUgYXR0cmlidXRlLlxcbiAgICAgKiBBbHNvIGZpcmVzIHRoZSBkZXN0cm95ZWQgZXZlbnQgZm9yIHRoZSBwbHVnaW4sIGNvbnNvbGlkYXRpbmcgcmVwZXRpdGl2ZSBjb2RlLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGx1Z2luIC0gYW4gaW5zdGFuY2Ugb2YgYSBwbHVnaW4sIHVzdWFsbHkgYHRoaXNgIGluIGNvbnRleHQuXFxuICAgICAqIEBmaXJlcyBQbHVnaW4jZGVzdHJveWVkXFxuICAgICAqL1xcbiAgICB1bnJlZ2lzdGVyUGx1Z2luOiBmdW5jdGlvbiAocGx1Z2luKSB7XFxuICAgICAgdmFyIHBsdWdpbk5hbWUgPSBoeXBoZW5hdGUoZnVuY3Rpb25OYW1lKHBsdWdpbi4kZWxlbWVudC5kYXRhKCd6ZlBsdWdpbicpLmNvbnN0cnVjdG9yKSk7XFxuXFxuICAgICAgdGhpcy5fdXVpZHMuc3BsaWNlKHRoaXMuX3V1aWRzLmluZGV4T2YocGx1Z2luLnV1aWQpLCAxKTtcXG4gICAgICBwbHVnaW4uJGVsZW1lbnQucmVtb3ZlQXR0cignZGF0YS0nICsgcGx1Z2luTmFtZSkucmVtb3ZlRGF0YSgnemZQbHVnaW4nKVxcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgYmVlbiBkZXN0cm95ZWQuXFxuICAgICAgICogQGV2ZW50IFBsdWdpbiNkZXN0cm95ZWRcXG4gICAgICAgKi9cXG4gICAgICAudHJpZ2dlcignZGVzdHJveWVkLnpmLicgKyBwbHVnaW5OYW1lKTtcXG4gICAgICBmb3IgKHZhciBwcm9wIGluIHBsdWdpbikge1xcbiAgICAgICAgcGx1Z2luW3Byb3BdID0gbnVsbDsgLy9jbGVhbiB1cCBzY3JpcHQgdG8gcHJlcCBmb3IgZ2FyYmFnZSBjb2xsZWN0aW9uLlxcbiAgICAgIH1cXG4gICAgICByZXR1cm47XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQ2F1c2VzIG9uZSBvciBtb3JlIGFjdGl2ZSBwbHVnaW5zIHRvIHJlLWluaXRpYWxpemUsIHJlc2V0dGluZyBldmVudCBsaXN0ZW5lcnMsIHJlY2FsY3VsYXRpbmcgcG9zaXRpb25zLCBldGMuXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwbHVnaW5zIC0gb3B0aW9uYWwgc3RyaW5nIG9mIGFuIGluZGl2aWR1YWwgcGx1Z2luIGtleSwgYXR0YWluZWQgYnkgY2FsbGluZyBgJChlbGVtZW50KS5kYXRhKCdwbHVnaW5OYW1lJylgLCBvciBzdHJpbmcgb2YgYSBwbHVnaW4gY2xhc3MgaS5lLiBgJ2Ryb3Bkb3duJ2BcXG4gICAgICogQGRlZmF1bHQgSWYgbm8gYXJndW1lbnQgaXMgcGFzc2VkLCByZWZsb3cgYWxsIGN1cnJlbnRseSBhY3RpdmUgcGx1Z2lucy5cXG4gICAgICovXFxuICAgIHJlSW5pdDogZnVuY3Rpb24gKHBsdWdpbnMpIHtcXG4gICAgICB2YXIgaXNKUSA9IHBsdWdpbnMgaW5zdGFuY2VvZiAkO1xcbiAgICAgIHRyeSB7XFxuICAgICAgICBpZiAoaXNKUSkge1xcbiAgICAgICAgICBwbHVnaW5zLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICQodGhpcykuZGF0YSgnemZQbHVnaW4nKS5faW5pdCgpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHZhciB0eXBlID0gdHlwZW9mIHBsdWdpbnMsXFxuICAgICAgICAgICAgICBfdGhpcyA9IHRoaXMsXFxuICAgICAgICAgICAgICBmbnMgPSB7XFxuICAgICAgICAgICAgJ29iamVjdCc6IGZ1bmN0aW9uIChwbGdzKSB7XFxuICAgICAgICAgICAgICBwbGdzLmZvckVhY2goZnVuY3Rpb24gKHApIHtcXG4gICAgICAgICAgICAgICAgcCA9IGh5cGhlbmF0ZShwKTtcXG4gICAgICAgICAgICAgICAgJCgnW2RhdGEtJyArIHAgKyAnXScpLmZvdW5kYXRpb24oJ19pbml0Jyk7XFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICdzdHJpbmcnOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBwbHVnaW5zID0gaHlwaGVuYXRlKHBsdWdpbnMpO1xcbiAgICAgICAgICAgICAgJCgnW2RhdGEtJyArIHBsdWdpbnMgKyAnXScpLmZvdW5kYXRpb24oJ19pbml0Jyk7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAndW5kZWZpbmVkJzogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgdGhpc1snb2JqZWN0J10oT2JqZWN0LmtleXMoX3RoaXMuX3BsdWdpbnMpKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH07XFxuICAgICAgICAgIGZuc1t0eXBlXShwbHVnaW5zKTtcXG4gICAgICAgIH1cXG4gICAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcXG4gICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgcmV0dXJuIHBsdWdpbnM7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogcmV0dXJucyBhIHJhbmRvbSBiYXNlLTM2IHVpZCB3aXRoIG5hbWVzcGFjaW5nXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIC0gbnVtYmVyIG9mIHJhbmRvbSBiYXNlLTM2IGRpZ2l0cyBkZXNpcmVkLiBJbmNyZWFzZSBmb3IgbW9yZSByYW5kb20gc3RyaW5ncy5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSAtIG5hbWUgb2YgcGx1Z2luIHRvIGJlIGluY29ycG9yYXRlZCBpbiB1aWQsIG9wdGlvbmFsLlxcbiAgICAgKiBAZGVmYXVsdCB7U3RyaW5nfSAnJyAtIGlmIG5vIHBsdWdpbiBuYW1lIGlzIHByb3ZpZGVkLCBub3RoaW5nIGlzIGFwcGVuZGVkIHRvIHRoZSB1aWQuXFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IC0gdW5pcXVlIGlkXFxuICAgICAqL1xcbiAgICBHZXRZb0RpZ2l0czogZnVuY3Rpb24gKGxlbmd0aCwgbmFtZXNwYWNlKSB7XFxuICAgICAgbGVuZ3RoID0gbGVuZ3RoIHx8IDY7XFxuICAgICAgcmV0dXJuIE1hdGgucm91bmQoTWF0aC5wb3coMzYsIGxlbmd0aCArIDEpIC0gTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDM2LCBsZW5ndGgpKS50b1N0cmluZygzNikuc2xpY2UoMSkgKyAobmFtZXNwYWNlID8gJy0nICsgbmFtZXNwYWNlIDogJycpO1xcbiAgICB9LFxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZSBwbHVnaW5zIG9uIGFueSBlbGVtZW50cyB3aXRoaW4gYGVsZW1gIChhbmQgYGVsZW1gIGl0c2VsZikgdGhhdCBhcmVuJ3QgYWxyZWFkeSBpbml0aWFsaXplZC5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW0gLSBqUXVlcnkgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGVsZW1lbnQgdG8gY2hlY2sgaW5zaWRlLiBBbHNvIGNoZWNrcyB0aGUgZWxlbWVudCBpdHNlbGYsIHVubGVzcyBpdCdzIHRoZSBgZG9jdW1lbnRgIG9iamVjdC5cXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHBsdWdpbnMgLSBBIGxpc3Qgb2YgcGx1Z2lucyB0byBpbml0aWFsaXplLiBMZWF2ZSB0aGlzIG91dCB0byBpbml0aWFsaXplIGV2ZXJ5dGhpbmcuXFxuICAgICAqL1xcbiAgICByZWZsb3c6IGZ1bmN0aW9uIChlbGVtLCBwbHVnaW5zKSB7XFxuXFxuICAgICAgLy8gSWYgcGx1Z2lucyBpcyB1bmRlZmluZWQsIGp1c3QgZ3JhYiBldmVyeXRoaW5nXFxuICAgICAgaWYgKHR5cGVvZiBwbHVnaW5zID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgcGx1Z2lucyA9IE9iamVjdC5rZXlzKHRoaXMuX3BsdWdpbnMpO1xcbiAgICAgIH1cXG4gICAgICAvLyBJZiBwbHVnaW5zIGlzIGEgc3RyaW5nLCBjb252ZXJ0IGl0IHRvIGFuIGFycmF5IHdpdGggb25lIGl0ZW1cXG4gICAgICBlbHNlIGlmICh0eXBlb2YgcGx1Z2lucyA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgICAgcGx1Z2lucyA9IFtwbHVnaW5zXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIHBsdWdpblxcbiAgICAgICQuZWFjaChwbHVnaW5zLCBmdW5jdGlvbiAoaSwgbmFtZSkge1xcbiAgICAgICAgLy8gR2V0IHRoZSBjdXJyZW50IHBsdWdpblxcbiAgICAgICAgdmFyIHBsdWdpbiA9IF90aGlzLl9wbHVnaW5zW25hbWVdO1xcblxcbiAgICAgICAgLy8gTG9jYWxpemUgdGhlIHNlYXJjaCB0byBhbGwgZWxlbWVudHMgaW5zaWRlIGVsZW0sIGFzIHdlbGwgYXMgZWxlbSBpdHNlbGYsIHVubGVzcyBlbGVtID09PSBkb2N1bWVudFxcbiAgICAgICAgdmFyICRlbGVtID0gJChlbGVtKS5maW5kKCdbZGF0YS0nICsgbmFtZSArICddJykuYWRkQmFjaygnW2RhdGEtJyArIG5hbWUgKyAnXScpO1xcblxcbiAgICAgICAgLy8gRm9yIGVhY2ggcGx1Z2luIGZvdW5kLCBpbml0aWFsaXplIGl0XFxuICAgICAgICAkZWxlbS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyICRlbCA9ICQodGhpcyksXFxuICAgICAgICAgICAgICBvcHRzID0ge307XFxuICAgICAgICAgIC8vIERvbid0IGRvdWJsZS1kaXAgb24gcGx1Z2luc1xcbiAgICAgICAgICBpZiAoJGVsLmRhdGEoJ3pmUGx1Z2luJykpIHtcXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXFxcIlRyaWVkIHRvIGluaXRpYWxpemUgXFxcIiArIG5hbWUgKyBcXFwiIG9uIGFuIGVsZW1lbnQgdGhhdCBhbHJlYWR5IGhhcyBhIEZvdW5kYXRpb24gcGx1Z2luLlxcXCIpO1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAoJGVsLmF0dHIoJ2RhdGEtb3B0aW9ucycpKSB7XFxuICAgICAgICAgICAgdmFyIHRoaW5nID0gJGVsLmF0dHIoJ2RhdGEtb3B0aW9ucycpLnNwbGl0KCc7JykuZm9yRWFjaChmdW5jdGlvbiAoZSwgaSkge1xcbiAgICAgICAgICAgICAgdmFyIG9wdCA9IGUuc3BsaXQoJzonKS5tYXAoZnVuY3Rpb24gKGVsKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBlbC50cmltKCk7XFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgIGlmIChvcHRbMF0pIG9wdHNbb3B0WzBdXSA9IHBhcnNlVmFsdWUob3B0WzFdKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICB0cnkge1xcbiAgICAgICAgICAgICRlbC5kYXRhKCd6ZlBsdWdpbicsIG5ldyBwbHVnaW4oJCh0aGlzKSwgb3B0cykpO1xcbiAgICAgICAgICB9IGNhdGNoIChlcikge1xcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXIpO1xcbiAgICAgICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgIH0sXFxuICAgIGdldEZuTmFtZTogZnVuY3Rpb25OYW1lLFxcbiAgICB0cmFuc2l0aW9uZW5kOiBmdW5jdGlvbiAoJGVsZW0pIHtcXG4gICAgICB2YXIgdHJhbnNpdGlvbnMgPSB7XFxuICAgICAgICAndHJhbnNpdGlvbic6ICd0cmFuc2l0aW9uZW5kJyxcXG4gICAgICAgICdXZWJraXRUcmFuc2l0aW9uJzogJ3dlYmtpdFRyYW5zaXRpb25FbmQnLFxcbiAgICAgICAgJ01velRyYW5zaXRpb24nOiAndHJhbnNpdGlvbmVuZCcsXFxuICAgICAgICAnT1RyYW5zaXRpb24nOiAnb3RyYW5zaXRpb25lbmQnXFxuICAgICAgfTtcXG4gICAgICB2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxcbiAgICAgICAgICBlbmQ7XFxuXFxuICAgICAgZm9yICh2YXIgdCBpbiB0cmFuc2l0aW9ucykge1xcbiAgICAgICAgaWYgKHR5cGVvZiBlbGVtLnN0eWxlW3RdICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICBlbmQgPSB0cmFuc2l0aW9uc1t0XTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgaWYgKGVuZCkge1xcbiAgICAgICAgcmV0dXJuIGVuZDtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgZW5kID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICRlbGVtLnRyaWdnZXJIYW5kbGVyKCd0cmFuc2l0aW9uZW5kJywgWyRlbGVtXSk7XFxuICAgICAgICB9LCAxKTtcXG4gICAgICAgIHJldHVybiAndHJhbnNpdGlvbmVuZCc7XFxuICAgICAgfVxcbiAgICB9XFxuICB9O1xcblxcbiAgRm91bmRhdGlvbi51dGlsID0ge1xcbiAgICAvKipcXG4gICAgICogRnVuY3Rpb24gZm9yIGFwcGx5aW5nIGEgZGVib3VuY2UgZWZmZWN0IHRvIGEgZnVuY3Rpb24gY2FsbC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgLSBGdW5jdGlvbiB0byBiZSBjYWxsZWQgYXQgZW5kIG9mIHRpbWVvdXQuXFxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSBkZWxheSAtIFRpbWUgaW4gbXMgdG8gZGVsYXkgdGhlIGNhbGwgb2YgYGZ1bmNgLlxcbiAgICAgKiBAcmV0dXJucyBmdW5jdGlvblxcbiAgICAgKi9cXG4gICAgdGhyb3R0bGU6IGZ1bmN0aW9uIChmdW5jLCBkZWxheSkge1xcbiAgICAgIHZhciB0aW1lciA9IG51bGw7XFxuXFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBjb250ZXh0ID0gdGhpcyxcXG4gICAgICAgICAgICBhcmdzID0gYXJndW1lbnRzO1xcblxcbiAgICAgICAgaWYgKHRpbWVyID09PSBudWxsKSB7XFxuICAgICAgICAgIHRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcXG4gICAgICAgICAgICB0aW1lciA9IG51bGw7XFxuICAgICAgICAgIH0sIGRlbGF5KTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9XFxuICB9O1xcblxcbiAgLy8gVE9ETzogY29uc2lkZXIgbm90IG1ha2luZyB0aGlzIGEgalF1ZXJ5IGZ1bmN0aW9uXFxuICAvLyBUT0RPOiBuZWVkIHdheSB0byByZWZsb3cgdnMuIHJlLWluaXRpYWxpemVcXG4gIC8qKlxcbiAgICogVGhlIEZvdW5kYXRpb24galF1ZXJ5IG1ldGhvZC5cXG4gICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBtZXRob2QgLSBBbiBhY3Rpb24gdG8gcGVyZm9ybSBvbiB0aGUgY3VycmVudCBqUXVlcnkgb2JqZWN0LlxcbiAgICovXFxuICB2YXIgZm91bmRhdGlvbiA9IGZ1bmN0aW9uIChtZXRob2QpIHtcXG4gICAgdmFyIHR5cGUgPSB0eXBlb2YgbWV0aG9kLFxcbiAgICAgICAgJG1ldGEgPSAkKCdtZXRhLmZvdW5kYXRpb24tbXEnKSxcXG4gICAgICAgICRub0pTID0gJCgnLm5vLWpzJyk7XFxuXFxuICAgIGlmICghJG1ldGEubGVuZ3RoKSB7XFxuICAgICAgJCgnPG1ldGEgY2xhc3M9XFxcImZvdW5kYXRpb24tbXFcXFwiPicpLmFwcGVuZFRvKGRvY3VtZW50LmhlYWQpO1xcbiAgICB9XFxuICAgIGlmICgkbm9KUy5sZW5ndGgpIHtcXG4gICAgICAkbm9KUy5yZW1vdmVDbGFzcygnbm8tanMnKTtcXG4gICAgfVxcblxcbiAgICBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAvL25lZWRzIHRvIGluaXRpYWxpemUgdGhlIEZvdW5kYXRpb24gb2JqZWN0LCBvciBhbiBpbmRpdmlkdWFsIHBsdWdpbi5cXG4gICAgICBGb3VuZGF0aW9uLk1lZGlhUXVlcnkuX2luaXQoKTtcXG4gICAgICBGb3VuZGF0aW9uLnJlZmxvdyh0aGlzKTtcXG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xcbiAgICAgIC8vYW4gaW5kaXZpZHVhbCBtZXRob2QgdG8gaW52b2tlIG9uIGEgcGx1Z2luIG9yIGdyb3VwIG9mIHBsdWdpbnNcXG4gICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7IC8vY29sbGVjdCBhbGwgdGhlIGFyZ3VtZW50cywgaWYgbmVjZXNzYXJ5XFxuICAgICAgdmFyIHBsdWdDbGFzcyA9IHRoaXMuZGF0YSgnemZQbHVnaW4nKTsgLy9kZXRlcm1pbmUgdGhlIGNsYXNzIG9mIHBsdWdpblxcblxcbiAgICAgIGlmIChwbHVnQ2xhc3MgIT09IHVuZGVmaW5lZCAmJiBwbHVnQ2xhc3NbbWV0aG9kXSAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAvL21ha2Ugc3VyZSBib3RoIHRoZSBjbGFzcyBhbmQgbWV0aG9kIGV4aXN0XFxuICAgICAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHtcXG4gICAgICAgICAgLy9pZiB0aGVyZSdzIG9ubHkgb25lLCBjYWxsIGl0IGRpcmVjdGx5LlxcbiAgICAgICAgICBwbHVnQ2xhc3NbbWV0aG9kXS5hcHBseShwbHVnQ2xhc3MsIGFyZ3MpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5lYWNoKGZ1bmN0aW9uIChpLCBlbCkge1xcbiAgICAgICAgICAgIC8vb3RoZXJ3aXNlIGxvb3AgdGhyb3VnaCB0aGUgalF1ZXJ5IGNvbGxlY3Rpb24gYW5kIGludm9rZSB0aGUgbWV0aG9kIG9uIGVhY2hcXG4gICAgICAgICAgICBwbHVnQ2xhc3NbbWV0aG9kXS5hcHBseSgkKGVsKS5kYXRhKCd6ZlBsdWdpbicpLCBhcmdzKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIC8vZXJyb3IgZm9yIG5vIGNsYXNzIG9yIG5vIG1ldGhvZFxcbiAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJXZSdyZSBzb3JyeSwgJ1xcXCIgKyBtZXRob2QgKyBcXFwiJyBpcyBub3QgYW4gYXZhaWxhYmxlIG1ldGhvZCBmb3IgXFxcIiArIChwbHVnQ2xhc3MgPyBmdW5jdGlvbk5hbWUocGx1Z0NsYXNzKSA6ICd0aGlzIGVsZW1lbnQnKSArICcuJyk7XFxuICAgICAgfVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vZXJyb3IgZm9yIGludmFsaWQgYXJndW1lbnQgdHlwZVxcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1dlXFxcXCdyZSBzb3JyeSwgJyArIHR5cGUgKyAnIGlzIG5vdCBhIHZhbGlkIHBhcmFtZXRlci4gWW91IG11c3QgdXNlIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgbWV0aG9kIHlvdSB3aXNoIHRvIGludm9rZS4nKTtcXG4gICAgfVxcbiAgICByZXR1cm4gdGhpcztcXG4gIH07XFxuXFxuICB3aW5kb3cuRm91bmRhdGlvbiA9IEZvdW5kYXRpb247XFxuICAkLmZuLmZvdW5kYXRpb24gPSBmb3VuZGF0aW9uO1xcblxcbiAgLy8gUG9seWZpbGwgZm9yIHJlcXVlc3RBbmltYXRpb25GcmFtZVxcbiAgKGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKCFEYXRlLm5vdyB8fCAhd2luZG93LkRhdGUubm93KSB3aW5kb3cuRGF0ZS5ub3cgPSBEYXRlLm5vdyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XFxuICAgIH07XFxuXFxuICAgIHZhciB2ZW5kb3JzID0gWyd3ZWJraXQnLCAnbW96J107XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVuZG9ycy5sZW5ndGggJiYgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWU7ICsraSkge1xcbiAgICAgIHZhciB2cCA9IHZlbmRvcnNbaV07XFxuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1t2cCArICdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnXTtcXG4gICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbdnAgKyAnQ2FuY2VsQW5pbWF0aW9uRnJhbWUnXSB8fCB3aW5kb3dbdnAgKyAnQ2FuY2VsUmVxdWVzdEFuaW1hdGlvbkZyYW1lJ107XFxuICAgIH1cXG4gICAgaWYgKC9pUChhZHxob25lfG9kKS4qT1MgNi8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgIXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xcbiAgICAgIHZhciBsYXN0VGltZSA9IDA7XFxuICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XFxuICAgICAgICB2YXIgbmV4dFRpbWUgPSBNYXRoLm1heChsYXN0VGltZSArIDE2LCBub3cpO1xcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBjYWxsYmFjayhsYXN0VGltZSA9IG5leHRUaW1lKTtcXG4gICAgICAgIH0sIG5leHRUaW1lIC0gbm93KTtcXG4gICAgICB9O1xcbiAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGNsZWFyVGltZW91dDtcXG4gICAgfVxcbiAgICAvKipcXG4gICAgICogUG9seWZpbGwgZm9yIHBlcmZvcm1hbmNlLm5vdywgcmVxdWlyZWQgYnkgckFGXFxuICAgICAqL1xcbiAgICBpZiAoIXdpbmRvdy5wZXJmb3JtYW5jZSB8fCAhd2luZG93LnBlcmZvcm1hbmNlLm5vdykge1xcbiAgICAgIHdpbmRvdy5wZXJmb3JtYW5jZSA9IHtcXG4gICAgICAgIHN0YXJ0OiBEYXRlLm5vdygpLFxcbiAgICAgICAgbm93OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5zdGFydDtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9XFxuICB9KSgpO1xcbiAgaWYgKCFGdW5jdGlvbi5wcm90b3R5cGUuYmluZCkge1xcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCA9IGZ1bmN0aW9uIChvVGhpcykge1xcbiAgICAgIGlmICh0eXBlb2YgdGhpcyAhPT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgLy8gY2xvc2VzdCB0aGluZyBwb3NzaWJsZSB0byB0aGUgRUNNQVNjcmlwdCA1XFxuICAgICAgICAvLyBpbnRlcm5hbCBJc0NhbGxhYmxlIGZ1bmN0aW9uXFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCAtIHdoYXQgaXMgdHJ5aW5nIHRvIGJlIGJvdW5kIGlzIG5vdCBjYWxsYWJsZScpO1xcbiAgICAgIH1cXG5cXG4gICAgICB2YXIgYUFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpLFxcbiAgICAgICAgICBmVG9CaW5kID0gdGhpcyxcXG4gICAgICAgICAgZk5PUCA9IGZ1bmN0aW9uICgpIHt9LFxcbiAgICAgICAgICBmQm91bmQgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gZlRvQmluZC5hcHBseSh0aGlzIGluc3RhbmNlb2YgZk5PUCA/IHRoaXMgOiBvVGhpcywgYUFyZ3MuY29uY2F0KEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcXG4gICAgICB9O1xcblxcbiAgICAgIGlmICh0aGlzLnByb3RvdHlwZSkge1xcbiAgICAgICAgLy8gbmF0aXZlIGZ1bmN0aW9ucyBkb24ndCBoYXZlIGEgcHJvdG90eXBlXFxuICAgICAgICBmTk9QLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlO1xcbiAgICAgIH1cXG4gICAgICBmQm91bmQucHJvdG90eXBlID0gbmV3IGZOT1AoKTtcXG5cXG4gICAgICByZXR1cm4gZkJvdW5kO1xcbiAgICB9O1xcbiAgfVxcbiAgLy8gUG9seWZpbGwgdG8gZ2V0IHRoZSBuYW1lIG9mIGEgZnVuY3Rpb24gaW4gSUU5XFxuICBmdW5jdGlvbiBmdW5jdGlvbk5hbWUoZm4pIHtcXG4gICAgaWYgKEZ1bmN0aW9uLnByb3RvdHlwZS5uYW1lID09PSB1bmRlZmluZWQpIHtcXG4gICAgICB2YXIgZnVuY05hbWVSZWdleCA9IC9mdW5jdGlvblxcXFxzKFteKF17MSx9KVxcXFwoLztcXG4gICAgICB2YXIgcmVzdWx0cyA9IGZ1bmNOYW1lUmVnZXguZXhlYyhmbi50b1N0cmluZygpKTtcXG4gICAgICByZXR1cm4gcmVzdWx0cyAmJiByZXN1bHRzLmxlbmd0aCA+IDEgPyByZXN1bHRzWzFdLnRyaW0oKSA6IFxcXCJcXFwiO1xcbiAgICB9IGVsc2UgaWYgKGZuLnByb3RvdHlwZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgcmV0dXJuIGZuLmNvbnN0cnVjdG9yLm5hbWU7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIGZuLnByb3RvdHlwZS5jb25zdHJ1Y3Rvci5uYW1lO1xcbiAgICB9XFxuICB9XFxuICBmdW5jdGlvbiBwYXJzZVZhbHVlKHN0cikge1xcbiAgICBpZiAoL3RydWUvLnRlc3Qoc3RyKSkgcmV0dXJuIHRydWU7ZWxzZSBpZiAoL2ZhbHNlLy50ZXN0KHN0cikpIHJldHVybiBmYWxzZTtlbHNlIGlmICghaXNOYU4oc3RyICogMSkpIHJldHVybiBwYXJzZUZsb2F0KHN0cik7XFxuICAgIHJldHVybiBzdHI7XFxuICB9XFxuICAvLyBDb252ZXJ0IFBhc2NhbENhc2UgdG8ga2ViYWItY2FzZVxcbiAgLy8gVGhhbmsgeW91OiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS84OTU1NTgwXFxuICBmdW5jdGlvbiBoeXBoZW5hdGUoc3RyKSB7XFxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcXG4gIH1cXG59KGpRdWVyeSk7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbiFmdW5jdGlvbiAoJCkge1xcblxcbiAgRm91bmRhdGlvbi5Cb3ggPSB7XFxuICAgIEltTm90VG91Y2hpbmdZb3U6IEltTm90VG91Y2hpbmdZb3UsXFxuICAgIEdldERpbWVuc2lvbnM6IEdldERpbWVuc2lvbnMsXFxuICAgIEdldE9mZnNldHM6IEdldE9mZnNldHNcXG4gIH07XFxuXFxuICAvKipcXG4gICAqIENvbXBhcmVzIHRoZSBkaW1lbnNpb25zIG9mIGFuIGVsZW1lbnQgdG8gYSBjb250YWluZXIgYW5kIGRldGVybWluZXMgY29sbGlzaW9uIGV2ZW50cyB3aXRoIGNvbnRhaW5lci5cXG4gICAqIEBmdW5jdGlvblxcbiAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIHRlc3QgZm9yIGNvbGxpc2lvbnMuXFxuICAgKiBAcGFyYW0ge2pRdWVyeX0gcGFyZW50IC0galF1ZXJ5IG9iamVjdCB0byB1c2UgYXMgYm91bmRpbmcgY29udGFpbmVyLlxcbiAgICogQHBhcmFtIHtCb29sZWFufSBsck9ubHkgLSBzZXQgdG8gdHJ1ZSB0byBjaGVjayBsZWZ0IGFuZCByaWdodCB2YWx1ZXMgb25seS5cXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gdGJPbmx5IC0gc2V0IHRvIHRydWUgdG8gY2hlY2sgdG9wIGFuZCBib3R0b20gdmFsdWVzIG9ubHkuXFxuICAgKiBAZGVmYXVsdCBpZiBubyBwYXJlbnQgb2JqZWN0IHBhc3NlZCwgZGV0ZWN0cyBjb2xsaXNpb25zIHdpdGggYHdpbmRvd2AuXFxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gLSB0cnVlIGlmIGNvbGxpc2lvbiBmcmVlLCBmYWxzZSBpZiBhIGNvbGxpc2lvbiBpbiBhbnkgZGlyZWN0aW9uLlxcbiAgICovXFxuICBmdW5jdGlvbiBJbU5vdFRvdWNoaW5nWW91KGVsZW1lbnQsIHBhcmVudCwgbHJPbmx5LCB0Yk9ubHkpIHtcXG4gICAgdmFyIGVsZURpbXMgPSBHZXREaW1lbnNpb25zKGVsZW1lbnQpLFxcbiAgICAgICAgdG9wLFxcbiAgICAgICAgYm90dG9tLFxcbiAgICAgICAgbGVmdCxcXG4gICAgICAgIHJpZ2h0O1xcblxcbiAgICBpZiAocGFyZW50KSB7XFxuICAgICAgdmFyIHBhckRpbXMgPSBHZXREaW1lbnNpb25zKHBhcmVudCk7XFxuXFxuICAgICAgYm90dG9tID0gZWxlRGltcy5vZmZzZXQudG9wICsgZWxlRGltcy5oZWlnaHQgPD0gcGFyRGltcy5oZWlnaHQgKyBwYXJEaW1zLm9mZnNldC50b3A7XFxuICAgICAgdG9wID0gZWxlRGltcy5vZmZzZXQudG9wID49IHBhckRpbXMub2Zmc2V0LnRvcDtcXG4gICAgICBsZWZ0ID0gZWxlRGltcy5vZmZzZXQubGVmdCA+PSBwYXJEaW1zLm9mZnNldC5sZWZ0O1xcbiAgICAgIHJpZ2h0ID0gZWxlRGltcy5vZmZzZXQubGVmdCArIGVsZURpbXMud2lkdGggPD0gcGFyRGltcy53aWR0aCArIHBhckRpbXMub2Zmc2V0LmxlZnQ7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgYm90dG9tID0gZWxlRGltcy5vZmZzZXQudG9wICsgZWxlRGltcy5oZWlnaHQgPD0gZWxlRGltcy53aW5kb3dEaW1zLmhlaWdodCArIGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wO1xcbiAgICAgIHRvcCA9IGVsZURpbXMub2Zmc2V0LnRvcCA+PSBlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LnRvcDtcXG4gICAgICBsZWZ0ID0gZWxlRGltcy5vZmZzZXQubGVmdCA+PSBlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQ7XFxuICAgICAgcmlnaHQgPSBlbGVEaW1zLm9mZnNldC5sZWZ0ICsgZWxlRGltcy53aWR0aCA8PSBlbGVEaW1zLndpbmRvd0RpbXMud2lkdGg7XFxuICAgIH1cXG5cXG4gICAgdmFyIGFsbERpcnMgPSBbYm90dG9tLCB0b3AsIGxlZnQsIHJpZ2h0XTtcXG5cXG4gICAgaWYgKGxyT25seSkge1xcbiAgICAgIHJldHVybiBsZWZ0ID09PSByaWdodCA9PT0gdHJ1ZTtcXG4gICAgfVxcblxcbiAgICBpZiAodGJPbmx5KSB7XFxuICAgICAgcmV0dXJuIHRvcCA9PT0gYm90dG9tID09PSB0cnVlO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBhbGxEaXJzLmluZGV4T2YoZmFsc2UpID09PSAtMTtcXG4gIH07XFxuXFxuICAvKipcXG4gICAqIFVzZXMgbmF0aXZlIG1ldGhvZHMgdG8gcmV0dXJuIGFuIG9iamVjdCBvZiBkaW1lbnNpb24gdmFsdWVzLlxcbiAgICogQGZ1bmN0aW9uXFxuICAgKiBAcGFyYW0ge2pRdWVyeSB8fCBIVE1MfSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCBvciBET00gZWxlbWVudCBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBkaW1lbnNpb25zLiBDYW4gYmUgYW55IGVsZW1lbnQgb3RoZXIgdGhhdCBkb2N1bWVudCBvciB3aW5kb3cuXFxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIG5lc3RlZCBvYmplY3Qgb2YgaW50ZWdlciBwaXhlbCB2YWx1ZXNcXG4gICAqIFRPRE8gLSBpZiBlbGVtZW50IGlzIHdpbmRvdywgcmV0dXJuIG9ubHkgdGhvc2UgdmFsdWVzLlxcbiAgICovXFxuICBmdW5jdGlvbiBHZXREaW1lbnNpb25zKGVsZW0sIHRlc3QpIHtcXG4gICAgZWxlbSA9IGVsZW0ubGVuZ3RoID8gZWxlbVswXSA6IGVsZW07XFxuXFxuICAgIGlmIChlbGVtID09PSB3aW5kb3cgfHwgZWxlbSA9PT0gZG9jdW1lbnQpIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXFxcIkknbSBzb3JyeSwgRGF2ZS4gSSdtIGFmcmFpZCBJIGNhbid0IGRvIHRoYXQuXFxcIik7XFxuICAgIH1cXG5cXG4gICAgdmFyIHJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxcbiAgICAgICAgcGFyUmVjdCA9IGVsZW0ucGFyZW50Tm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcXG4gICAgICAgIHdpblJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxcbiAgICAgICAgd2luWSA9IHdpbmRvdy5wYWdlWU9mZnNldCxcXG4gICAgICAgIHdpblggPSB3aW5kb3cucGFnZVhPZmZzZXQ7XFxuXFxuICAgIHJldHVybiB7XFxuICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXFxuICAgICAgaGVpZ2h0OiByZWN0LmhlaWdodCxcXG4gICAgICBvZmZzZXQ6IHtcXG4gICAgICAgIHRvcDogcmVjdC50b3AgKyB3aW5ZLFxcbiAgICAgICAgbGVmdDogcmVjdC5sZWZ0ICsgd2luWFxcbiAgICAgIH0sXFxuICAgICAgcGFyZW50RGltczoge1xcbiAgICAgICAgd2lkdGg6IHBhclJlY3Qud2lkdGgsXFxuICAgICAgICBoZWlnaHQ6IHBhclJlY3QuaGVpZ2h0LFxcbiAgICAgICAgb2Zmc2V0OiB7XFxuICAgICAgICAgIHRvcDogcGFyUmVjdC50b3AgKyB3aW5ZLFxcbiAgICAgICAgICBsZWZ0OiBwYXJSZWN0LmxlZnQgKyB3aW5YXFxuICAgICAgICB9XFxuICAgICAgfSxcXG4gICAgICB3aW5kb3dEaW1zOiB7XFxuICAgICAgICB3aWR0aDogd2luUmVjdC53aWR0aCxcXG4gICAgICAgIGhlaWdodDogd2luUmVjdC5oZWlnaHQsXFxuICAgICAgICBvZmZzZXQ6IHtcXG4gICAgICAgICAgdG9wOiB3aW5ZLFxcbiAgICAgICAgICBsZWZ0OiB3aW5YXFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCBvZiB0b3AgYW5kIGxlZnQgaW50ZWdlciBwaXhlbCB2YWx1ZXMgZm9yIGR5bmFtaWNhbGx5IHJlbmRlcmVkIGVsZW1lbnRzLFxcbiAgICogc3VjaCBhczogVG9vbHRpcCwgUmV2ZWFsLCBhbmQgRHJvcGRvd25cXG4gICAqIEBmdW5jdGlvblxcbiAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IGZvciB0aGUgZWxlbWVudCBiZWluZyBwb3NpdGlvbmVkLlxcbiAgICogQHBhcmFtIHtqUXVlcnl9IGFuY2hvciAtIGpRdWVyeSBvYmplY3QgZm9yIHRoZSBlbGVtZW50J3MgYW5jaG9yIHBvaW50LlxcbiAgICogQHBhcmFtIHtTdHJpbmd9IHBvc2l0aW9uIC0gYSBzdHJpbmcgcmVsYXRpbmcgdG8gdGhlIGRlc2lyZWQgcG9zaXRpb24gb2YgdGhlIGVsZW1lbnQsIHJlbGF0aXZlIHRvIGl0J3MgYW5jaG9yXFxuICAgKiBAcGFyYW0ge051bWJlcn0gdk9mZnNldCAtIGludGVnZXIgcGl4ZWwgdmFsdWUgb2YgZGVzaXJlZCB2ZXJ0aWNhbCBzZXBhcmF0aW9uIGJldHdlZW4gYW5jaG9yIGFuZCBlbGVtZW50LlxcbiAgICogQHBhcmFtIHtOdW1iZXJ9IGhPZmZzZXQgLSBpbnRlZ2VyIHBpeGVsIHZhbHVlIG9mIGRlc2lyZWQgaG9yaXpvbnRhbCBzZXBhcmF0aW9uIGJldHdlZW4gYW5jaG9yIGFuZCBlbGVtZW50LlxcbiAgICogQHBhcmFtIHtCb29sZWFufSBpc092ZXJmbG93IC0gaWYgYSBjb2xsaXNpb24gZXZlbnQgaXMgZGV0ZWN0ZWQsIHNldHMgdG8gdHJ1ZSB0byBkZWZhdWx0IHRoZSBlbGVtZW50IHRvIGZ1bGwgd2lkdGggLSBhbnkgZGVzaXJlZCBvZmZzZXQuXFxuICAgKiBUT0RPIGFsdGVyL3Jld3JpdGUgdG8gd29yayB3aXRoIGBlbWAgdmFsdWVzIGFzIHdlbGwvaW5zdGVhZCBvZiBwaXhlbHNcXG4gICAqL1xcbiAgZnVuY3Rpb24gR2V0T2Zmc2V0cyhlbGVtZW50LCBhbmNob3IsIHBvc2l0aW9uLCB2T2Zmc2V0LCBoT2Zmc2V0LCBpc092ZXJmbG93KSB7XFxuICAgIHZhciAkZWxlRGltcyA9IEdldERpbWVuc2lvbnMoZWxlbWVudCksXFxuICAgICAgICAkYW5jaG9yRGltcyA9IGFuY2hvciA/IEdldERpbWVuc2lvbnMoYW5jaG9yKSA6IG51bGw7XFxuXFxuICAgIHN3aXRjaCAocG9zaXRpb24pIHtcXG4gICAgICBjYXNlICd0b3AnOlxcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgbGVmdDogRm91bmRhdGlvbi5ydGwoKSA/ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0IC0gJGVsZURpbXMud2lkdGggKyAkYW5jaG9yRGltcy53aWR0aCA6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0LFxcbiAgICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3AgLSAoJGVsZURpbXMuaGVpZ2h0ICsgdk9mZnNldClcXG4gICAgICAgIH07XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICdsZWZ0JzpcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIGxlZnQ6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0IC0gKCRlbGVEaW1zLndpZHRoICsgaE9mZnNldCksXFxuICAgICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcFxcbiAgICAgICAgfTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgJ3JpZ2h0JzpcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIGxlZnQ6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgJGFuY2hvckRpbXMud2lkdGggKyBoT2Zmc2V0LFxcbiAgICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3BcXG4gICAgICAgIH07XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICdjZW50ZXIgdG9wJzpcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIGxlZnQ6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgJGFuY2hvckRpbXMud2lkdGggLyAyIC0gJGVsZURpbXMud2lkdGggLyAyLFxcbiAgICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3AgLSAoJGVsZURpbXMuaGVpZ2h0ICsgdk9mZnNldClcXG4gICAgICAgIH07XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICdjZW50ZXIgYm90dG9tJzpcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIGxlZnQ6IGlzT3ZlcmZsb3cgPyBoT2Zmc2V0IDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgKyAkYW5jaG9yRGltcy53aWR0aCAvIDIgLSAkZWxlRGltcy53aWR0aCAvIDIsXFxuICAgICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICRhbmNob3JEaW1zLmhlaWdodCArIHZPZmZzZXRcXG4gICAgICAgIH07XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICdjZW50ZXIgbGVmdCc6XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBsZWZ0OiAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCAtICgkZWxlRGltcy53aWR0aCArIGhPZmZzZXQpLFxcbiAgICAgICAgICB0b3A6ICRhbmNob3JEaW1zLm9mZnNldC50b3AgKyAkYW5jaG9yRGltcy5oZWlnaHQgLyAyIC0gJGVsZURpbXMuaGVpZ2h0IC8gMlxcbiAgICAgICAgfTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgJ2NlbnRlciByaWdodCc6XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBsZWZ0OiAkYW5jaG9yRGltcy5vZmZzZXQubGVmdCArICRhbmNob3JEaW1zLndpZHRoICsgaE9mZnNldCArIDEsXFxuICAgICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICRhbmNob3JEaW1zLmhlaWdodCAvIDIgLSAkZWxlRGltcy5oZWlnaHQgLyAyXFxuICAgICAgICB9O1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAnY2VudGVyJzpcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIGxlZnQ6ICRlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQgKyAkZWxlRGltcy53aW5kb3dEaW1zLndpZHRoIC8gMiAtICRlbGVEaW1zLndpZHRoIC8gMixcXG4gICAgICAgICAgdG9wOiAkZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3AgKyAkZWxlRGltcy53aW5kb3dEaW1zLmhlaWdodCAvIDIgLSAkZWxlRGltcy5oZWlnaHQgLyAyXFxuICAgICAgICB9O1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAncmV2ZWFsJzpcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIGxlZnQ6ICgkZWxlRGltcy53aW5kb3dEaW1zLndpZHRoIC0gJGVsZURpbXMud2lkdGgpIC8gMixcXG4gICAgICAgICAgdG9wOiAkZWxlRGltcy53aW5kb3dEaW1zLm9mZnNldC50b3AgKyB2T2Zmc2V0XFxuICAgICAgICB9O1xcbiAgICAgIGNhc2UgJ3JldmVhbCBmdWxsJzpcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIGxlZnQ6ICRlbGVEaW1zLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQsXFxuICAgICAgICAgIHRvcDogJGVsZURpbXMud2luZG93RGltcy5vZmZzZXQudG9wXFxuICAgICAgICB9O1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAnbGVmdCBib3R0b20nOlxcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgbGVmdDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAoJGVsZURpbXMud2lkdGggKyBoT2Zmc2V0KSxcXG4gICAgICAgICAgdG9wOiAkYW5jaG9yRGltcy5vZmZzZXQudG9wICsgJGFuY2hvckRpbXMuaGVpZ2h0XFxuICAgICAgICB9O1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAncmlnaHQgYm90dG9tJzpcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgIGxlZnQ6ICRhbmNob3JEaW1zLm9mZnNldC5sZWZ0ICsgJGFuY2hvckRpbXMud2lkdGggKyBoT2Zmc2V0IC0gJGVsZURpbXMud2lkdGgsXFxuICAgICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICRhbmNob3JEaW1zLmhlaWdodFxcbiAgICAgICAgfTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBsZWZ0OiBGb3VuZGF0aW9uLnJ0bCgpID8gJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQgLSAkZWxlRGltcy53aWR0aCArICRhbmNob3JEaW1zLndpZHRoIDogJGFuY2hvckRpbXMub2Zmc2V0LmxlZnQsXFxuICAgICAgICAgIHRvcDogJGFuY2hvckRpbXMub2Zmc2V0LnRvcCArICRhbmNob3JEaW1zLmhlaWdodCArIHZPZmZzZXRcXG4gICAgICAgIH07XFxuICAgIH1cXG4gIH1cXG59KGpRdWVyeSk7XFxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKlxcbiAqIFRoaXMgdXRpbCB3YXMgY3JlYXRlZCBieSBNYXJpdXMgT2xiZXJ0eiAqXFxuICogUGxlYXNlIHRoYW5rIE1hcml1cyBvbiBHaXRIdWIgL293bGJlcnR6ICpcXG4gKiBvciB0aGUgd2ViIGh0dHA6Ly93d3cubWFyaXVzb2xiZXJ0ei5kZS8gKlxcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqXFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG5cXG4ndXNlIHN0cmljdCc7XFxuXFxuIWZ1bmN0aW9uICgkKSB7XFxuXFxuICB2YXIga2V5Q29kZXMgPSB7XFxuICAgIDk6ICdUQUInLFxcbiAgICAxMzogJ0VOVEVSJyxcXG4gICAgMjc6ICdFU0NBUEUnLFxcbiAgICAzMjogJ1NQQUNFJyxcXG4gICAgMzc6ICdBUlJPV19MRUZUJyxcXG4gICAgMzg6ICdBUlJPV19VUCcsXFxuICAgIDM5OiAnQVJST1dfUklHSFQnLFxcbiAgICA0MDogJ0FSUk9XX0RPV04nXFxuICB9O1xcblxcbiAgdmFyIGNvbW1hbmRzID0ge307XFxuXFxuICB2YXIgS2V5Ym9hcmQgPSB7XFxuICAgIGtleXM6IGdldEtleUNvZGVzKGtleUNvZGVzKSxcXG5cXG4gICAgLyoqXFxuICAgICAqIFBhcnNlcyB0aGUgKGtleWJvYXJkKSBldmVudCBhbmQgcmV0dXJucyBhIFN0cmluZyB0aGF0IHJlcHJlc2VudHMgaXRzIGtleVxcbiAgICAgKiBDYW4gYmUgdXNlZCBsaWtlIEZvdW5kYXRpb24ucGFyc2VLZXkoZXZlbnQpID09PSBGb3VuZGF0aW9uLmtleXMuU1BBQ0VcXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSB0aGUgZXZlbnQgZ2VuZXJhdGVkIGJ5IHRoZSBldmVudCBoYW5kbGVyXFxuICAgICAqIEByZXR1cm4gU3RyaW5nIGtleSAtIFN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIGtleSBwcmVzc2VkXFxuICAgICAqL1xcbiAgICBwYXJzZUtleTogZnVuY3Rpb24gKGV2ZW50KSB7XFxuICAgICAgdmFyIGtleSA9IGtleUNvZGVzW2V2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGVdIHx8IFN0cmluZy5mcm9tQ2hhckNvZGUoZXZlbnQud2hpY2gpLnRvVXBwZXJDYXNlKCk7XFxuICAgICAgaWYgKGV2ZW50LnNoaWZ0S2V5KSBrZXkgPSAnU0hJRlRfJyArIGtleTtcXG4gICAgICBpZiAoZXZlbnQuY3RybEtleSkga2V5ID0gJ0NUUkxfJyArIGtleTtcXG4gICAgICBpZiAoZXZlbnQuYWx0S2V5KSBrZXkgPSAnQUxUXycgKyBrZXk7XFxuICAgICAgcmV0dXJuIGtleTtcXG4gICAgfSxcXG5cXG5cXG4gICAgLyoqXFxuICAgICAqIEhhbmRsZXMgdGhlIGdpdmVuIChrZXlib2FyZCkgZXZlbnRcXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgLSB0aGUgZXZlbnQgZ2VuZXJhdGVkIGJ5IHRoZSBldmVudCBoYW5kbGVyXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBjb21wb25lbnQgLSBGb3VuZGF0aW9uIGNvbXBvbmVudCdzIG5hbWUsIGUuZy4gU2xpZGVyIG9yIFJldmVhbFxcbiAgICAgKiBAcGFyYW0ge09iamVjdHN9IGZ1bmN0aW9ucyAtIGNvbGxlY3Rpb24gb2YgZnVuY3Rpb25zIHRoYXQgYXJlIHRvIGJlIGV4ZWN1dGVkXFxuICAgICAqL1xcbiAgICBoYW5kbGVLZXk6IGZ1bmN0aW9uIChldmVudCwgY29tcG9uZW50LCBmdW5jdGlvbnMpIHtcXG4gICAgICB2YXIgY29tbWFuZExpc3QgPSBjb21tYW5kc1tjb21wb25lbnRdLFxcbiAgICAgICAgICBrZXlDb2RlID0gdGhpcy5wYXJzZUtleShldmVudCksXFxuICAgICAgICAgIGNtZHMsXFxuICAgICAgICAgIGNvbW1hbmQsXFxuICAgICAgICAgIGZuO1xcblxcbiAgICAgIGlmICghY29tbWFuZExpc3QpIHJldHVybiBjb25zb2xlLndhcm4oJ0NvbXBvbmVudCBub3QgZGVmaW5lZCEnKTtcXG5cXG4gICAgICBpZiAodHlwZW9mIGNvbW1hbmRMaXN0Lmx0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIC8vIHRoaXMgY29tcG9uZW50IGRvZXMgbm90IGRpZmZlcmVudGlhdGUgYmV0d2VlbiBsdHIgYW5kIHJ0bFxcbiAgICAgICAgY21kcyA9IGNvbW1hbmRMaXN0OyAvLyB1c2UgcGxhaW4gbGlzdFxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIG1lcmdlIGx0ciBhbmQgcnRsOiBpZiBkb2N1bWVudCBpcyBydGwsIHJ0bCBvdmVyd3JpdGVzIGx0ciBhbmQgdmljZSB2ZXJzYVxcbiAgICAgICAgICBpZiAoRm91bmRhdGlvbi5ydGwoKSkgY21kcyA9ICQuZXh0ZW5kKHt9LCBjb21tYW5kTGlzdC5sdHIsIGNvbW1hbmRMaXN0LnJ0bCk7ZWxzZSBjbWRzID0gJC5leHRlbmQoe30sIGNvbW1hbmRMaXN0LnJ0bCwgY29tbWFuZExpc3QubHRyKTtcXG4gICAgICAgIH1cXG4gICAgICBjb21tYW5kID0gY21kc1trZXlDb2RlXTtcXG5cXG4gICAgICBmbiA9IGZ1bmN0aW9uc1tjb21tYW5kXTtcXG4gICAgICBpZiAoZm4gJiYgdHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAvLyBleGVjdXRlIGZ1bmN0aW9uICBpZiBleGlzdHNcXG4gICAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGZuLmFwcGx5KCk7XFxuICAgICAgICBpZiAoZnVuY3Rpb25zLmhhbmRsZWQgfHwgdHlwZW9mIGZ1bmN0aW9ucy5oYW5kbGVkID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgIC8vIGV4ZWN1dGUgZnVuY3Rpb24gd2hlbiBldmVudCB3YXMgaGFuZGxlZFxcbiAgICAgICAgICBmdW5jdGlvbnMuaGFuZGxlZChyZXR1cm5WYWx1ZSk7XFxuICAgICAgICB9XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGlmIChmdW5jdGlvbnMudW5oYW5kbGVkIHx8IHR5cGVvZiBmdW5jdGlvbnMudW5oYW5kbGVkID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgIC8vIGV4ZWN1dGUgZnVuY3Rpb24gd2hlbiBldmVudCB3YXMgbm90IGhhbmRsZWRcXG4gICAgICAgICAgZnVuY3Rpb25zLnVuaGFuZGxlZCgpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSxcXG5cXG5cXG4gICAgLyoqXFxuICAgICAqIEZpbmRzIGFsbCBmb2N1c2FibGUgZWxlbWVudHMgd2l0aGluIHRoZSBnaXZlbiBgJGVsZW1lbnRgXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gc2VhcmNoIHdpdGhpblxcbiAgICAgKiBAcmV0dXJuIHtqUXVlcnl9ICRmb2N1c2FibGUgLSBhbGwgZm9jdXNhYmxlIGVsZW1lbnRzIHdpdGhpbiBgJGVsZW1lbnRgXFxuICAgICAqL1xcbiAgICBmaW5kRm9jdXNhYmxlOiBmdW5jdGlvbiAoJGVsZW1lbnQpIHtcXG4gICAgICByZXR1cm4gJGVsZW1lbnQuZmluZCgnYVtocmVmXSwgYXJlYVtocmVmXSwgaW5wdXQ6bm90KFtkaXNhYmxlZF0pLCBzZWxlY3Q6bm90KFtkaXNhYmxlZF0pLCB0ZXh0YXJlYTpub3QoW2Rpc2FibGVkXSksIGJ1dHRvbjpub3QoW2Rpc2FibGVkXSksIGlmcmFtZSwgb2JqZWN0LCBlbWJlZCwgKlt0YWJpbmRleF0sICpbY29udGVudGVkaXRhYmxlXScpLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpZiAoISQodGhpcykuaXMoJzp2aXNpYmxlJykgfHwgJCh0aGlzKS5hdHRyKCd0YWJpbmRleCcpIDwgMCkge1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9IC8vb25seSBoYXZlIHZpc2libGUgZWxlbWVudHMgYW5kIHRob3NlIHRoYXQgaGF2ZSBhIHRhYmluZGV4IGdyZWF0ZXIgb3IgZXF1YWwgMFxcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfSk7XFxuICAgIH0sXFxuXFxuXFxuICAgIC8qKlxcbiAgICAgKiBSZXR1cm5zIHRoZSBjb21wb25lbnQgbmFtZSBuYW1lXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb21wb25lbnQgLSBGb3VuZGF0aW9uIGNvbXBvbmVudCwgZS5nLiBTbGlkZXIgb3IgUmV2ZWFsXFxuICAgICAqIEByZXR1cm4gU3RyaW5nIGNvbXBvbmVudE5hbWVcXG4gICAgICovXFxuXFxuICAgIHJlZ2lzdGVyOiBmdW5jdGlvbiAoY29tcG9uZW50TmFtZSwgY21kcykge1xcbiAgICAgIGNvbW1hbmRzW2NvbXBvbmVudE5hbWVdID0gY21kcztcXG4gICAgfVxcbiAgfTtcXG5cXG4gIC8qXFxuICAgKiBDb25zdGFudHMgZm9yIGVhc2llciBjb21wYXJpbmcuXFxuICAgKiBDYW4gYmUgdXNlZCBsaWtlIEZvdW5kYXRpb24ucGFyc2VLZXkoZXZlbnQpID09PSBGb3VuZGF0aW9uLmtleXMuU1BBQ0VcXG4gICAqL1xcbiAgZnVuY3Rpb24gZ2V0S2V5Q29kZXMoa2NzKSB7XFxuICAgIHZhciBrID0ge307XFxuICAgIGZvciAodmFyIGtjIGluIGtjcykge1xcbiAgICAgIGtba2NzW2tjXV0gPSBrY3Nba2NdO1xcbiAgICB9cmV0dXJuIGs7XFxuICB9XFxuXFxuICBGb3VuZGF0aW9uLktleWJvYXJkID0gS2V5Ym9hcmQ7XFxufShqUXVlcnkpO1xcbid1c2Ugc3RyaWN0JztcXG5cXG4hZnVuY3Rpb24gKCQpIHtcXG5cXG4gIC8vIERlZmF1bHQgc2V0IG9mIG1lZGlhIHF1ZXJpZXNcXG4gIHZhciBkZWZhdWx0UXVlcmllcyA9IHtcXG4gICAgJ2RlZmF1bHQnOiAnb25seSBzY3JlZW4nLFxcbiAgICBsYW5kc2NhcGU6ICdvbmx5IHNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBsYW5kc2NhcGUpJyxcXG4gICAgcG9ydHJhaXQ6ICdvbmx5IHNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOiBwb3J0cmFpdCknLFxcbiAgICByZXRpbmE6ICdvbmx5IHNjcmVlbiBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMiksJyArICdvbmx5IHNjcmVlbiBhbmQgKG1pbi0tbW96LWRldmljZS1waXhlbC1yYXRpbzogMiksJyArICdvbmx5IHNjcmVlbiBhbmQgKC1vLW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIvMSksJyArICdvbmx5IHNjcmVlbiBhbmQgKG1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCcgKyAnb25seSBzY3JlZW4gYW5kIChtaW4tcmVzb2x1dGlvbjogMTkyZHBpKSwnICsgJ29ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDJkcHB4KSdcXG4gIH07XFxuXFxuICB2YXIgTWVkaWFRdWVyeSA9IHtcXG4gICAgcXVlcmllczogW10sXFxuXFxuICAgIGN1cnJlbnQ6ICcnLFxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIG1lZGlhIHF1ZXJ5IGhlbHBlciwgYnkgZXh0cmFjdGluZyB0aGUgYnJlYWtwb2ludCBsaXN0IGZyb20gdGhlIENTUyBhbmQgYWN0aXZhdGluZyB0aGUgYnJlYWtwb2ludCB3YXRjaGVyLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuICAgIF9pbml0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgICAgIHZhciBleHRyYWN0ZWRTdHlsZXMgPSAkKCcuZm91bmRhdGlvbi1tcScpLmNzcygnZm9udC1mYW1pbHknKTtcXG4gICAgICB2YXIgbmFtZWRRdWVyaWVzO1xcblxcbiAgICAgIG5hbWVkUXVlcmllcyA9IHBhcnNlU3R5bGVUb09iamVjdChleHRyYWN0ZWRTdHlsZXMpO1xcblxcbiAgICAgIGZvciAodmFyIGtleSBpbiBuYW1lZFF1ZXJpZXMpIHtcXG4gICAgICAgIGlmIChuYW1lZFF1ZXJpZXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICAgICAgICBzZWxmLnF1ZXJpZXMucHVzaCh7XFxuICAgICAgICAgICAgbmFtZToga2V5LFxcbiAgICAgICAgICAgIHZhbHVlOiAnb25seSBzY3JlZW4gYW5kIChtaW4td2lkdGg6ICcgKyBuYW1lZFF1ZXJpZXNba2V5XSArICcpJ1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgdGhpcy5jdXJyZW50ID0gdGhpcy5fZ2V0Q3VycmVudFNpemUoKTtcXG5cXG4gICAgICB0aGlzLl93YXRjaGVyKCk7XFxuICAgIH0sXFxuXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDaGVja3MgaWYgdGhlIHNjcmVlbiBpcyBhdCBsZWFzdCBhcyB3aWRlIGFzIGEgYnJlYWtwb2ludC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXplIC0gTmFtZSBvZiB0aGUgYnJlYWtwb2ludCB0byBjaGVjay5cXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgYnJlYWtwb2ludCBtYXRjaGVzLCBgZmFsc2VgIGlmIGl0J3Mgc21hbGxlci5cXG4gICAgICovXFxuICAgIGF0TGVhc3Q6IGZ1bmN0aW9uIChzaXplKSB7XFxuICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5nZXQoc2l6ZSk7XFxuXFxuICAgICAgaWYgKHF1ZXJ5KSB7XFxuICAgICAgICByZXR1cm4gd2luZG93Lm1hdGNoTWVkaWEocXVlcnkpLm1hdGNoZXM7XFxuICAgICAgfVxcblxcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfSxcXG5cXG5cXG4gICAgLyoqXFxuICAgICAqIEdldHMgdGhlIG1lZGlhIHF1ZXJ5IG9mIGEgYnJlYWtwb2ludC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzaXplIC0gTmFtZSBvZiB0aGUgYnJlYWtwb2ludCB0byBnZXQuXFxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd8bnVsbH0gLSBUaGUgbWVkaWEgcXVlcnkgb2YgdGhlIGJyZWFrcG9pbnQsIG9yIGBudWxsYCBpZiB0aGUgYnJlYWtwb2ludCBkb2Vzbid0IGV4aXN0LlxcbiAgICAgKi9cXG4gICAgZ2V0OiBmdW5jdGlvbiAoc2l6ZSkge1xcbiAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5xdWVyaWVzKSB7XFxuICAgICAgICBpZiAodGhpcy5xdWVyaWVzLmhhc093blByb3BlcnR5KGkpKSB7XFxuICAgICAgICAgIHZhciBxdWVyeSA9IHRoaXMucXVlcmllc1tpXTtcXG4gICAgICAgICAgaWYgKHNpemUgPT09IHF1ZXJ5Lm5hbWUpIHJldHVybiBxdWVyeS52YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH0sXFxuXFxuXFxuICAgIC8qKlxcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IGJyZWFrcG9pbnQgbmFtZSBieSB0ZXN0aW5nIGV2ZXJ5IGJyZWFrcG9pbnQgYW5kIHJldHVybmluZyB0aGUgbGFzdCBvbmUgdG8gbWF0Y2ggKHRoZSBiaWdnZXN0IG9uZSkuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBOYW1lIG9mIHRoZSBjdXJyZW50IGJyZWFrcG9pbnQuXFxuICAgICAqL1xcbiAgICBfZ2V0Q3VycmVudFNpemU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICB2YXIgbWF0Y2hlZDtcXG5cXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucXVlcmllcy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgdmFyIHF1ZXJ5ID0gdGhpcy5xdWVyaWVzW2ldO1xcblxcbiAgICAgICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKHF1ZXJ5LnZhbHVlKS5tYXRjaGVzKSB7XFxuICAgICAgICAgIG1hdGNoZWQgPSBxdWVyeTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgaWYgKHR5cGVvZiBtYXRjaGVkID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgcmV0dXJuIG1hdGNoZWQubmFtZTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIG1hdGNoZWQ7XFxuICAgICAgfVxcbiAgICB9LFxcblxcblxcbiAgICAvKipcXG4gICAgICogQWN0aXZhdGVzIHRoZSBicmVha3BvaW50IHdhdGNoZXIsIHdoaWNoIGZpcmVzIGFuIGV2ZW50IG9uIHRoZSB3aW5kb3cgd2hlbmV2ZXIgdGhlIGJyZWFrcG9pbnQgY2hhbmdlcy5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcbiAgICBfd2F0Y2hlcjogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgJCh3aW5kb3cpLm9uKCdyZXNpemUuemYubWVkaWFxdWVyeScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBuZXdTaXplID0gX3RoaXMuX2dldEN1cnJlbnRTaXplKCksXFxuICAgICAgICAgICAgY3VycmVudFNpemUgPSBfdGhpcy5jdXJyZW50O1xcblxcbiAgICAgICAgaWYgKG5ld1NpemUgIT09IGN1cnJlbnRTaXplKSB7XFxuICAgICAgICAgIC8vIENoYW5nZSB0aGUgY3VycmVudCBtZWRpYSBxdWVyeVxcbiAgICAgICAgICBfdGhpcy5jdXJyZW50ID0gbmV3U2l6ZTtcXG5cXG4gICAgICAgICAgLy8gQnJvYWRjYXN0IHRoZSBtZWRpYSBxdWVyeSBjaGFuZ2Ugb24gdGhlIHdpbmRvd1xcbiAgICAgICAgICAkKHdpbmRvdykudHJpZ2dlcignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgW25ld1NpemUsIGN1cnJlbnRTaXplXSk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH07XFxuXFxuICBGb3VuZGF0aW9uLk1lZGlhUXVlcnkgPSBNZWRpYVF1ZXJ5O1xcblxcbiAgLy8gbWF0Y2hNZWRpYSgpIHBvbHlmaWxsIC0gVGVzdCBhIENTUyBtZWRpYSB0eXBlL3F1ZXJ5IGluIEpTLlxcbiAgLy8gQXV0aG9ycyAmIGNvcHlyaWdodCAoYykgMjAxMjogU2NvdHQgSmVobCwgUGF1bCBJcmlzaCwgTmljaG9sYXMgWmFrYXMsIERhdmlkIEtuaWdodC4gRHVhbCBNSVQvQlNEIGxpY2Vuc2VcXG4gIHdpbmRvdy5tYXRjaE1lZGlhIHx8ICh3aW5kb3cubWF0Y2hNZWRpYSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgJ3VzZSBzdHJpY3QnO1xcblxcbiAgICAvLyBGb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IG1hdGNoTWVkaXVtIGFwaSBzdWNoIGFzIElFIDkgYW5kIHdlYmtpdFxcblxcbiAgICB2YXIgc3R5bGVNZWRpYSA9IHdpbmRvdy5zdHlsZU1lZGlhIHx8IHdpbmRvdy5tZWRpYTtcXG5cXG4gICAgLy8gRm9yIHRob3NlIHRoYXQgZG9uJ3Qgc3VwcG9ydCBtYXRjaE1lZGl1bVxcbiAgICBpZiAoIXN0eWxlTWVkaWEpIHtcXG4gICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpLFxcbiAgICAgICAgICBzY3JpcHQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF0sXFxuICAgICAgICAgIGluZm8gPSBudWxsO1xcblxcbiAgICAgIHN0eWxlLnR5cGUgPSAndGV4dC9jc3MnO1xcbiAgICAgIHN0eWxlLmlkID0gJ21hdGNobWVkaWFqcy10ZXN0JztcXG5cXG4gICAgICBzY3JpcHQucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoc3R5bGUsIHNjcmlwdCk7XFxuXFxuICAgICAgLy8gJ3N0eWxlLmN1cnJlbnRTdHlsZScgaXMgdXNlZCBieSBJRSA8PSA4IGFuZCAnd2luZG93LmdldENvbXB1dGVkU3R5bGUnIGZvciBhbGwgb3RoZXIgYnJvd3NlcnNcXG4gICAgICBpbmZvID0gJ2dldENvbXB1dGVkU3R5bGUnIGluIHdpbmRvdyAmJiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShzdHlsZSwgbnVsbCkgfHwgc3R5bGUuY3VycmVudFN0eWxlO1xcblxcbiAgICAgIHN0eWxlTWVkaWEgPSB7XFxuICAgICAgICBtYXRjaE1lZGl1bTogZnVuY3Rpb24gKG1lZGlhKSB7XFxuICAgICAgICAgIHZhciB0ZXh0ID0gJ0BtZWRpYSAnICsgbWVkaWEgKyAneyAjbWF0Y2htZWRpYWpzLXRlc3QgeyB3aWR0aDogMXB4OyB9IH0nO1xcblxcbiAgICAgICAgICAvLyAnc3R5bGUuc3R5bGVTaGVldCcgaXMgdXNlZCBieSBJRSA8PSA4IGFuZCAnc3R5bGUudGV4dENvbnRlbnQnIGZvciBhbGwgb3RoZXIgYnJvd3NlcnNcXG4gICAgICAgICAgaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcXG4gICAgICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSB0ZXh0O1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHN0eWxlLnRleHRDb250ZW50ID0gdGV4dDtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICAvLyBUZXN0IGlmIG1lZGlhIHF1ZXJ5IGlzIHRydWUgb3IgZmFsc2VcXG4gICAgICAgICAgcmV0dXJuIGluZm8ud2lkdGggPT09ICcxcHgnO1xcbiAgICAgICAgfVxcbiAgICAgIH07XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZWRpYSkge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBtYXRjaGVzOiBzdHlsZU1lZGlhLm1hdGNoTWVkaXVtKG1lZGlhIHx8ICdhbGwnKSxcXG4gICAgICAgIG1lZGlhOiBtZWRpYSB8fCAnYWxsJ1xcbiAgICAgIH07XFxuICAgIH07XFxuICB9KCkpO1xcblxcbiAgLy8gVGhhbmsgeW91OiBodHRwczovL2dpdGh1Yi5jb20vc2luZHJlc29yaHVzL3F1ZXJ5LXN0cmluZ1xcbiAgZnVuY3Rpb24gcGFyc2VTdHlsZVRvT2JqZWN0KHN0cikge1xcbiAgICB2YXIgc3R5bGVPYmplY3QgPSB7fTtcXG5cXG4gICAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xcbiAgICB9XFxuXFxuICAgIHN0ciA9IHN0ci50cmltKCkuc2xpY2UoMSwgLTEpOyAvLyBicm93c2VycyByZS1xdW90ZSBzdHJpbmcgc3R5bGUgdmFsdWVzXFxuXFxuICAgIGlmICghc3RyKSB7XFxuICAgICAgcmV0dXJuIHN0eWxlT2JqZWN0O1xcbiAgICB9XFxuXFxuICAgIHN0eWxlT2JqZWN0ID0gc3RyLnNwbGl0KCcmJykucmVkdWNlKGZ1bmN0aW9uIChyZXQsIHBhcmFtKSB7XFxuICAgICAgdmFyIHBhcnRzID0gcGFyYW0ucmVwbGFjZSgvXFxcXCsvZywgJyAnKS5zcGxpdCgnPScpO1xcbiAgICAgIHZhciBrZXkgPSBwYXJ0c1swXTtcXG4gICAgICB2YXIgdmFsID0gcGFydHNbMV07XFxuICAgICAga2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KGtleSk7XFxuXFxuICAgICAgLy8gbWlzc2luZyBgPWAgc2hvdWxkIGJlIGBudWxsYDpcXG4gICAgICAvLyBodHRwOi8vdzMub3JnL1RSLzIwMTIvV0QtdXJsLTIwMTIwNTI0LyNjb2xsZWN0LXVybC1wYXJhbWV0ZXJzXFxuICAgICAgdmFsID0gdmFsID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVjb2RlVVJJQ29tcG9uZW50KHZhbCk7XFxuXFxuICAgICAgaWYgKCFyZXQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICAgICAgcmV0W2tleV0gPSB2YWw7XFxuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJldFtrZXldKSkge1xcbiAgICAgICAgcmV0W2tleV0ucHVzaCh2YWwpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXRba2V5XSA9IFtyZXRba2V5XSwgdmFsXTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIHJldDtcXG4gICAgfSwge30pO1xcblxcbiAgICByZXR1cm4gc3R5bGVPYmplY3Q7XFxuICB9XFxuXFxuICBGb3VuZGF0aW9uLk1lZGlhUXVlcnkgPSBNZWRpYVF1ZXJ5O1xcbn0oalF1ZXJ5KTtcXG4ndXNlIHN0cmljdCc7XFxuXFxuIWZ1bmN0aW9uICgkKSB7XFxuXFxuICAvKipcXG4gICAqIE1vdGlvbiBtb2R1bGUuXFxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24ubW90aW9uXFxuICAgKi9cXG5cXG4gIHZhciBpbml0Q2xhc3NlcyA9IFsnbXVpLWVudGVyJywgJ211aS1sZWF2ZSddO1xcbiAgdmFyIGFjdGl2ZUNsYXNzZXMgPSBbJ211aS1lbnRlci1hY3RpdmUnLCAnbXVpLWxlYXZlLWFjdGl2ZSddO1xcblxcbiAgdmFyIE1vdGlvbiA9IHtcXG4gICAgYW5pbWF0ZUluOiBmdW5jdGlvbiAoZWxlbWVudCwgYW5pbWF0aW9uLCBjYikge1xcbiAgICAgIGFuaW1hdGUodHJ1ZSwgZWxlbWVudCwgYW5pbWF0aW9uLCBjYik7XFxuICAgIH0sXFxuXFxuICAgIGFuaW1hdGVPdXQ6IGZ1bmN0aW9uIChlbGVtZW50LCBhbmltYXRpb24sIGNiKSB7XFxuICAgICAgYW5pbWF0ZShmYWxzZSwgZWxlbWVudCwgYW5pbWF0aW9uLCBjYik7XFxuICAgIH1cXG4gIH07XFxuXFxuICBmdW5jdGlvbiBNb3ZlKGR1cmF0aW9uLCBlbGVtLCBmbikge1xcbiAgICB2YXIgYW5pbSxcXG4gICAgICAgIHByb2csXFxuICAgICAgICBzdGFydCA9IG51bGw7XFxuICAgIC8vIGNvbnNvbGUubG9nKCdjYWxsZWQnKTtcXG5cXG4gICAgZnVuY3Rpb24gbW92ZSh0cykge1xcbiAgICAgIGlmICghc3RhcnQpIHN0YXJ0ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xcbiAgICAgIC8vIGNvbnNvbGUubG9nKHN0YXJ0LCB0cyk7XFxuICAgICAgcHJvZyA9IHRzIC0gc3RhcnQ7XFxuICAgICAgZm4uYXBwbHkoZWxlbSk7XFxuXFxuICAgICAgaWYgKHByb2cgPCBkdXJhdGlvbikge1xcbiAgICAgICAgYW5pbSA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobW92ZSwgZWxlbSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZShhbmltKTtcXG4gICAgICAgIGVsZW0udHJpZ2dlcignZmluaXNoZWQuemYuYW5pbWF0ZScsIFtlbGVtXSkudHJpZ2dlckhhbmRsZXIoJ2ZpbmlzaGVkLnpmLmFuaW1hdGUnLCBbZWxlbV0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBhbmltID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShtb3ZlKTtcXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogQW5pbWF0ZXMgYW4gZWxlbWVudCBpbiBvciBvdXQgdXNpbmcgYSBDU1MgdHJhbnNpdGlvbiBjbGFzcy5cXG4gICAqIEBmdW5jdGlvblxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNJbiAtIERlZmluZXMgaWYgdGhlIGFuaW1hdGlvbiBpcyBpbiBvciBvdXQuXFxuICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvciBIVE1MIG9iamVjdCB0byBhbmltYXRlLlxcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFuaW1hdGlvbiAtIENTUyBjbGFzcyB0byB1c2UuXFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIENhbGxiYWNrIHRvIHJ1biB3aGVuIGFuaW1hdGlvbiBpcyBmaW5pc2hlZC5cXG4gICAqL1xcbiAgZnVuY3Rpb24gYW5pbWF0ZShpc0luLCBlbGVtZW50LCBhbmltYXRpb24sIGNiKSB7XFxuICAgIGVsZW1lbnQgPSAkKGVsZW1lbnQpLmVxKDApO1xcblxcbiAgICBpZiAoIWVsZW1lbnQubGVuZ3RoKSByZXR1cm47XFxuXFxuICAgIHZhciBpbml0Q2xhc3MgPSBpc0luID8gaW5pdENsYXNzZXNbMF0gOiBpbml0Q2xhc3Nlc1sxXTtcXG4gICAgdmFyIGFjdGl2ZUNsYXNzID0gaXNJbiA/IGFjdGl2ZUNsYXNzZXNbMF0gOiBhY3RpdmVDbGFzc2VzWzFdO1xcblxcbiAgICAvLyBTZXQgdXAgdGhlIGFuaW1hdGlvblxcbiAgICByZXNldCgpO1xcblxcbiAgICBlbGVtZW50LmFkZENsYXNzKGFuaW1hdGlvbikuY3NzKCd0cmFuc2l0aW9uJywgJ25vbmUnKTtcXG5cXG4gICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcXG4gICAgICBlbGVtZW50LmFkZENsYXNzKGluaXRDbGFzcyk7XFxuICAgICAgaWYgKGlzSW4pIGVsZW1lbnQuc2hvdygpO1xcbiAgICB9KTtcXG5cXG4gICAgLy8gU3RhcnQgdGhlIGFuaW1hdGlvblxcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xcbiAgICAgIGVsZW1lbnRbMF0ub2Zmc2V0V2lkdGg7XFxuICAgICAgZWxlbWVudC5jc3MoJ3RyYW5zaXRpb24nLCAnJykuYWRkQ2xhc3MoYWN0aXZlQ2xhc3MpO1xcbiAgICB9KTtcXG5cXG4gICAgLy8gQ2xlYW4gdXAgdGhlIGFuaW1hdGlvbiB3aGVuIGl0IGZpbmlzaGVzXFxuICAgIGVsZW1lbnQub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZChlbGVtZW50KSwgZmluaXNoKTtcXG5cXG4gICAgLy8gSGlkZXMgdGhlIGVsZW1lbnQgKGZvciBvdXQgYW5pbWF0aW9ucyksIHJlc2V0cyB0aGUgZWxlbWVudCwgYW5kIHJ1bnMgYSBjYWxsYmFja1xcbiAgICBmdW5jdGlvbiBmaW5pc2goKSB7XFxuICAgICAgaWYgKCFpc0luKSBlbGVtZW50LmhpZGUoKTtcXG4gICAgICByZXNldCgpO1xcbiAgICAgIGlmIChjYikgY2IuYXBwbHkoZWxlbWVudCk7XFxuICAgIH1cXG5cXG4gICAgLy8gUmVzZXRzIHRyYW5zaXRpb25zIGFuZCByZW1vdmVzIG1vdGlvbi1zcGVjaWZpYyBjbGFzc2VzXFxuICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xcbiAgICAgIGVsZW1lbnRbMF0uc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gMDtcXG4gICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKGluaXRDbGFzcyArICcgJyArIGFjdGl2ZUNsYXNzICsgJyAnICsgYW5pbWF0aW9uKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgRm91bmRhdGlvbi5Nb3ZlID0gTW92ZTtcXG4gIEZvdW5kYXRpb24uTW90aW9uID0gTW90aW9uO1xcbn0oalF1ZXJ5KTtcXG4ndXNlIHN0cmljdCc7XFxuXFxuIWZ1bmN0aW9uICgkKSB7XFxuXFxuICB2YXIgTmVzdCA9IHtcXG4gICAgRmVhdGhlcjogZnVuY3Rpb24gKG1lbnUpIHtcXG4gICAgICB2YXIgdHlwZSA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMSB8fCBhcmd1bWVudHNbMV0gPT09IHVuZGVmaW5lZCA/ICd6ZicgOiBhcmd1bWVudHNbMV07XFxuXFxuICAgICAgbWVudS5hdHRyKCdyb2xlJywgJ21lbnViYXInKTtcXG5cXG4gICAgICB2YXIgaXRlbXMgPSBtZW51LmZpbmQoJ2xpJykuYXR0cih7ICdyb2xlJzogJ21lbnVpdGVtJyB9KSxcXG4gICAgICAgICAgc3ViTWVudUNsYXNzID0gJ2lzLScgKyB0eXBlICsgJy1zdWJtZW51JyxcXG4gICAgICAgICAgc3ViSXRlbUNsYXNzID0gc3ViTWVudUNsYXNzICsgJy1pdGVtJyxcXG4gICAgICAgICAgaGFzU3ViQ2xhc3MgPSAnaXMtJyArIHR5cGUgKyAnLXN1Ym1lbnUtcGFyZW50JztcXG5cXG4gICAgICBtZW51LmZpbmQoJ2E6Zmlyc3QnKS5hdHRyKCd0YWJpbmRleCcsIDApO1xcblxcbiAgICAgIGl0ZW1zLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyICRpdGVtID0gJCh0aGlzKSxcXG4gICAgICAgICAgICAkc3ViID0gJGl0ZW0uY2hpbGRyZW4oJ3VsJyk7XFxuXFxuICAgICAgICBpZiAoJHN1Yi5sZW5ndGgpIHtcXG4gICAgICAgICAgJGl0ZW0uYWRkQ2xhc3MoaGFzU3ViQ2xhc3MpLmF0dHIoe1xcbiAgICAgICAgICAgICdhcmlhLWhhc3BvcHVwJzogdHJ1ZSxcXG4gICAgICAgICAgICAnYXJpYS1leHBhbmRlZCc6IGZhbHNlLFxcbiAgICAgICAgICAgICdhcmlhLWxhYmVsJzogJGl0ZW0uY2hpbGRyZW4oJ2E6Zmlyc3QnKS50ZXh0KClcXG4gICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICRzdWIuYWRkQ2xhc3MoJ3N1Ym1lbnUgJyArIHN1Yk1lbnVDbGFzcykuYXR0cih7XFxuICAgICAgICAgICAgJ2RhdGEtc3VibWVudSc6ICcnLFxcbiAgICAgICAgICAgICdhcmlhLWhpZGRlbic6IHRydWUsXFxuICAgICAgICAgICAgJ3JvbGUnOiAnbWVudSdcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoJGl0ZW0ucGFyZW50KCdbZGF0YS1zdWJtZW51XScpLmxlbmd0aCkge1xcbiAgICAgICAgICAkaXRlbS5hZGRDbGFzcygnaXMtc3VibWVudS1pdGVtICcgKyBzdWJJdGVtQ2xhc3MpO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcblxcbiAgICAgIHJldHVybjtcXG4gICAgfSxcXG4gICAgQnVybjogZnVuY3Rpb24gKG1lbnUsIHR5cGUpIHtcXG4gICAgICB2YXIgaXRlbXMgPSBtZW51LmZpbmQoJ2xpJykucmVtb3ZlQXR0cigndGFiaW5kZXgnKSxcXG4gICAgICAgICAgc3ViTWVudUNsYXNzID0gJ2lzLScgKyB0eXBlICsgJy1zdWJtZW51JyxcXG4gICAgICAgICAgc3ViSXRlbUNsYXNzID0gc3ViTWVudUNsYXNzICsgJy1pdGVtJyxcXG4gICAgICAgICAgaGFzU3ViQ2xhc3MgPSAnaXMtJyArIHR5cGUgKyAnLXN1Ym1lbnUtcGFyZW50JztcXG5cXG4gICAgICBtZW51LmZpbmQoJyonKS5yZW1vdmVDbGFzcyhzdWJNZW51Q2xhc3MgKyAnICcgKyBzdWJJdGVtQ2xhc3MgKyAnICcgKyBoYXNTdWJDbGFzcyArICcgaXMtc3VibWVudS1pdGVtIHN1Ym1lbnUgaXMtYWN0aXZlJykucmVtb3ZlQXR0cignZGF0YS1zdWJtZW51JykuY3NzKCdkaXNwbGF5JywgJycpO1xcblxcbiAgICAgIC8vIGNvbnNvbGUubG9nKCAgICAgIG1lbnUuZmluZCgnLicgKyBzdWJNZW51Q2xhc3MgKyAnLCAuJyArIHN1Ykl0ZW1DbGFzcyArICcsIC5oYXMtc3VibWVudSwgLmlzLXN1Ym1lbnUtaXRlbSwgLnN1Ym1lbnUsIFtkYXRhLXN1Ym1lbnVdJylcXG4gICAgICAvLyAgICAgICAgICAgLnJlbW92ZUNsYXNzKHN1Yk1lbnVDbGFzcyArICcgJyArIHN1Ykl0ZW1DbGFzcyArICcgaGFzLXN1Ym1lbnUgaXMtc3VibWVudS1pdGVtIHN1Ym1lbnUnKVxcbiAgICAgIC8vICAgICAgICAgICAucmVtb3ZlQXR0cignZGF0YS1zdWJtZW51JykpO1xcbiAgICAgIC8vIGl0ZW1zLmVhY2goZnVuY3Rpb24oKXtcXG4gICAgICAvLyAgIHZhciAkaXRlbSA9ICQodGhpcyksXFxuICAgICAgLy8gICAgICAgJHN1YiA9ICRpdGVtLmNoaWxkcmVuKCd1bCcpO1xcbiAgICAgIC8vICAgaWYoJGl0ZW0ucGFyZW50KCdbZGF0YS1zdWJtZW51XScpLmxlbmd0aCl7XFxuICAgICAgLy8gICAgICRpdGVtLnJlbW92ZUNsYXNzKCdpcy1zdWJtZW51LWl0ZW0gJyArIHN1Ykl0ZW1DbGFzcyk7XFxuICAgICAgLy8gICB9XFxuICAgICAgLy8gICBpZigkc3ViLmxlbmd0aCl7XFxuICAgICAgLy8gICAgICRpdGVtLnJlbW92ZUNsYXNzKCdoYXMtc3VibWVudScpO1xcbiAgICAgIC8vICAgICAkc3ViLnJlbW92ZUNsYXNzKCdzdWJtZW51ICcgKyBzdWJNZW51Q2xhc3MpLnJlbW92ZUF0dHIoJ2RhdGEtc3VibWVudScpO1xcbiAgICAgIC8vICAgfVxcbiAgICAgIC8vIH0pO1xcbiAgICB9XFxuICB9O1xcblxcbiAgRm91bmRhdGlvbi5OZXN0ID0gTmVzdDtcXG59KGpRdWVyeSk7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbiFmdW5jdGlvbiAoJCkge1xcblxcbiAgZnVuY3Rpb24gVGltZXIoZWxlbSwgb3B0aW9ucywgY2IpIHtcXG4gICAgdmFyIF90aGlzID0gdGhpcyxcXG4gICAgICAgIGR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbixcXG4gICAgICAgIC8vb3B0aW9ucyBpcyBhbiBvYmplY3QgZm9yIGVhc2lseSBhZGRpbmcgZmVhdHVyZXMgbGF0ZXIuXFxuICAgIG5hbWVTcGFjZSA9IE9iamVjdC5rZXlzKGVsZW0uZGF0YSgpKVswXSB8fCAndGltZXInLFxcbiAgICAgICAgcmVtYWluID0gLTEsXFxuICAgICAgICBzdGFydCxcXG4gICAgICAgIHRpbWVyO1xcblxcbiAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XFxuXFxuICAgIHRoaXMucmVzdGFydCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZW1haW4gPSAtMTtcXG4gICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xcbiAgICAgIHRoaXMuc3RhcnQoKTtcXG4gICAgfTtcXG5cXG4gICAgdGhpcy5zdGFydCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICB0aGlzLmlzUGF1c2VkID0gZmFsc2U7XFxuICAgICAgLy8gaWYoIWVsZW0uZGF0YSgncGF1c2VkJykpeyByZXR1cm4gZmFsc2U7IH0vL21heWJlIGltcGxlbWVudCB0aGlzIHNhbml0eSBjaGVjayBpZiB1c2VkIGZvciBvdGhlciB0aGluZ3MuXFxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcXG4gICAgICByZW1haW4gPSByZW1haW4gPD0gMCA/IGR1cmF0aW9uIDogcmVtYWluO1xcbiAgICAgIGVsZW0uZGF0YSgncGF1c2VkJywgZmFsc2UpO1xcbiAgICAgIHN0YXJ0ID0gRGF0ZS5ub3coKTtcXG4gICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKG9wdGlvbnMuaW5maW5pdGUpIHtcXG4gICAgICAgICAgX3RoaXMucmVzdGFydCgpOyAvL3JlcnVuIHRoZSB0aW1lci5cXG4gICAgICAgIH1cXG4gICAgICAgIGNiKCk7XFxuICAgICAgfSwgcmVtYWluKTtcXG4gICAgICBlbGVtLnRyaWdnZXIoJ3RpbWVyc3RhcnQuemYuJyArIG5hbWVTcGFjZSk7XFxuICAgIH07XFxuXFxuICAgIHRoaXMucGF1c2UgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgdGhpcy5pc1BhdXNlZCA9IHRydWU7XFxuICAgICAgLy9pZihlbGVtLmRhdGEoJ3BhdXNlZCcpKXsgcmV0dXJuIGZhbHNlOyB9Ly9tYXliZSBpbXBsZW1lbnQgdGhpcyBzYW5pdHkgY2hlY2sgaWYgdXNlZCBmb3Igb3RoZXIgdGhpbmdzLlxcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XFxuICAgICAgZWxlbS5kYXRhKCdwYXVzZWQnLCB0cnVlKTtcXG4gICAgICB2YXIgZW5kID0gRGF0ZS5ub3coKTtcXG4gICAgICByZW1haW4gPSByZW1haW4gLSAoZW5kIC0gc3RhcnQpO1xcbiAgICAgIGVsZW0udHJpZ2dlcigndGltZXJwYXVzZWQuemYuJyArIG5hbWVTcGFjZSk7XFxuICAgIH07XFxuICB9XFxuXFxuICAvKipcXG4gICAqIFJ1bnMgYSBjYWxsYmFjayBmdW5jdGlvbiB3aGVuIGltYWdlcyBhcmUgZnVsbHkgbG9hZGVkLlxcbiAgICogQHBhcmFtIHtPYmplY3R9IGltYWdlcyAtIEltYWdlKHMpIHRvIGNoZWNrIGlmIGxvYWRlZC5cXG4gICAqIEBwYXJhbSB7RnVuY30gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gaW1hZ2UgaXMgZnVsbHkgbG9hZGVkLlxcbiAgICovXFxuICBmdW5jdGlvbiBvbkltYWdlc0xvYWRlZChpbWFnZXMsIGNhbGxiYWNrKSB7XFxuICAgIHZhciBzZWxmID0gdGhpcyxcXG4gICAgICAgIHVubG9hZGVkID0gaW1hZ2VzLmxlbmd0aDtcXG5cXG4gICAgaWYgKHVubG9hZGVkID09PSAwKSB7XFxuICAgICAgY2FsbGJhY2soKTtcXG4gICAgfVxcblxcbiAgICBpbWFnZXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgaWYgKHRoaXMuY29tcGxldGUpIHtcXG4gICAgICAgIHNpbmdsZUltYWdlTG9hZGVkKCk7XFxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5uYXR1cmFsV2lkdGggIT09ICd1bmRlZmluZWQnICYmIHRoaXMubmF0dXJhbFdpZHRoID4gMCkge1xcbiAgICAgICAgc2luZ2xlSW1hZ2VMb2FkZWQoKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgJCh0aGlzKS5vbmUoJ2xvYWQnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHNpbmdsZUltYWdlTG9hZGVkKCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuICAgIH0pO1xcblxcbiAgICBmdW5jdGlvbiBzaW5nbGVJbWFnZUxvYWRlZCgpIHtcXG4gICAgICB1bmxvYWRlZC0tO1xcbiAgICAgIGlmICh1bmxvYWRlZCA9PT0gMCkge1xcbiAgICAgICAgY2FsbGJhY2soKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIEZvdW5kYXRpb24uVGltZXIgPSBUaW1lcjtcXG4gIEZvdW5kYXRpb24ub25JbWFnZXNMb2FkZWQgPSBvbkltYWdlc0xvYWRlZDtcXG59KGpRdWVyeSk7XFxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbi8vKipXb3JrIGluc3BpcmVkIGJ5IG11bHRpcGxlIGpxdWVyeSBzd2lwZSBwbHVnaW5zKipcXG4vLyoqRG9uZSBieSBZb2hhaSBBcmFyYXQgKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxuLy8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbihmdW5jdGlvbiAoJCkge1xcblxcblxcdCQuc3BvdFN3aXBlID0ge1xcblxcdFxcdHZlcnNpb246ICcxLjAuMCcsXFxuXFx0XFx0ZW5hYmxlZDogJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxcblxcdFxcdHByZXZlbnREZWZhdWx0OiBmYWxzZSxcXG5cXHRcXHRtb3ZlVGhyZXNob2xkOiA3NSxcXG5cXHRcXHR0aW1lVGhyZXNob2xkOiAyMDBcXG5cXHR9O1xcblxcblxcdHZhciBzdGFydFBvc1gsXFxuXFx0ICAgIHN0YXJ0UG9zWSxcXG5cXHQgICAgc3RhcnRUaW1lLFxcblxcdCAgICBlbGFwc2VkVGltZSxcXG5cXHQgICAgaXNNb3ZpbmcgPSBmYWxzZTtcXG5cXG5cXHRmdW5jdGlvbiBvblRvdWNoRW5kKCkge1xcblxcdFxcdC8vICBhbGVydCh0aGlzKTtcXG5cXHRcXHR0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlKTtcXG5cXHRcXHR0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgb25Ub3VjaEVuZCk7XFxuXFx0XFx0aXNNb3ZpbmcgPSBmYWxzZTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gb25Ub3VjaE1vdmUoZSkge1xcblxcdFxcdGlmICgkLnNwb3RTd2lwZS5wcmV2ZW50RGVmYXVsdCkge1xcblxcdFxcdFxcdGUucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHR9XFxuXFx0XFx0aWYgKGlzTW92aW5nKSB7XFxuXFx0XFx0XFx0dmFyIHggPSBlLnRvdWNoZXNbMF0ucGFnZVg7XFxuXFx0XFx0XFx0dmFyIHkgPSBlLnRvdWNoZXNbMF0ucGFnZVk7XFxuXFx0XFx0XFx0dmFyIGR4ID0gc3RhcnRQb3NYIC0geDtcXG5cXHRcXHRcXHR2YXIgZHkgPSBzdGFydFBvc1kgLSB5O1xcblxcdFxcdFxcdHZhciBkaXI7XFxuXFx0XFx0XFx0ZWxhcHNlZFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHN0YXJ0VGltZTtcXG5cXHRcXHRcXHRpZiAoTWF0aC5hYnMoZHgpID49ICQuc3BvdFN3aXBlLm1vdmVUaHJlc2hvbGQgJiYgZWxhcHNlZFRpbWUgPD0gJC5zcG90U3dpcGUudGltZVRocmVzaG9sZCkge1xcblxcdFxcdFxcdFxcdGRpciA9IGR4ID4gMCA/ICdsZWZ0JyA6ICdyaWdodCc7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdC8vIGVsc2UgaWYoTWF0aC5hYnMoZHkpID49ICQuc3BvdFN3aXBlLm1vdmVUaHJlc2hvbGQgJiYgZWxhcHNlZFRpbWUgPD0gJC5zcG90U3dpcGUudGltZVRocmVzaG9sZCkge1xcblxcdFxcdFxcdC8vICAgZGlyID0gZHkgPiAwID8gJ2Rvd24nIDogJ3VwJztcXG5cXHRcXHRcXHQvLyB9XFxuXFx0XFx0XFx0aWYgKGRpcikge1xcblxcdFxcdFxcdFxcdGUucHJldmVudERlZmF1bHQoKTtcXG5cXHRcXHRcXHRcXHRvblRvdWNoRW5kLmNhbGwodGhpcyk7XFxuXFx0XFx0XFx0XFx0JCh0aGlzKS50cmlnZ2VyKCdzd2lwZScsIGRpcikudHJpZ2dlcignc3dpcGUnICsgZGlyKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBvblRvdWNoU3RhcnQoZSkge1xcblxcdFxcdGlmIChlLnRvdWNoZXMubGVuZ3RoID09IDEpIHtcXG5cXHRcXHRcXHRzdGFydFBvc1ggPSBlLnRvdWNoZXNbMF0ucGFnZVg7XFxuXFx0XFx0XFx0c3RhcnRQb3NZID0gZS50b3VjaGVzWzBdLnBhZ2VZO1xcblxcdFxcdFxcdGlzTW92aW5nID0gdHJ1ZTtcXG5cXHRcXHRcXHRzdGFydFRpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXG5cXHRcXHRcXHR0aGlzLmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIG9uVG91Y2hNb3ZlLCBmYWxzZSk7XFxuXFx0XFx0XFx0dGhpcy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hFbmQsIGZhbHNlKTtcXG5cXHRcXHR9XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGluaXQoKSB7XFxuXFx0XFx0dGhpcy5hZGRFdmVudExpc3RlbmVyICYmIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uVG91Y2hTdGFydCwgZmFsc2UpO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiB0ZWFyZG93bigpIHtcXG5cXHRcXHR0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCBvblRvdWNoU3RhcnQpO1xcblxcdH1cXG5cXG5cXHQkLmV2ZW50LnNwZWNpYWwuc3dpcGUgPSB7IHNldHVwOiBpbml0IH07XFxuXFxuXFx0JC5lYWNoKFsnbGVmdCcsICd1cCcsICdkb3duJywgJ3JpZ2h0J10sIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHQkLmV2ZW50LnNwZWNpYWxbJ3N3aXBlJyArIHRoaXNdID0geyBzZXR1cDogZnVuY3Rpb24gKCkge1xcblxcdFxcdFxcdFxcdCQodGhpcykub24oJ3N3aXBlJywgJC5ub29wKTtcXG5cXHRcXHRcXHR9IH07XFxuXFx0fSk7XFxufSkoalF1ZXJ5KTtcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbiAqIE1ldGhvZCBmb3IgYWRkaW5nIHBzdWVkbyBkcmFnIGV2ZW50cyB0byBlbGVtZW50cyAqXFxuICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cXG4hZnVuY3Rpb24gKCQpIHtcXG5cXHQkLmZuLmFkZFRvdWNoID0gZnVuY3Rpb24gKCkge1xcblxcdFxcdHRoaXMuZWFjaChmdW5jdGlvbiAoaSwgZWwpIHtcXG5cXHRcXHRcXHQkKGVsKS5iaW5kKCd0b3VjaHN0YXJ0IHRvdWNobW92ZSB0b3VjaGVuZCB0b3VjaGNhbmNlbCcsIGZ1bmN0aW9uICgpIHtcXG5cXHRcXHRcXHRcXHQvL3dlIHBhc3MgdGhlIG9yaWdpbmFsIGV2ZW50IG9iamVjdCBiZWNhdXNlIHRoZSBqUXVlcnkgZXZlbnRcXG5cXHRcXHRcXHRcXHQvL29iamVjdCBpcyBub3JtYWxpemVkIHRvIHczYyBzcGVjcyBhbmQgZG9lcyBub3QgcHJvdmlkZSB0aGUgVG91Y2hMaXN0XFxuXFx0XFx0XFx0XFx0aGFuZGxlVG91Y2goZXZlbnQpO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0pO1xcblxcblxcdFxcdHZhciBoYW5kbGVUb3VjaCA9IGZ1bmN0aW9uIChldmVudCkge1xcblxcdFxcdFxcdHZhciB0b3VjaGVzID0gZXZlbnQuY2hhbmdlZFRvdWNoZXMsXFxuXFx0XFx0XFx0ICAgIGZpcnN0ID0gdG91Y2hlc1swXSxcXG5cXHRcXHRcXHQgICAgZXZlbnRUeXBlcyA9IHtcXG5cXHRcXHRcXHRcXHR0b3VjaHN0YXJ0OiAnbW91c2Vkb3duJyxcXG5cXHRcXHRcXHRcXHR0b3VjaG1vdmU6ICdtb3VzZW1vdmUnLFxcblxcdFxcdFxcdFxcdHRvdWNoZW5kOiAnbW91c2V1cCdcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdCAgICB0eXBlID0gZXZlbnRUeXBlc1tldmVudC50eXBlXSxcXG5cXHRcXHRcXHQgICAgc2ltdWxhdGVkRXZlbnQ7XFxuXFxuXFx0XFx0XFx0aWYgKCdNb3VzZUV2ZW50JyBpbiB3aW5kb3cgJiYgdHlwZW9mIHdpbmRvdy5Nb3VzZUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XFxuXFx0XFx0XFx0XFx0c2ltdWxhdGVkRXZlbnQgPSBuZXcgd2luZG93Lk1vdXNlRXZlbnQodHlwZSwge1xcblxcdFxcdFxcdFxcdFxcdCdidWJibGVzJzogdHJ1ZSxcXG5cXHRcXHRcXHRcXHRcXHQnY2FuY2VsYWJsZSc6IHRydWUsXFxuXFx0XFx0XFx0XFx0XFx0J3NjcmVlblgnOiBmaXJzdC5zY3JlZW5YLFxcblxcdFxcdFxcdFxcdFxcdCdzY3JlZW5ZJzogZmlyc3Quc2NyZWVuWSxcXG5cXHRcXHRcXHRcXHRcXHQnY2xpZW50WCc6IGZpcnN0LmNsaWVudFgsXFxuXFx0XFx0XFx0XFx0XFx0J2NsaWVudFknOiBmaXJzdC5jbGllbnRZXFxuXFx0XFx0XFx0XFx0fSk7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRzaW11bGF0ZWRFdmVudCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdNb3VzZUV2ZW50Jyk7XFxuXFx0XFx0XFx0XFx0c2ltdWxhdGVkRXZlbnQuaW5pdE1vdXNlRXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSwgd2luZG93LCAxLCBmaXJzdC5zY3JlZW5YLCBmaXJzdC5zY3JlZW5ZLCBmaXJzdC5jbGllbnRYLCBmaXJzdC5jbGllbnRZLCBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCAvKmxlZnQqLywgbnVsbCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGZpcnN0LnRhcmdldC5kaXNwYXRjaEV2ZW50KHNpbXVsYXRlZEV2ZW50KTtcXG5cXHRcXHR9O1xcblxcdH07XFxufShqUXVlcnkpO1xcblxcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbi8vKipGcm9tIHRoZSBqUXVlcnkgTW9iaWxlIExpYnJhcnkqKlxcbi8vKipuZWVkIHRvIHJlY3JlYXRlIGZ1bmN0aW9uYWxpdHkqKlxcbi8vKiphbmQgdHJ5IHRvIGltcHJvdmUgaWYgcG9zc2libGUqKlxcbi8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcblxcbi8qIFJlbW92aW5nIHRoZSBqUXVlcnkgZnVuY3Rpb24gKioqKlxcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcblxcbihmdW5jdGlvbiggJCwgd2luZG93LCB1bmRlZmluZWQgKSB7XFxuXFxuXFx0dmFyICRkb2N1bWVudCA9ICQoIGRvY3VtZW50ICksXFxuXFx0XFx0Ly8gc3VwcG9ydFRvdWNoID0gJC5tb2JpbGUuc3VwcG9ydC50b3VjaCxcXG5cXHRcXHR0b3VjaFN0YXJ0RXZlbnQgPSAndG91Y2hzdGFydCcvL3N1cHBvcnRUb3VjaCA/IFxcXCJ0b3VjaHN0YXJ0XFxcIiA6IFxcXCJtb3VzZWRvd25cXFwiLFxcblxcdFxcdHRvdWNoU3RvcEV2ZW50ID0gJ3RvdWNoZW5kJy8vc3VwcG9ydFRvdWNoID8gXFxcInRvdWNoZW5kXFxcIiA6IFxcXCJtb3VzZXVwXFxcIixcXG5cXHRcXHR0b3VjaE1vdmVFdmVudCA9ICd0b3VjaG1vdmUnLy9zdXBwb3J0VG91Y2ggPyBcXFwidG91Y2htb3ZlXFxcIiA6IFxcXCJtb3VzZW1vdmVcXFwiO1xcblxcblxcdC8vIHNldHVwIG5ldyBldmVudCBzaG9ydGN1dHNcXG5cXHQkLmVhY2goICggXFxcInRvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIFxcXCIgK1xcblxcdFxcdFxcXCJzd2lwZSBzd2lwZWxlZnQgc3dpcGVyaWdodFxcXCIgKS5zcGxpdCggXFxcIiBcXFwiICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xcblxcblxcdFxcdCQuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcXG5cXHRcXHRcXHRyZXR1cm4gZm4gPyB0aGlzLmJpbmQoIG5hbWUsIGZuICkgOiB0aGlzLnRyaWdnZXIoIG5hbWUgKTtcXG5cXHRcXHR9O1xcblxcblxcdFxcdC8vIGpRdWVyeSA8IDEuOFxcblxcdFxcdGlmICggJC5hdHRyRm4gKSB7XFxuXFx0XFx0XFx0JC5hdHRyRm5bIG5hbWUgXSA9IHRydWU7XFxuXFx0XFx0fVxcblxcdH0pO1xcblxcblxcdGZ1bmN0aW9uIHRyaWdnZXJDdXN0b21FdmVudCggb2JqLCBldmVudFR5cGUsIGV2ZW50LCBidWJibGUgKSB7XFxuXFx0XFx0dmFyIG9yaWdpbmFsVHlwZSA9IGV2ZW50LnR5cGU7XFxuXFx0XFx0ZXZlbnQudHlwZSA9IGV2ZW50VHlwZTtcXG5cXHRcXHRpZiAoIGJ1YmJsZSApIHtcXG5cXHRcXHRcXHQkLmV2ZW50LnRyaWdnZXIoIGV2ZW50LCB1bmRlZmluZWQsIG9iaiApO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0JC5ldmVudC5kaXNwYXRjaC5jYWxsKCBvYmosIGV2ZW50ICk7XFxuXFx0XFx0fVxcblxcdFxcdGV2ZW50LnR5cGUgPSBvcmlnaW5hbFR5cGU7XFxuXFx0fVxcblxcblxcdC8vIGFsc28gaGFuZGxlcyB0YXBob2xkXFxuXFxuXFx0Ly8gQWxzbyBoYW5kbGVzIHN3aXBlbGVmdCwgc3dpcGVyaWdodFxcblxcdCQuZXZlbnQuc3BlY2lhbC5zd2lwZSA9IHtcXG5cXG5cXHRcXHQvLyBNb3JlIHRoYW4gdGhpcyBob3Jpem9udGFsIGRpc3BsYWNlbWVudCwgYW5kIHdlIHdpbGwgc3VwcHJlc3Mgc2Nyb2xsaW5nLlxcblxcdFxcdHNjcm9sbFN1cHJlc3Npb25UaHJlc2hvbGQ6IDMwLFxcblxcblxcdFxcdC8vIE1vcmUgdGltZSB0aGFuIHRoaXMsIGFuZCBpdCBpc24ndCBhIHN3aXBlLlxcblxcdFxcdGR1cmF0aW9uVGhyZXNob2xkOiAxMDAwLFxcblxcblxcdFxcdC8vIFN3aXBlIGhvcml6b250YWwgZGlzcGxhY2VtZW50IG11c3QgYmUgbW9yZSB0aGFuIHRoaXMuXFxuXFx0XFx0aG9yaXpvbnRhbERpc3RhbmNlVGhyZXNob2xkOiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+PSAyID8gMTUgOiAzMCxcXG5cXG5cXHRcXHQvLyBTd2lwZSB2ZXJ0aWNhbCBkaXNwbGFjZW1lbnQgbXVzdCBiZSBsZXNzIHRoYW4gdGhpcy5cXG5cXHRcXHR2ZXJ0aWNhbERpc3RhbmNlVGhyZXNob2xkOiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+PSAyID8gMTUgOiAzMCxcXG5cXG5cXHRcXHRnZXRMb2NhdGlvbjogZnVuY3Rpb24gKCBldmVudCApIHtcXG5cXHRcXHRcXHR2YXIgd2luUGFnZVggPSB3aW5kb3cucGFnZVhPZmZzZXQsXFxuXFx0XFx0XFx0XFx0d2luUGFnZVkgPSB3aW5kb3cucGFnZVlPZmZzZXQsXFxuXFx0XFx0XFx0XFx0eCA9IGV2ZW50LmNsaWVudFgsXFxuXFx0XFx0XFx0XFx0eSA9IGV2ZW50LmNsaWVudFk7XFxuXFxuXFx0XFx0XFx0aWYgKCBldmVudC5wYWdlWSA9PT0gMCAmJiBNYXRoLmZsb29yKCB5ICkgPiBNYXRoLmZsb29yKCBldmVudC5wYWdlWSApIHx8XFxuXFx0XFx0XFx0XFx0ZXZlbnQucGFnZVggPT09IDAgJiYgTWF0aC5mbG9vciggeCApID4gTWF0aC5mbG9vciggZXZlbnQucGFnZVggKSApIHtcXG5cXG5cXHRcXHRcXHRcXHQvLyBpT1M0IGNsaWVudFgvY2xpZW50WSBoYXZlIHRoZSB2YWx1ZSB0aGF0IHNob3VsZCBoYXZlIGJlZW5cXG5cXHRcXHRcXHRcXHQvLyBpbiBwYWdlWC9wYWdlWS4gV2hpbGUgcGFnZVgvcGFnZS8gaGF2ZSB0aGUgdmFsdWUgMFxcblxcdFxcdFxcdFxcdHggPSB4IC0gd2luUGFnZVg7XFxuXFx0XFx0XFx0XFx0eSA9IHkgLSB3aW5QYWdlWTtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCB5IDwgKCBldmVudC5wYWdlWSAtIHdpblBhZ2VZKSB8fCB4IDwgKCBldmVudC5wYWdlWCAtIHdpblBhZ2VYICkgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gU29tZSBBbmRyb2lkIGJyb3dzZXJzIGhhdmUgdG90YWxseSBib2d1cyB2YWx1ZXMgZm9yIGNsaWVudFgvWVxcblxcdFxcdFxcdFxcdC8vIHdoZW4gc2Nyb2xsaW5nL3pvb21pbmcgYSBwYWdlLiBEZXRlY3RhYmxlIHNpbmNlIGNsaWVudFgvY2xpZW50WVxcblxcdFxcdFxcdFxcdC8vIHNob3VsZCBuZXZlciBiZSBzbWFsbGVyIHRoYW4gcGFnZVgvcGFnZVkgbWludXMgcGFnZSBzY3JvbGxcXG5cXHRcXHRcXHRcXHR4ID0gZXZlbnQucGFnZVggLSB3aW5QYWdlWDtcXG5cXHRcXHRcXHRcXHR5ID0gZXZlbnQucGFnZVkgLSB3aW5QYWdlWTtcXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0cmV0dXJuIHtcXG5cXHRcXHRcXHRcXHR4OiB4LFxcblxcdFxcdFxcdFxcdHk6IHlcXG5cXHRcXHRcXHR9O1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0c3RhcnQ6IGZ1bmN0aW9uKCBldmVudCApIHtcXG5cXHRcXHRcXHR2YXIgZGF0YSA9IGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlcyA/XFxuXFx0XFx0XFx0XFx0XFx0ZXZlbnQub3JpZ2luYWxFdmVudC50b3VjaGVzWyAwIF0gOiBldmVudCxcXG5cXHRcXHRcXHRcXHRsb2NhdGlvbiA9ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS5nZXRMb2NhdGlvbiggZGF0YSApO1xcblxcdFxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0XFx0XFx0XFx0dGltZTogKCBuZXcgRGF0ZSgpICkuZ2V0VGltZSgpLFxcblxcdFxcdFxcdFxcdFxcdFxcdGNvb3JkczogWyBsb2NhdGlvbi54LCBsb2NhdGlvbi55IF0sXFxuXFx0XFx0XFx0XFx0XFx0XFx0b3JpZ2luOiAkKCBldmVudC50YXJnZXQgKVxcblxcdFxcdFxcdFxcdFxcdH07XFxuXFx0XFx0fSxcXG5cXG5cXHRcXHRzdG9wOiBmdW5jdGlvbiggZXZlbnQgKSB7XFxuXFx0XFx0XFx0dmFyIGRhdGEgPSBldmVudC5vcmlnaW5hbEV2ZW50LnRvdWNoZXMgP1xcblxcdFxcdFxcdFxcdFxcdGV2ZW50Lm9yaWdpbmFsRXZlbnQudG91Y2hlc1sgMCBdIDogZXZlbnQsXFxuXFx0XFx0XFx0XFx0bG9jYXRpb24gPSAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuZ2V0TG9jYXRpb24oIGRhdGEgKTtcXG5cXHRcXHRcXHRyZXR1cm4ge1xcblxcdFxcdFxcdFxcdFxcdFxcdHRpbWU6ICggbmV3IERhdGUoKSApLmdldFRpbWUoKSxcXG5cXHRcXHRcXHRcXHRcXHRcXHRjb29yZHM6IFsgbG9jYXRpb24ueCwgbG9jYXRpb24ueSBdXFxuXFx0XFx0XFx0XFx0XFx0fTtcXG5cXHRcXHR9LFxcblxcblxcdFxcdGhhbmRsZVN3aXBlOiBmdW5jdGlvbiggc3RhcnQsIHN0b3AsIHRoaXNPYmplY3QsIG9yaWdUYXJnZXQgKSB7XFxuXFx0XFx0XFx0aWYgKCBzdG9wLnRpbWUgLSBzdGFydC50aW1lIDwgJC5ldmVudC5zcGVjaWFsLnN3aXBlLmR1cmF0aW9uVGhyZXNob2xkICYmXFxuXFx0XFx0XFx0XFx0TWF0aC5hYnMoIHN0YXJ0LmNvb3Jkc1sgMCBdIC0gc3RvcC5jb29yZHNbIDAgXSApID4gJC5ldmVudC5zcGVjaWFsLnN3aXBlLmhvcml6b250YWxEaXN0YW5jZVRocmVzaG9sZCAmJlxcblxcdFxcdFxcdFxcdE1hdGguYWJzKCBzdGFydC5jb29yZHNbIDEgXSAtIHN0b3AuY29vcmRzWyAxIF0gKSA8ICQuZXZlbnQuc3BlY2lhbC5zd2lwZS52ZXJ0aWNhbERpc3RhbmNlVGhyZXNob2xkICkge1xcblxcdFxcdFxcdFxcdHZhciBkaXJlY3Rpb24gPSBzdGFydC5jb29yZHNbMF0gPiBzdG9wLmNvb3Jkc1sgMCBdID8gXFxcInN3aXBlbGVmdFxcXCIgOiBcXFwic3dpcGVyaWdodFxcXCI7XFxuXFxuXFx0XFx0XFx0XFx0dHJpZ2dlckN1c3RvbUV2ZW50KCB0aGlzT2JqZWN0LCBcXFwic3dpcGVcXFwiLCAkLkV2ZW50KCBcXFwic3dpcGVcXFwiLCB7IHRhcmdldDogb3JpZ1RhcmdldCwgc3dpcGVzdGFydDogc3RhcnQsIHN3aXBlc3RvcDogc3RvcCB9KSwgdHJ1ZSApO1xcblxcdFxcdFxcdFxcdHRyaWdnZXJDdXN0b21FdmVudCggdGhpc09iamVjdCwgZGlyZWN0aW9uLCQuRXZlbnQoIGRpcmVjdGlvbiwgeyB0YXJnZXQ6IG9yaWdUYXJnZXQsIHN3aXBlc3RhcnQ6IHN0YXJ0LCBzd2lwZXN0b3A6IHN0b3AgfSApLCB0cnVlICk7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHRydWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdHJldHVybiBmYWxzZTtcXG5cXG5cXHRcXHR9LFxcblxcblxcdFxcdC8vIFRoaXMgc2VydmVzIGFzIGEgZmxhZyB0byBlbnN1cmUgdGhhdCBhdCBtb3N0IG9uZSBzd2lwZSBldmVudCBldmVudCBpc1xcblxcdFxcdC8vIGluIHdvcmsgYXQgYW55IGdpdmVuIHRpbWVcXG5cXHRcXHRldmVudEluUHJvZ3Jlc3M6IGZhbHNlLFxcblxcblxcdFxcdHNldHVwOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHR2YXIgZXZlbnRzLFxcblxcdFxcdFxcdFxcdHRoaXNPYmplY3QgPSB0aGlzLFxcblxcdFxcdFxcdFxcdCR0aGlzID0gJCggdGhpc09iamVjdCApLFxcblxcdFxcdFxcdFxcdGNvbnRleHQgPSB7fTtcXG5cXG5cXHRcXHRcXHQvLyBSZXRyaWV2ZSB0aGUgZXZlbnRzIGRhdGEgZm9yIHRoaXMgZWxlbWVudCBhbmQgYWRkIHRoZSBzd2lwZSBjb250ZXh0XFxuXFx0XFx0XFx0ZXZlbnRzID0gJC5kYXRhKCB0aGlzLCBcXFwibW9iaWxlLWV2ZW50c1xcXCIgKTtcXG5cXHRcXHRcXHRpZiAoICFldmVudHMgKSB7XFxuXFx0XFx0XFx0XFx0ZXZlbnRzID0geyBsZW5ndGg6IDAgfTtcXG5cXHRcXHRcXHRcXHQkLmRhdGEoIHRoaXMsIFxcXCJtb2JpbGUtZXZlbnRzXFxcIiwgZXZlbnRzICk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGV2ZW50cy5sZW5ndGgrKztcXG5cXHRcXHRcXHRldmVudHMuc3dpcGUgPSBjb250ZXh0O1xcblxcblxcdFxcdFxcdGNvbnRleHQuc3RhcnQgPSBmdW5jdGlvbiggZXZlbnQgKSB7XFxuXFxuXFx0XFx0XFx0XFx0Ly8gQmFpbCBpZiB3ZSdyZSBhbHJlYWR5IHdvcmtpbmcgb24gYSBzd2lwZSBldmVudFxcblxcdFxcdFxcdFxcdGlmICggJC5ldmVudC5zcGVjaWFsLnN3aXBlLmV2ZW50SW5Qcm9ncmVzcyApIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdCQuZXZlbnQuc3BlY2lhbC5zd2lwZS5ldmVudEluUHJvZ3Jlc3MgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdHZhciBzdG9wLFxcblxcdFxcdFxcdFxcdFxcdHN0YXJ0ID0gJC5ldmVudC5zcGVjaWFsLnN3aXBlLnN0YXJ0KCBldmVudCApLFxcblxcdFxcdFxcdFxcdFxcdG9yaWdUYXJnZXQgPSBldmVudC50YXJnZXQsXFxuXFx0XFx0XFx0XFx0XFx0ZW1pdHRlZCA9IGZhbHNlO1xcblxcblxcdFxcdFxcdFxcdGNvbnRleHQubW92ZSA9IGZ1bmN0aW9uKCBldmVudCApIHtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoICFzdGFydCB8fCBldmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKSApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRyZXR1cm47XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdFxcdFxcdHN0b3AgPSAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuc3RvcCggZXZlbnQgKTtcXG5cXHRcXHRcXHRcXHRcXHRpZiAoICFlbWl0dGVkICkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVtaXR0ZWQgPSAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuaGFuZGxlU3dpcGUoIHN0YXJ0LCBzdG9wLCB0aGlzT2JqZWN0LCBvcmlnVGFyZ2V0ICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0aWYgKCBlbWl0dGVkICkge1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdC8vIFJlc2V0IHRoZSBjb250ZXh0IHRvIG1ha2Ugd2F5IGZvciB0aGUgbmV4dCBzd2lwZSBldmVudFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCQuZXZlbnQuc3BlY2lhbC5zd2lwZS5ldmVudEluUHJvZ3Jlc3MgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdFxcdC8vIHByZXZlbnQgc2Nyb2xsaW5nXFxuXFx0XFx0XFx0XFx0XFx0aWYgKCBNYXRoLmFicyggc3RhcnQuY29vcmRzWyAwIF0gLSBzdG9wLmNvb3Jkc1sgMCBdICkgPiAkLmV2ZW50LnNwZWNpYWwuc3dpcGUuc2Nyb2xsU3VwcmVzc2lvblRocmVzaG9sZCApIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdGNvbnRleHQuc3RvcCA9IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdFxcdFxcdFxcdGVtaXR0ZWQgPSB0cnVlO1xcblxcblxcdFxcdFxcdFxcdFxcdFxcdC8vIFJlc2V0IHRoZSBjb250ZXh0IHRvIG1ha2Ugd2F5IGZvciB0aGUgbmV4dCBzd2lwZSBldmVudFxcblxcdFxcdFxcdFxcdFxcdFxcdCQuZXZlbnQuc3BlY2lhbC5zd2lwZS5ldmVudEluUHJvZ3Jlc3MgPSBmYWxzZTtcXG5cXHRcXHRcXHRcXHRcXHRcXHQkZG9jdW1lbnQub2ZmKCB0b3VjaE1vdmVFdmVudCwgY29udGV4dC5tb3ZlICk7XFxuXFx0XFx0XFx0XFx0XFx0XFx0Y29udGV4dC5tb3ZlID0gbnVsbDtcXG5cXHRcXHRcXHRcXHR9O1xcblxcblxcdFxcdFxcdFxcdCRkb2N1bWVudC5vbiggdG91Y2hNb3ZlRXZlbnQsIGNvbnRleHQubW92ZSApXFxuXFx0XFx0XFx0XFx0XFx0Lm9uZSggdG91Y2hTdG9wRXZlbnQsIGNvbnRleHQuc3RvcCApO1xcblxcdFxcdFxcdH07XFxuXFx0XFx0XFx0JHRoaXMub24oIHRvdWNoU3RhcnRFdmVudCwgY29udGV4dC5zdGFydCApO1xcblxcdFxcdH0sXFxuXFxuXFx0XFx0dGVhcmRvd246IGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHZhciBldmVudHMsIGNvbnRleHQ7XFxuXFxuXFx0XFx0XFx0ZXZlbnRzID0gJC5kYXRhKCB0aGlzLCBcXFwibW9iaWxlLWV2ZW50c1xcXCIgKTtcXG5cXHRcXHRcXHRpZiAoIGV2ZW50cyApIHtcXG5cXHRcXHRcXHRcXHRjb250ZXh0ID0gZXZlbnRzLnN3aXBlO1xcblxcdFxcdFxcdFxcdGRlbGV0ZSBldmVudHMuc3dpcGU7XFxuXFx0XFx0XFx0XFx0ZXZlbnRzLmxlbmd0aC0tO1xcblxcdFxcdFxcdFxcdGlmICggZXZlbnRzLmxlbmd0aCA9PT0gMCApIHtcXG5cXHRcXHRcXHRcXHRcXHQkLnJlbW92ZURhdGEoIHRoaXMsIFxcXCJtb2JpbGUtZXZlbnRzXFxcIiApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFxuXFx0XFx0XFx0aWYgKCBjb250ZXh0ICkge1xcblxcdFxcdFxcdFxcdGlmICggY29udGV4dC5zdGFydCApIHtcXG5cXHRcXHRcXHRcXHRcXHQkKCB0aGlzICkub2ZmKCB0b3VjaFN0YXJ0RXZlbnQsIGNvbnRleHQuc3RhcnQgKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0aWYgKCBjb250ZXh0Lm1vdmUgKSB7XFxuXFx0XFx0XFx0XFx0XFx0JGRvY3VtZW50Lm9mZiggdG91Y2hNb3ZlRXZlbnQsIGNvbnRleHQubW92ZSApO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRpZiAoIGNvbnRleHQuc3RvcCApIHtcXG5cXHRcXHRcXHRcXHRcXHQkZG9jdW1lbnQub2ZmKCB0b3VjaFN0b3BFdmVudCwgY29udGV4dC5zdG9wICk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0fTtcXG5cXHQkLmVhY2goe1xcblxcdFxcdHN3aXBlbGVmdDogXFxcInN3aXBlLmxlZnRcXFwiLFxcblxcdFxcdHN3aXBlcmlnaHQ6IFxcXCJzd2lwZS5yaWdodFxcXCJcXG5cXHR9LCBmdW5jdGlvbiggZXZlbnQsIHNvdXJjZUV2ZW50ICkge1xcblxcblxcdFxcdCQuZXZlbnQuc3BlY2lhbFsgZXZlbnQgXSA9IHtcXG5cXHRcXHRcXHRzZXR1cDogZnVuY3Rpb24oKSB7XFxuXFx0XFx0XFx0XFx0JCggdGhpcyApLmJpbmQoIHNvdXJjZUV2ZW50LCAkLm5vb3AgKTtcXG5cXHRcXHRcXHR9LFxcblxcdFxcdFxcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcXG5cXHRcXHRcXHRcXHQkKCB0aGlzICkudW5iaW5kKCBzb3VyY2VFdmVudCApO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9O1xcblxcdH0pO1xcbn0pKCBqUXVlcnksIHRoaXMgKTtcXG4qL1xcbid1c2Ugc3RyaWN0JztcXG5cXG4hZnVuY3Rpb24gKCQpIHtcXG5cXG4gIHZhciBNdXRhdGlvbk9ic2VydmVyID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgcHJlZml4ZXMgPSBbJ1dlYktpdCcsICdNb3onLCAnTycsICdNcycsICcnXTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGg7IGkrKykge1xcbiAgICAgIGlmIChwcmVmaXhlc1tpXSArICdNdXRhdGlvbk9ic2VydmVyJyBpbiB3aW5kb3cpIHtcXG4gICAgICAgIHJldHVybiB3aW5kb3dbcHJlZml4ZXNbaV0gKyAnTXV0YXRpb25PYnNlcnZlciddO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9KCk7XFxuXFxuICB2YXIgdHJpZ2dlcnMgPSBmdW5jdGlvbiAoZWwsIHR5cGUpIHtcXG4gICAgZWwuZGF0YSh0eXBlKS5zcGxpdCgnICcpLmZvckVhY2goZnVuY3Rpb24gKGlkKSB7XFxuICAgICAgJCgnIycgKyBpZClbdHlwZSA9PT0gJ2Nsb3NlJyA/ICd0cmlnZ2VyJyA6ICd0cmlnZ2VySGFuZGxlciddKHR5cGUgKyAnLnpmLnRyaWdnZXInLCBbZWxdKTtcXG4gICAgfSk7XFxuICB9O1xcbiAgLy8gRWxlbWVudHMgd2l0aCBbZGF0YS1vcGVuXSB3aWxsIHJldmVhbCBhIHBsdWdpbiB0aGF0IHN1cHBvcnRzIGl0IHdoZW4gY2xpY2tlZC5cXG4gICQoZG9jdW1lbnQpLm9uKCdjbGljay56Zi50cmlnZ2VyJywgJ1tkYXRhLW9wZW5dJywgZnVuY3Rpb24gKCkge1xcbiAgICB0cmlnZ2VycygkKHRoaXMpLCAnb3BlbicpO1xcbiAgfSk7XFxuXFxuICAvLyBFbGVtZW50cyB3aXRoIFtkYXRhLWNsb3NlXSB3aWxsIGNsb3NlIGEgcGx1Z2luIHRoYXQgc3VwcG9ydHMgaXQgd2hlbiBjbGlja2VkLlxcbiAgLy8gSWYgdXNlZCB3aXRob3V0IGEgdmFsdWUgb24gW2RhdGEtY2xvc2VdLCB0aGUgZXZlbnQgd2lsbCBidWJibGUsIGFsbG93aW5nIGl0IHRvIGNsb3NlIGEgcGFyZW50IGNvbXBvbmVudC5cXG4gICQoZG9jdW1lbnQpLm9uKCdjbGljay56Zi50cmlnZ2VyJywgJ1tkYXRhLWNsb3NlXScsIGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGlkID0gJCh0aGlzKS5kYXRhKCdjbG9zZScpO1xcbiAgICBpZiAoaWQpIHtcXG4gICAgICB0cmlnZ2VycygkKHRoaXMpLCAnY2xvc2UnKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAkKHRoaXMpLnRyaWdnZXIoJ2Nsb3NlLnpmLnRyaWdnZXInKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyBFbGVtZW50cyB3aXRoIFtkYXRhLXRvZ2dsZV0gd2lsbCB0b2dnbGUgYSBwbHVnaW4gdGhhdCBzdXBwb3J0cyBpdCB3aGVuIGNsaWNrZWQuXFxuICAkKGRvY3VtZW50KS5vbignY2xpY2suemYudHJpZ2dlcicsICdbZGF0YS10b2dnbGVdJywgZnVuY3Rpb24gKCkge1xcbiAgICB0cmlnZ2VycygkKHRoaXMpLCAndG9nZ2xlJyk7XFxuICB9KTtcXG5cXG4gIC8vIEVsZW1lbnRzIHdpdGggW2RhdGEtY2xvc2FibGVdIHdpbGwgcmVzcG9uZCB0byBjbG9zZS56Zi50cmlnZ2VyIGV2ZW50cy5cXG4gICQoZG9jdW1lbnQpLm9uKCdjbG9zZS56Zi50cmlnZ2VyJywgJ1tkYXRhLWNsb3NhYmxlXScsIGZ1bmN0aW9uIChlKSB7XFxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgIHZhciBhbmltYXRpb24gPSAkKHRoaXMpLmRhdGEoJ2Nsb3NhYmxlJyk7XFxuXFxuICAgIGlmIChhbmltYXRpb24gIT09ICcnKSB7XFxuICAgICAgRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dCgkKHRoaXMpLCBhbmltYXRpb24sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICQodGhpcykudHJpZ2dlcignY2xvc2VkLnpmJyk7XFxuICAgICAgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgJCh0aGlzKS5mYWRlT3V0KCkudHJpZ2dlcignY2xvc2VkLnpmJyk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgJChkb2N1bWVudCkub24oJ2ZvY3VzLnpmLnRyaWdnZXIgYmx1ci56Zi50cmlnZ2VyJywgJ1tkYXRhLXRvZ2dsZS1mb2N1c10nLCBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBpZCA9ICQodGhpcykuZGF0YSgndG9nZ2xlLWZvY3VzJyk7XFxuICAgICQoJyMnICsgaWQpLnRyaWdnZXJIYW5kbGVyKCd0b2dnbGUuemYudHJpZ2dlcicsIFskKHRoaXMpXSk7XFxuICB9KTtcXG5cXG4gIC8qKlxcbiAgKiBGaXJlcyBvbmNlIGFmdGVyIGFsbCBvdGhlciBzY3JpcHRzIGhhdmUgbG9hZGVkXFxuICAqIEBmdW5jdGlvblxcbiAgKiBAcHJpdmF0ZVxcbiAgKi9cXG4gICQod2luZG93KS5sb2FkKGZ1bmN0aW9uICgpIHtcXG4gICAgY2hlY2tMaXN0ZW5lcnMoKTtcXG4gIH0pO1xcblxcbiAgZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcnMoKSB7XFxuICAgIGV2ZW50c0xpc3RlbmVyKCk7XFxuICAgIHJlc2l6ZUxpc3RlbmVyKCk7XFxuICAgIHNjcm9sbExpc3RlbmVyKCk7XFxuICAgIGNsb3NlbWVMaXN0ZW5lcigpO1xcbiAgfVxcblxcbiAgLy8qKioqKioqKiBvbmx5IGZpcmVzIHRoaXMgZnVuY3Rpb24gb25jZSBvbiBsb2FkLCBpZiB0aGVyZSdzIHNvbWV0aGluZyB0byB3YXRjaCAqKioqKioqKlxcbiAgZnVuY3Rpb24gY2xvc2VtZUxpc3RlbmVyKHBsdWdpbk5hbWUpIHtcXG4gICAgdmFyIHlldGlCb3hlcyA9ICQoJ1tkYXRhLXlldGktYm94XScpLFxcbiAgICAgICAgcGx1Z05hbWVzID0gWydkcm9wZG93bicsICd0b29sdGlwJywgJ3JldmVhbCddO1xcblxcbiAgICBpZiAocGx1Z2luTmFtZSkge1xcbiAgICAgIGlmICh0eXBlb2YgcGx1Z2luTmFtZSA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgIHBsdWdOYW1lcy5wdXNoKHBsdWdpbk5hbWUpO1xcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbk5hbWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwbHVnaW5OYW1lWzBdID09PSAnc3RyaW5nJykge1xcbiAgICAgICAgcGx1Z05hbWVzLmNvbmNhdChwbHVnaW5OYW1lKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgY29uc29sZS5lcnJvcignUGx1Z2luIG5hbWVzIG11c3QgYmUgc3RyaW5ncycpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoeWV0aUJveGVzLmxlbmd0aCkge1xcbiAgICAgIHZhciBsaXN0ZW5lcnMgPSBwbHVnTmFtZXMubWFwKGZ1bmN0aW9uIChuYW1lKSB7XFxuICAgICAgICByZXR1cm4gJ2Nsb3NlbWUuemYuJyArIG5hbWU7XFxuICAgICAgfSkuam9pbignICcpO1xcblxcbiAgICAgICQod2luZG93KS5vZmYobGlzdGVuZXJzKS5vbihsaXN0ZW5lcnMsIGZ1bmN0aW9uIChlLCBwbHVnaW5JZCkge1xcbiAgICAgICAgdmFyIHBsdWdpbiA9IGUubmFtZXNwYWNlLnNwbGl0KCcuJylbMF07XFxuICAgICAgICB2YXIgcGx1Z2lucyA9ICQoJ1tkYXRhLScgKyBwbHVnaW4gKyAnXScpLm5vdCgnW2RhdGEteWV0aS1ib3g9XFxcIicgKyBwbHVnaW5JZCArICdcXFwiXScpO1xcblxcbiAgICAgICAgcGx1Z2lucy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIF90aGlzID0gJCh0aGlzKTtcXG5cXG4gICAgICAgICAgX3RoaXMudHJpZ2dlckhhbmRsZXIoJ2Nsb3NlLnpmLnRyaWdnZXInLCBbX3RoaXNdKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiByZXNpemVMaXN0ZW5lcihkZWJvdW5jZSkge1xcbiAgICB2YXIgdGltZXIgPSB2b2lkIDAsXFxuICAgICAgICAkbm9kZXMgPSAkKCdbZGF0YS1yZXNpemVdJyk7XFxuICAgIGlmICgkbm9kZXMubGVuZ3RoKSB7XFxuICAgICAgJCh3aW5kb3cpLm9mZigncmVzaXplLnpmLnRyaWdnZXInKS5vbigncmVzaXplLnpmLnRyaWdnZXInLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgaWYgKHRpbWVyKSB7XFxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcblxcbiAgICAgICAgICBpZiAoIU11dGF0aW9uT2JzZXJ2ZXIpIHtcXG4gICAgICAgICAgICAvL2ZhbGxiYWNrIGZvciBJRSA5XFxuICAgICAgICAgICAgJG5vZGVzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgJCh0aGlzKS50cmlnZ2VySGFuZGxlcigncmVzaXplbWUuemYudHJpZ2dlcicpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIC8vdHJpZ2dlciBhbGwgbGlzdGVuaW5nIGVsZW1lbnRzIGFuZCBzaWduYWwgYSByZXNpemUgZXZlbnRcXG4gICAgICAgICAgJG5vZGVzLmF0dHIoJ2RhdGEtZXZlbnRzJywgXFxcInJlc2l6ZVxcXCIpO1xcbiAgICAgICAgfSwgZGVib3VuY2UgfHwgMTApOyAvL2RlZmF1bHQgdGltZSB0byBlbWl0IHJlc2l6ZSBldmVudFxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBzY3JvbGxMaXN0ZW5lcihkZWJvdW5jZSkge1xcbiAgICB2YXIgdGltZXIgPSB2b2lkIDAsXFxuICAgICAgICAkbm9kZXMgPSAkKCdbZGF0YS1zY3JvbGxdJyk7XFxuICAgIGlmICgkbm9kZXMubGVuZ3RoKSB7XFxuICAgICAgJCh3aW5kb3cpLm9mZignc2Nyb2xsLnpmLnRyaWdnZXInKS5vbignc2Nyb2xsLnpmLnRyaWdnZXInLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgaWYgKHRpbWVyKSB7XFxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcblxcbiAgICAgICAgICBpZiAoIU11dGF0aW9uT2JzZXJ2ZXIpIHtcXG4gICAgICAgICAgICAvL2ZhbGxiYWNrIGZvciBJRSA5XFxuICAgICAgICAgICAgJG5vZGVzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgJCh0aGlzKS50cmlnZ2VySGFuZGxlcignc2Nyb2xsbWUuemYudHJpZ2dlcicpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIC8vdHJpZ2dlciBhbGwgbGlzdGVuaW5nIGVsZW1lbnRzIGFuZCBzaWduYWwgYSBzY3JvbGwgZXZlbnRcXG4gICAgICAgICAgJG5vZGVzLmF0dHIoJ2RhdGEtZXZlbnRzJywgXFxcInNjcm9sbFxcXCIpO1xcbiAgICAgICAgfSwgZGVib3VuY2UgfHwgMTApOyAvL2RlZmF1bHQgdGltZSB0byBlbWl0IHNjcm9sbCBldmVudFxcbiAgICAgIH0pO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBldmVudHNMaXN0ZW5lcigpIHtcXG4gICAgaWYgKCFNdXRhdGlvbk9ic2VydmVyKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIHZhciBub2RlcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLXJlc2l6ZV0sIFtkYXRhLXNjcm9sbF0sIFtkYXRhLW11dGF0ZV0nKTtcXG5cXG4gICAgLy9lbGVtZW50IGNhbGxiYWNrXFxuICAgIHZhciBsaXN0ZW5pbmdFbGVtZW50c011dGF0aW9uID0gZnVuY3Rpb24gKG11dGF0aW9uUmVjb3Jkc0xpc3QpIHtcXG4gICAgICB2YXIgJHRhcmdldCA9ICQobXV0YXRpb25SZWNvcmRzTGlzdFswXS50YXJnZXQpO1xcbiAgICAgIC8vdHJpZ2dlciB0aGUgZXZlbnQgaGFuZGxlciBmb3IgdGhlIGVsZW1lbnQgZGVwZW5kaW5nIG9uIHR5cGVcXG4gICAgICBzd2l0Y2ggKCR0YXJnZXQuYXR0cihcXFwiZGF0YS1ldmVudHNcXFwiKSkge1xcblxcbiAgICAgICAgY2FzZSBcXFwicmVzaXplXFxcIjpcXG4gICAgICAgICAgJHRhcmdldC50cmlnZ2VySGFuZGxlcigncmVzaXplbWUuemYudHJpZ2dlcicsIFskdGFyZ2V0XSk7XFxuICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgY2FzZSBcXFwic2Nyb2xsXFxcIjpcXG4gICAgICAgICAgJHRhcmdldC50cmlnZ2VySGFuZGxlcignc2Nyb2xsbWUuemYudHJpZ2dlcicsIFskdGFyZ2V0LCB3aW5kb3cucGFnZVlPZmZzZXRdKTtcXG4gICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAvLyBjYXNlIFxcXCJtdXRhdGVcXFwiIDpcXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKCdtdXRhdGUnLCAkdGFyZ2V0KTtcXG4gICAgICAgIC8vICR0YXJnZXQudHJpZ2dlckhhbmRsZXIoJ211dGF0ZS56Zi50cmlnZ2VyJyk7XFxuICAgICAgICAvL1xcbiAgICAgICAgLy8gLy9tYWtlIHN1cmUgd2UgZG9uJ3QgZ2V0IHN0dWNrIGluIGFuIGluZmluaXRlIGxvb3AgZnJvbSBzbG9wcHkgY29kZWluZ1xcbiAgICAgICAgLy8gaWYgKCR0YXJnZXQuaW5kZXgoJ1tkYXRhLW11dGF0ZV0nKSA9PSAkKFxcXCJbZGF0YS1tdXRhdGVdXFxcIikubGVuZ3RoLTEpIHtcXG4gICAgICAgIC8vICAgZG9tTXV0YXRpb25PYnNlcnZlcigpO1xcbiAgICAgICAgLy8gfVxcbiAgICAgICAgLy8gYnJlYWs7XFxuXFxuICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAvL25vdGhpbmdcXG4gICAgICB9XFxuICAgIH07XFxuXFxuICAgIGlmIChub2Rlcy5sZW5ndGgpIHtcXG4gICAgICAvL2ZvciBlYWNoIGVsZW1lbnQgdGhhdCBuZWVkcyB0byBsaXN0ZW4gZm9yIHJlc2l6aW5nLCBzY3JvbGxpbmcsIChvciBjb21pbmcgc29vbiBtdXRhdGlvbikgYWRkIGEgc2luZ2xlIG9ic2VydmVyXFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gbm9kZXMubGVuZ3RoIC0gMTsgaSsrKSB7XFxuICAgICAgICB2YXIgZWxlbWVudE9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIobGlzdGVuaW5nRWxlbWVudHNNdXRhdGlvbik7XFxuICAgICAgICBlbGVtZW50T2JzZXJ2ZXIub2JzZXJ2ZShub2Rlc1tpXSwgeyBhdHRyaWJ1dGVzOiB0cnVlLCBjaGlsZExpc3Q6IGZhbHNlLCBjaGFyYWN0ZXJEYXRhOiBmYWxzZSwgc3VidHJlZTogZmFsc2UsIGF0dHJpYnV0ZUZpbHRlcjogW1xcXCJkYXRhLWV2ZW50c1xcXCJdIH0pO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXFxuXFxuICAvLyBbUEhdXFxuICAvLyBGb3VuZGF0aW9uLkNoZWNrV2F0Y2hlcnMgPSBjaGVja1dhdGNoZXJzO1xcbiAgRm91bmRhdGlvbi5JSGVhcllvdSA9IGNoZWNrTGlzdGVuZXJzO1xcbiAgLy8gRm91bmRhdGlvbi5JU2VlWW91ID0gc2Nyb2xsTGlzdGVuZXI7XFxuICAvLyBGb3VuZGF0aW9uLklGZWVsWW91ID0gY2xvc2VtZUxpc3RlbmVyO1xcbn0oalF1ZXJ5KTtcXG5cXG4vLyBmdW5jdGlvbiBkb21NdXRhdGlvbk9ic2VydmVyKGRlYm91bmNlKSB7XFxuLy8gICAvLyAhISEgVGhpcyBpcyBjb21pbmcgc29vbiBhbmQgbmVlZHMgbW9yZSB3b3JrOyBub3QgYWN0aXZlICAhISEgLy9cXG4vLyAgIHZhciB0aW1lcixcXG4vLyAgIG5vZGVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnW2RhdGEtbXV0YXRlXScpO1xcbi8vICAgLy9cXG4vLyAgIGlmIChub2Rlcy5sZW5ndGgpIHtcXG4vLyAgICAgLy8gdmFyIE11dGF0aW9uT2JzZXJ2ZXIgPSAoZnVuY3Rpb24gKCkge1xcbi8vICAgICAvLyAgIHZhciBwcmVmaXhlcyA9IFsnV2ViS2l0JywgJ01veicsICdPJywgJ01zJywgJyddO1xcbi8vICAgICAvLyAgIGZvciAodmFyIGk9MDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XFxuLy8gICAgIC8vICAgICBpZiAocHJlZml4ZXNbaV0gKyAnTXV0YXRpb25PYnNlcnZlcicgaW4gd2luZG93KSB7XFxuLy8gICAgIC8vICAgICAgIHJldHVybiB3aW5kb3dbcHJlZml4ZXNbaV0gKyAnTXV0YXRpb25PYnNlcnZlciddO1xcbi8vICAgICAvLyAgICAgfVxcbi8vICAgICAvLyAgIH1cXG4vLyAgICAgLy8gICByZXR1cm4gZmFsc2U7XFxuLy8gICAgIC8vIH0oKSk7XFxuLy9cXG4vL1xcbi8vICAgICAvL2ZvciB0aGUgYm9keSwgd2UgbmVlZCB0byBsaXN0ZW4gZm9yIGFsbCBjaGFuZ2VzIGVmZmVjdGluZyB0aGUgc3R5bGUgYW5kIGNsYXNzIGF0dHJpYnV0ZXNcXG4vLyAgICAgdmFyIGJvZHlPYnNlcnZlciA9IG5ldyBNdXRhdGlvbk9ic2VydmVyKGJvZHlNdXRhdGlvbik7XFxuLy8gICAgIGJvZHlPYnNlcnZlci5vYnNlcnZlKGRvY3VtZW50LmJvZHksIHsgYXR0cmlidXRlczogdHJ1ZSwgY2hpbGRMaXN0OiB0cnVlLCBjaGFyYWN0ZXJEYXRhOiBmYWxzZSwgc3VidHJlZTp0cnVlLCBhdHRyaWJ1dGVGaWx0ZXI6W1xcXCJzdHlsZVxcXCIsIFxcXCJjbGFzc1xcXCJdfSk7XFxuLy9cXG4vL1xcbi8vICAgICAvL2JvZHkgY2FsbGJhY2tcXG4vLyAgICAgZnVuY3Rpb24gYm9keU11dGF0aW9uKG11dGF0ZSkge1xcbi8vICAgICAgIC8vdHJpZ2dlciBhbGwgbGlzdGVuaW5nIGVsZW1lbnRzIGFuZCBzaWduYWwgYSBtdXRhdGlvbiBldmVudFxcbi8vICAgICAgIGlmICh0aW1lcikgeyBjbGVhclRpbWVvdXQodGltZXIpOyB9XFxuLy9cXG4vLyAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XFxuLy8gICAgICAgICBib2R5T2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xcbi8vICAgICAgICAgJCgnW2RhdGEtbXV0YXRlXScpLmF0dHIoJ2RhdGEtZXZlbnRzJyxcXFwibXV0YXRlXFxcIik7XFxuLy8gICAgICAgfSwgZGVib3VuY2UgfHwgMTUwKTtcXG4vLyAgICAgfVxcbi8vICAgfVxcbi8vIH1cXG4ndXNlIHN0cmljdCc7XFxuXFxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuIWZ1bmN0aW9uICgkKSB7XFxuXFxuICAvKipcXG4gICAqIEFiaWRlIG1vZHVsZS5cXG4gICAqIEBtb2R1bGUgZm91bmRhdGlvbi5hYmlkZVxcbiAgICovXFxuXFxuICB2YXIgQWJpZGUgPSBmdW5jdGlvbiAoKSB7XFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEFiaWRlLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQGZpcmVzIEFiaWRlI2luaXRcXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGFkZCB0aGUgdHJpZ2dlciB0by5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG5cXG4gICAgZnVuY3Rpb24gQWJpZGUoZWxlbWVudCkge1xcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMV07XFxuXFxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEFiaWRlKTtcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQWJpZGUuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuXFxuICAgICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnQWJpZGUnKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIEFiaWRlIHBsdWdpbiBhbmQgY2FsbHMgZnVuY3Rpb25zIHRvIGdldCBBYmlkZSBmdW5jdGlvbmluZyBvbiBsb2FkLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG5cXG4gICAgX2NyZWF0ZUNsYXNzKEFiaWRlLCBbe1xcbiAgICAgIGtleTogJ19pbml0JyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgICB0aGlzLiRpbnB1dHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ2lucHV0LCB0ZXh0YXJlYSwgc2VsZWN0Jyk7XFxuXFxuICAgICAgICB0aGlzLl9ldmVudHMoKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciBBYmlkZS5cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX2V2ZW50cycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcXG5cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuYWJpZGUnKS5vbigncmVzZXQuemYuYWJpZGUnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIF90aGlzMi5yZXNldEZvcm0oKTtcXG4gICAgICAgIH0pLm9uKCdzdWJtaXQuemYuYWJpZGUnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHJldHVybiBfdGhpczIudmFsaWRhdGVGb3JtKCk7XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMudmFsaWRhdGVPbiA9PT0gJ2ZpZWxkQ2hhbmdlJykge1xcbiAgICAgICAgICB0aGlzLiRpbnB1dHMub2ZmKCdjaGFuZ2UuemYuYWJpZGUnKS5vbignY2hhbmdlLnpmLmFiaWRlJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBfdGhpczIudmFsaWRhdGVJbnB1dCgkKGUudGFyZ2V0KSk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saXZlVmFsaWRhdGUpIHtcXG4gICAgICAgICAgdGhpcy4kaW5wdXRzLm9mZignaW5wdXQuemYuYWJpZGUnKS5vbignaW5wdXQuemYuYWJpZGUnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIF90aGlzMi52YWxpZGF0ZUlucHV0KCQoZS50YXJnZXQpKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIENhbGxzIG5lY2Vzc2FyeSBmdW5jdGlvbnMgdG8gdXBkYXRlIEFiaWRlIHVwb24gRE9NIGNoYW5nZVxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfcmVmbG93JyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlZmxvdygpIHtcXG4gICAgICAgIHRoaXMuX2luaXQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IGEgZm9ybSBlbGVtZW50IGhhcyB0aGUgcmVxdWlyZWQgYXR0cmlidXRlIGFuZCBpZiBpdCdzIGNoZWNrZWQgb3Igbm90XFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGNoZWNrIGZvciByZXF1aXJlZCBhdHRyaWJ1dGVcXG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gQm9vbGVhbiB2YWx1ZSBkZXBlbmRzIG9uIHdoZXRoZXIgb3Igbm90IGF0dHJpYnV0ZSBpcyBjaGVja2VkIG9yIGVtcHR5XFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdyZXF1aXJlZENoZWNrJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVxdWlyZWRDaGVjaygkZWwpIHtcXG4gICAgICAgIGlmICghJGVsLmF0dHIoJ3JlcXVpcmVkJykpIHJldHVybiB0cnVlO1xcblxcbiAgICAgICAgdmFyIGlzR29vZCA9IHRydWU7XFxuXFxuICAgICAgICBzd2l0Y2ggKCRlbFswXS50eXBlKSB7XFxuICAgICAgICAgIGNhc2UgJ2NoZWNrYm94JzpcXG4gICAgICAgICAgICBpc0dvb2QgPSAkZWxbMF0uY2hlY2tlZDtcXG4gICAgICAgICAgICBicmVhaztcXG5cXG4gICAgICAgICAgY2FzZSAnc2VsZWN0JzpcXG4gICAgICAgICAgY2FzZSAnc2VsZWN0LW9uZSc6XFxuICAgICAgICAgIGNhc2UgJ3NlbGVjdC1tdWx0aXBsZSc6XFxuICAgICAgICAgICAgdmFyIG9wdCA9ICRlbC5maW5kKCdvcHRpb246c2VsZWN0ZWQnKTtcXG4gICAgICAgICAgICBpZiAoIW9wdC5sZW5ndGggfHwgIW9wdC52YWwoKSkgaXNHb29kID0gZmFsc2U7XFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgaWYgKCEkZWwudmFsKCkgfHwgISRlbC52YWwoKS5sZW5ndGgpIGlzR29vZCA9IGZhbHNlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgcmV0dXJuIGlzR29vZDtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogQmFzZWQgb24gJGVsLCBnZXQgdGhlIGZpcnN0IGVsZW1lbnQgd2l0aCBzZWxlY3RvciBpbiB0aGlzIG9yZGVyOlxcbiAgICAgICAqIDEuIFRoZSBlbGVtZW50J3MgZGlyZWN0IHNpYmxpbmcoJ3MpLlxcbiAgICAgICAqIDMuIFRoZSBlbGVtZW50J3MgcGFyZW50J3MgY2hpbGRyZW4uXFxuICAgICAgICpcXG4gICAgICAgKiBUaGlzIGFsbG93cyBmb3IgbXVsdGlwbGUgZm9ybSBlcnJvcnMgcGVyIGlucHV0LCB0aG91Z2ggaWYgbm9uZSBhcmUgZm91bmQsIG5vIGZvcm0gZXJyb3JzIHdpbGwgYmUgc2hvd24uXFxuICAgICAgICpcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byB1c2UgYXMgcmVmZXJlbmNlIHRvIGZpbmQgdGhlIGZvcm0gZXJyb3Igc2VsZWN0b3IuXFxuICAgICAgICogQHJldHVybnMge09iamVjdH0galF1ZXJ5IG9iamVjdCB3aXRoIHRoZSBzZWxlY3Rvci5cXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ2ZpbmRGb3JtRXJyb3InLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBmaW5kRm9ybUVycm9yKCRlbCkge1xcbiAgICAgICAgdmFyICRlcnJvciA9ICRlbC5zaWJsaW5ncyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yU2VsZWN0b3IpO1xcblxcbiAgICAgICAgaWYgKCEkZXJyb3IubGVuZ3RoKSB7XFxuICAgICAgICAgICRlcnJvciA9ICRlbC5wYXJlbnQoKS5maW5kKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JTZWxlY3Rvcik7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gJGVycm9yO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBHZXQgdGhlIGZpcnN0IGVsZW1lbnQgaW4gdGhpcyBvcmRlcjpcXG4gICAgICAgKiAyLiBUaGUgPGxhYmVsPiB3aXRoIHRoZSBhdHRyaWJ1dGUgYFtmb3I9XFxcInNvbWVJbnB1dElkXFxcIl1gXFxuICAgICAgICogMy4gVGhlIGAuY2xvc2VzdCgpYCA8bGFiZWw+XFxuICAgICAgICpcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byBjaGVjayBmb3IgcmVxdWlyZWQgYXR0cmlidXRlXFxuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IEJvb2xlYW4gdmFsdWUgZGVwZW5kcyBvbiB3aGV0aGVyIG9yIG5vdCBhdHRyaWJ1dGUgaXMgY2hlY2tlZCBvciBlbXB0eVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnZmluZExhYmVsJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZmluZExhYmVsKCRlbCkge1xcbiAgICAgICAgdmFyIGlkID0gJGVsWzBdLmlkO1xcbiAgICAgICAgdmFyICRsYWJlbCA9IHRoaXMuJGVsZW1lbnQuZmluZCgnbGFiZWxbZm9yPVxcXCInICsgaWQgKyAnXFxcIl0nKTtcXG5cXG4gICAgICAgIGlmICghJGxhYmVsLmxlbmd0aCkge1xcbiAgICAgICAgICByZXR1cm4gJGVsLmNsb3Nlc3QoJ2xhYmVsJyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gJGxhYmVsO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBHZXQgdGhlIHNldCBvZiBsYWJlbHMgYXNzb2NpYXRlZCB3aXRoIGEgc2V0IG9mIHJhZGlvIGVscyBpbiB0aGlzIG9yZGVyXFxuICAgICAgICogMi4gVGhlIDxsYWJlbD4gd2l0aCB0aGUgYXR0cmlidXRlIGBbZm9yPVxcXCJzb21lSW5wdXRJZFxcXCJdYFxcbiAgICAgICAqIDMuIFRoZSBgLmNsb3Nlc3QoKWAgPGxhYmVsPlxcbiAgICAgICAqXFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9ICRlbCAtIGpRdWVyeSBvYmplY3QgdG8gY2hlY2sgZm9yIHJlcXVpcmVkIGF0dHJpYnV0ZVxcbiAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgYXR0cmlidXRlIGlzIGNoZWNrZWQgb3IgZW1wdHlcXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ2ZpbmRSYWRpb0xhYmVscycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGZpbmRSYWRpb0xhYmVscygkZWxzKSB7XFxuICAgICAgICB2YXIgX3RoaXMzID0gdGhpcztcXG5cXG4gICAgICAgIHZhciBsYWJlbHMgPSAkZWxzLm1hcChmdW5jdGlvbiAoaSwgZWwpIHtcXG4gICAgICAgICAgdmFyIGlkID0gZWwuaWQ7XFxuICAgICAgICAgIHZhciAkbGFiZWwgPSBfdGhpczMuJGVsZW1lbnQuZmluZCgnbGFiZWxbZm9yPVxcXCInICsgaWQgKyAnXFxcIl0nKTtcXG5cXG4gICAgICAgICAgaWYgKCEkbGFiZWwubGVuZ3RoKSB7XFxuICAgICAgICAgICAgJGxhYmVsID0gJChlbCkuY2xvc2VzdCgnbGFiZWwnKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4gJGxhYmVsWzBdO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICByZXR1cm4gJChsYWJlbHMpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBBZGRzIHRoZSBDU1MgZXJyb3IgY2xhc3MgYXMgc3BlY2lmaWVkIGJ5IHRoZSBBYmlkZSBzZXR0aW5ncyB0byB0aGUgbGFiZWwsIGlucHV0LCBhbmQgdGhlIGZvcm1cXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIGNsYXNzIHRvXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdhZGRFcnJvckNsYXNzZXMnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhZGRFcnJvckNsYXNzZXMoJGVsKSB7XFxuICAgICAgICB2YXIgJGxhYmVsID0gdGhpcy5maW5kTGFiZWwoJGVsKTtcXG4gICAgICAgIHZhciAkZm9ybUVycm9yID0gdGhpcy5maW5kRm9ybUVycm9yKCRlbCk7XFxuXFxuICAgICAgICBpZiAoJGxhYmVsLmxlbmd0aCkge1xcbiAgICAgICAgICAkbGFiZWwuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoJGZvcm1FcnJvci5sZW5ndGgpIHtcXG4gICAgICAgICAgJGZvcm1FcnJvci5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yQ2xhc3MpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgJGVsLmFkZENsYXNzKHRoaXMub3B0aW9ucy5pbnB1dEVycm9yQ2xhc3MpLmF0dHIoJ2RhdGEtaW52YWxpZCcsICcnKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogUmVtb3ZlIENTUyBlcnJvciBjbGFzc2VzIGV0YyBmcm9tIGFuIGVudGlyZSByYWRpbyBidXR0b24gZ3JvdXBcXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gZ3JvdXBOYW1lIC0gQSBzdHJpbmcgdGhhdCBzcGVjaWZpZXMgdGhlIG5hbWUgb2YgYSByYWRpbyBidXR0b24gZ3JvdXBcXG4gICAgICAgKlxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAncmVtb3ZlUmFkaW9FcnJvckNsYXNzZXMnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVSYWRpb0Vycm9yQ2xhc3Nlcyhncm91cE5hbWUpIHtcXG4gICAgICAgIHZhciAkZWxzID0gdGhpcy4kZWxlbWVudC5maW5kKCc6cmFkaW9bbmFtZT1cXFwiJyArIGdyb3VwTmFtZSArICdcXFwiXScpO1xcbiAgICAgICAgdmFyICRsYWJlbHMgPSB0aGlzLmZpbmRSYWRpb0xhYmVscygkZWxzKTtcXG4gICAgICAgIHZhciAkZm9ybUVycm9ycyA9IHRoaXMuZmluZEZvcm1FcnJvcigkZWxzKTtcXG5cXG4gICAgICAgIGlmICgkbGFiZWxzLmxlbmd0aCkge1xcbiAgICAgICAgICAkbGFiZWxzLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sYWJlbEVycm9yQ2xhc3MpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCRmb3JtRXJyb3JzLmxlbmd0aCkge1xcbiAgICAgICAgICAkZm9ybUVycm9ycy5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yQ2xhc3MpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgJGVscy5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuaW5wdXRFcnJvckNsYXNzKS5yZW1vdmVBdHRyKCdkYXRhLWludmFsaWQnKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogUmVtb3ZlcyBDU1MgZXJyb3IgY2xhc3MgYXMgc3BlY2lmaWVkIGJ5IHRoZSBBYmlkZSBzZXR0aW5ncyBmcm9tIHRoZSBsYWJlbCwgaW5wdXQsIGFuZCB0aGUgZm9ybVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIHJlbW92ZSB0aGUgY2xhc3MgZnJvbVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAncmVtb3ZlRXJyb3JDbGFzc2VzJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVtb3ZlRXJyb3JDbGFzc2VzKCRlbCkge1xcbiAgICAgICAgLy8gcmFkaW9zIG5lZWQgdG8gY2xlYXIgYWxsIG9mIHRoZSBlbHNcXG4gICAgICAgIGlmICgkZWxbMF0udHlwZSA9PSAncmFkaW8nKSB7XFxuICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZVJhZGlvRXJyb3JDbGFzc2VzKCRlbC5hdHRyKCduYW1lJykpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdmFyICRsYWJlbCA9IHRoaXMuZmluZExhYmVsKCRlbCk7XFxuICAgICAgICB2YXIgJGZvcm1FcnJvciA9IHRoaXMuZmluZEZvcm1FcnJvcigkZWwpO1xcblxcbiAgICAgICAgaWYgKCRsYWJlbC5sZW5ndGgpIHtcXG4gICAgICAgICAgJGxhYmVsLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5sYWJlbEVycm9yQ2xhc3MpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCRmb3JtRXJyb3IubGVuZ3RoKSB7XFxuICAgICAgICAgICRmb3JtRXJyb3IucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmZvcm1FcnJvckNsYXNzKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgICRlbC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuaW5wdXRFcnJvckNsYXNzKS5yZW1vdmVBdHRyKCdkYXRhLWludmFsaWQnKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogR29lcyB0aHJvdWdoIGEgZm9ybSB0byBmaW5kIGlucHV0cyBhbmQgcHJvY2VlZHMgdG8gdmFsaWRhdGUgdGhlbSBpbiB3YXlzIHNwZWNpZmljIHRvIHRoZWlyIHR5cGVcXG4gICAgICAgKiBAZmlyZXMgQWJpZGUjaW52YWxpZFxcbiAgICAgICAqIEBmaXJlcyBBYmlkZSN2YWxpZFxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byB2YWxpZGF0ZSwgc2hvdWxkIGJlIGFuIEhUTUwgaW5wdXRcXG4gICAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gZ29vZFRvR28gLSBJZiB0aGUgaW5wdXQgaXMgdmFsaWQgb3Igbm90LlxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAndmFsaWRhdGVJbnB1dCcsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlSW5wdXQoJGVsKSB7XFxuICAgICAgICB2YXIgY2xlYXJSZXF1aXJlID0gdGhpcy5yZXF1aXJlZENoZWNrKCRlbCksXFxuICAgICAgICAgICAgdmFsaWRhdGVkID0gZmFsc2UsXFxuICAgICAgICAgICAgY3VzdG9tVmFsaWRhdG9yID0gdHJ1ZSxcXG4gICAgICAgICAgICB2YWxpZGF0b3IgPSAkZWwuYXR0cignZGF0YS12YWxpZGF0b3InKSxcXG4gICAgICAgICAgICBlcXVhbFRvID0gdHJ1ZTtcXG5cXG4gICAgICAgIC8vIGRvbid0IHZhbGlkYXRlIGlnbm9yZWQgaW5wdXRzIG9yIGhpZGRlbiBpbnB1dHNcXG4gICAgICAgIGlmICgkZWwuaXMoJ1tkYXRhLWFiaWRlLWlnbm9yZV0nKSB8fCAkZWwuaXMoJ1t0eXBlPVxcXCJoaWRkZW5cXFwiXScpKSB7XFxuICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgc3dpdGNoICgkZWxbMF0udHlwZSkge1xcbiAgICAgICAgICBjYXNlICdyYWRpbyc6XFxuICAgICAgICAgICAgdmFsaWRhdGVkID0gdGhpcy52YWxpZGF0ZVJhZGlvKCRlbC5hdHRyKCduYW1lJykpO1xcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBjYXNlICdjaGVja2JveCc6XFxuICAgICAgICAgICAgdmFsaWRhdGVkID0gY2xlYXJSZXF1aXJlO1xcbiAgICAgICAgICAgIGJyZWFrO1xcblxcbiAgICAgICAgICBjYXNlICdzZWxlY3QnOlxcbiAgICAgICAgICBjYXNlICdzZWxlY3Qtb25lJzpcXG4gICAgICAgICAgY2FzZSAnc2VsZWN0LW11bHRpcGxlJzpcXG4gICAgICAgICAgICB2YWxpZGF0ZWQgPSBjbGVhclJlcXVpcmU7XFxuICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgdmFsaWRhdGVkID0gdGhpcy52YWxpZGF0ZVRleHQoJGVsKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh2YWxpZGF0b3IpIHtcXG4gICAgICAgICAgY3VzdG9tVmFsaWRhdG9yID0gdGhpcy5tYXRjaFZhbGlkYXRpb24oJGVsLCB2YWxpZGF0b3IsICRlbC5hdHRyKCdyZXF1aXJlZCcpKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICgkZWwuYXR0cignZGF0YS1lcXVhbHRvJykpIHtcXG4gICAgICAgICAgZXF1YWxUbyA9IHRoaXMub3B0aW9ucy52YWxpZGF0b3JzLmVxdWFsVG8oJGVsKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBnb29kVG9HbyA9IFtjbGVhclJlcXVpcmUsIHZhbGlkYXRlZCwgY3VzdG9tVmFsaWRhdG9yLCBlcXVhbFRvXS5pbmRleE9mKGZhbHNlKSA9PT0gLTE7XFxuICAgICAgICB2YXIgbWVzc2FnZSA9IChnb29kVG9HbyA/ICd2YWxpZCcgOiAnaW52YWxpZCcpICsgJy56Zi5hYmlkZSc7XFxuXFxuICAgICAgICB0aGlzW2dvb2RUb0dvID8gJ3JlbW92ZUVycm9yQ2xhc3NlcycgOiAnYWRkRXJyb3JDbGFzc2VzJ10oJGVsKTtcXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgaW5wdXQgaXMgZG9uZSBjaGVja2luZyBmb3IgdmFsaWRhdGlvbi4gRXZlbnQgdHJpZ2dlciBpcyBlaXRoZXIgYHZhbGlkLnpmLmFiaWRlYCBvciBgaW52YWxpZC56Zi5hYmlkZWBcXG4gICAgICAgICAqIFRyaWdnZXIgaW5jbHVkZXMgdGhlIERPTSBlbGVtZW50IG9mIHRoZSBpbnB1dC5cXG4gICAgICAgICAqIEBldmVudCBBYmlkZSN2YWxpZFxcbiAgICAgICAgICogQGV2ZW50IEFiaWRlI2ludmFsaWRcXG4gICAgICAgICAqL1xcbiAgICAgICAgJGVsLnRyaWdnZXIobWVzc2FnZSwgWyRlbF0pO1xcblxcbiAgICAgICAgcmV0dXJuIGdvb2RUb0dvO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBHb2VzIHRocm91Z2ggYSBmb3JtIGFuZCBpZiB0aGVyZSBhcmUgYW55IGludmFsaWQgaW5wdXRzLCBpdCB3aWxsIGRpc3BsYXkgdGhlIGZvcm0gZXJyb3IgZWxlbWVudFxcbiAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBub0Vycm9yIC0gdHJ1ZSBpZiBubyBlcnJvcnMgd2VyZSBkZXRlY3RlZC4uLlxcbiAgICAgICAqIEBmaXJlcyBBYmlkZSNmb3JtdmFsaWRcXG4gICAgICAgKiBAZmlyZXMgQWJpZGUjZm9ybWludmFsaWRcXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ3ZhbGlkYXRlRm9ybScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybSgpIHtcXG4gICAgICAgIHZhciBhY2MgPSBbXTtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgICB0aGlzLiRpbnB1dHMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGFjYy5wdXNoKF90aGlzLnZhbGlkYXRlSW5wdXQoJCh0aGlzKSkpO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICB2YXIgbm9FcnJvciA9IGFjYy5pbmRleE9mKGZhbHNlKSA9PT0gLTE7XFxuXFxuICAgICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLWFiaWRlLWVycm9yXScpLmNzcygnZGlzcGxheScsIG5vRXJyb3IgPyAnbm9uZScgOiAnYmxvY2snKTtcXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgZm9ybSBpcyBmaW5pc2hlZCB2YWxpZGF0aW5nLiBFdmVudCB0cmlnZ2VyIGlzIGVpdGhlciBgZm9ybXZhbGlkLnpmLmFiaWRlYCBvciBgZm9ybWludmFsaWQuemYuYWJpZGVgLlxcbiAgICAgICAgICogVHJpZ2dlciBpbmNsdWRlcyB0aGUgZWxlbWVudCBvZiB0aGUgZm9ybS5cXG4gICAgICAgICAqIEBldmVudCBBYmlkZSNmb3JtdmFsaWRcXG4gICAgICAgICAqIEBldmVudCBBYmlkZSNmb3JtaW52YWxpZFxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoKG5vRXJyb3IgPyAnZm9ybXZhbGlkJyA6ICdmb3JtaW52YWxpZCcpICsgJy56Zi5hYmlkZScsIFt0aGlzLiRlbGVtZW50XSk7XFxuXFxuICAgICAgICByZXR1cm4gbm9FcnJvcjtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIGEgbm90IGEgdGV4dCBpbnB1dCBpcyB2YWxpZCBiYXNlZCBvbiB0aGUgcGF0dGVybiBzcGVjaWZpZWQgaW4gdGhlIGF0dHJpYnV0ZS4gSWYgbm8gbWF0Y2hpbmcgcGF0dGVybiBpcyBmb3VuZCwgcmV0dXJucyB0cnVlLlxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSAkZWwgLSBqUXVlcnkgb2JqZWN0IHRvIHZhbGlkYXRlLCBzaG91bGQgYmUgYSB0ZXh0IGlucHV0IEhUTUwgZWxlbWVudFxcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYXR0ZXJuIC0gc3RyaW5nIHZhbHVlIG9mIG9uZSBvZiB0aGUgUmVnRXggcGF0dGVybnMgaW4gQWJpZGUub3B0aW9ucy5wYXR0ZXJuc1xcbiAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgdGhlIGlucHV0IHZhbHVlIG1hdGNoZXMgdGhlIHBhdHRlcm4gc3BlY2lmaWVkXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICd2YWxpZGF0ZVRleHQnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB2YWxpZGF0ZVRleHQoJGVsLCBwYXR0ZXJuKSB7XFxuICAgICAgICAvLyBBIHBhdHRlcm4gY2FuIGJlIHBhc3NlZCB0byB0aGlzIGZ1bmN0aW9uLCBvciBpdCB3aWxsIGJlIGluZmVyZWQgZnJvbSB0aGUgaW5wdXQncyBcXFwicGF0dGVyblxcXCIgYXR0cmlidXRlLCBvciBpdCdzIFxcXCJ0eXBlXFxcIiBhdHRyaWJ1dGVcXG4gICAgICAgIHBhdHRlcm4gPSBwYXR0ZXJuIHx8ICRlbC5hdHRyKCdwYXR0ZXJuJykgfHwgJGVsLmF0dHIoJ3R5cGUnKTtcXG4gICAgICAgIHZhciBpbnB1dFRleHQgPSAkZWwudmFsKCk7XFxuICAgICAgICB2YXIgdmFsaWQgPSBmYWxzZTtcXG5cXG4gICAgICAgIGlmIChpbnB1dFRleHQubGVuZ3RoKSB7XFxuICAgICAgICAgIC8vIElmIHRoZSBwYXR0ZXJuIGF0dHJpYnV0ZSBvbiB0aGUgZWxlbWVudCBpcyBpbiBBYmlkZSdzIGxpc3Qgb2YgcGF0dGVybnMsIHRoZW4gdGVzdCB0aGF0IHJlZ2V4cFxcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhdHRlcm5zLmhhc093blByb3BlcnR5KHBhdHRlcm4pKSB7XFxuICAgICAgICAgICAgdmFsaWQgPSB0aGlzLm9wdGlvbnMucGF0dGVybnNbcGF0dGVybl0udGVzdChpbnB1dFRleHQpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIC8vIElmIHRoZSBwYXR0ZXJuIG5hbWUgaXNuJ3QgYWxzbyB0aGUgdHlwZSBhdHRyaWJ1dGUgb2YgdGhlIGZpZWxkLCB0aGVuIHRlc3QgaXQgYXMgYSByZWdleHBcXG4gICAgICAgICAgZWxzZSBpZiAocGF0dGVybiAhPT0gJGVsLmF0dHIoJ3R5cGUnKSkge1xcbiAgICAgICAgICAgICAgdmFsaWQgPSBuZXcgUmVnRXhwKHBhdHRlcm4pLnRlc3QoaW5wdXRUZXh0KTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgdmFsaWQgPSB0cnVlO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIC8vIEFuIGVtcHR5IGZpZWxkIGlzIHZhbGlkIGlmIGl0J3Mgbm90IHJlcXVpcmVkXFxuICAgICAgICBlbHNlIGlmICghJGVsLnByb3AoJ3JlcXVpcmVkJykpIHtcXG4gICAgICAgICAgICB2YWxpZCA9IHRydWU7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB2YWxpZDtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogRGV0ZXJtaW5lcyB3aGV0aGVyIG9yIGEgbm90IGEgcmFkaW8gaW5wdXQgaXMgdmFsaWQgYmFzZWQgb24gd2hldGhlciBvciBub3QgaXQgaXMgcmVxdWlyZWQgYW5kIHNlbGVjdGVkLiBBbHRob3VnaCB0aGUgZnVuY3Rpb24gdGFyZ2V0cyBhIHNpbmdsZSBgPGlucHV0PmAsIGl0IHZhbGlkYXRlcyBieSBjaGVja2luZyB0aGUgYHJlcXVpcmVkYCBhbmQgYGNoZWNrZWRgIHByb3BlcnRpZXMgb2YgYWxsIHJhZGlvIGJ1dHRvbnMgaW4gaXRzIGdyb3VwLlxcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBncm91cE5hbWUgLSBBIHN0cmluZyB0aGF0IHNwZWNpZmllcyB0aGUgbmFtZSBvZiBhIHJhZGlvIGJ1dHRvbiBncm91cFxcbiAgICAgICAqIEByZXR1cm5zIHtCb29sZWFufSBCb29sZWFuIHZhbHVlIGRlcGVuZHMgb24gd2hldGhlciBvciBub3QgYXQgbGVhc3Qgb25lIHJhZGlvIGlucHV0IGhhcyBiZWVuIHNlbGVjdGVkIChpZiBpdCdzIHJlcXVpcmVkKVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAndmFsaWRhdGVSYWRpbycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHZhbGlkYXRlUmFkaW8oZ3JvdXBOYW1lKSB7XFxuICAgICAgICAvLyBJZiBhdCBsZWFzdCBvbmUgcmFkaW8gaW4gdGhlIGdyb3VwIGhhcyB0aGUgYHJlcXVpcmVkYCBhdHRyaWJ1dGUsIHRoZSBncm91cCBpcyBjb25zaWRlcmVkIHJlcXVpcmVkXFxuICAgICAgICAvLyBQZXIgVzNDIHNwZWMsIGFsbCByYWRpbyBidXR0b25zIGluIGEgZ3JvdXAgc2hvdWxkIGhhdmUgYHJlcXVpcmVkYCwgYnV0IHdlJ3JlIGJlaW5nIG5pY2VcXG4gICAgICAgIHZhciAkZ3JvdXAgPSB0aGlzLiRlbGVtZW50LmZpbmQoJzpyYWRpb1tuYW1lPVxcXCInICsgZ3JvdXBOYW1lICsgJ1xcXCJdJyk7XFxuICAgICAgICB2YXIgdmFsaWQgPSBmYWxzZSxcXG4gICAgICAgICAgICByZXF1aXJlZCA9IGZhbHNlO1xcblxcbiAgICAgICAgLy8gRm9yIHRoZSBncm91cCB0byBiZSByZXF1aXJlZCwgYXQgbGVhc3Qgb25lIHJhZGlvIG5lZWRzIHRvIGJlIHJlcXVpcmVkXFxuICAgICAgICAkZ3JvdXAuZWFjaChmdW5jdGlvbiAoaSwgZSkge1xcbiAgICAgICAgICBpZiAoJChlKS5hdHRyKCdyZXF1aXJlZCcpKSB7XFxuICAgICAgICAgICAgcmVxdWlyZWQgPSB0cnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIGlmICghcmVxdWlyZWQpIHZhbGlkID0gdHJ1ZTtcXG5cXG4gICAgICAgIGlmICghdmFsaWQpIHtcXG4gICAgICAgICAgLy8gRm9yIHRoZSBncm91cCB0byBiZSB2YWxpZCwgYXQgbGVhc3Qgb25lIHJhZGlvIG5lZWRzIHRvIGJlIGNoZWNrZWRcXG4gICAgICAgICAgJGdyb3VwLmVhY2goZnVuY3Rpb24gKGksIGUpIHtcXG4gICAgICAgICAgICBpZiAoJChlKS5wcm9wKCdjaGVja2VkJykpIHtcXG4gICAgICAgICAgICAgIHZhbGlkID0gdHJ1ZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIHJldHVybiB2YWxpZDtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogRGV0ZXJtaW5lcyBpZiBhIHNlbGVjdGVkIGlucHV0IHBhc3NlcyBhIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9uLiBNdWx0aXBsZSB2YWxpZGF0aW9ucyBjYW4gYmUgdXNlZCwgaWYgcGFzc2VkIHRvIHRoZSBlbGVtZW50IHdpdGggYGRhdGEtdmFsaWRhdG9yPVxcXCJmb28gYmFyIGJhelxcXCJgIGluIGEgc3BhY2Ugc2VwYXJhdGVkIGxpc3RlZC5cXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gJGVsIC0galF1ZXJ5IGlucHV0IGVsZW1lbnQuXFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHZhbGlkYXRvcnMgLSBhIHN0cmluZyBvZiBmdW5jdGlvbiBuYW1lcyBtYXRjaGluZyBmdW5jdGlvbnMgaW4gdGhlIEFiaWRlLm9wdGlvbnMudmFsaWRhdG9ycyBvYmplY3QuXFxuICAgICAgICogQHBhcmFtIHtCb29sZWFufSByZXF1aXJlZCAtIHNlbGYgZXhwbGFuYXRvcnk/XFxuICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IC0gdHJ1ZSBpZiB2YWxpZGF0aW9ucyBwYXNzZWQuXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdtYXRjaFZhbGlkYXRpb24nLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBtYXRjaFZhbGlkYXRpb24oJGVsLCB2YWxpZGF0b3JzLCByZXF1aXJlZCkge1xcbiAgICAgICAgdmFyIF90aGlzNCA9IHRoaXM7XFxuXFxuICAgICAgICByZXF1aXJlZCA9IHJlcXVpcmVkID8gdHJ1ZSA6IGZhbHNlO1xcblxcbiAgICAgICAgdmFyIGNsZWFyID0gdmFsaWRhdG9ycy5zcGxpdCgnICcpLm1hcChmdW5jdGlvbiAodikge1xcbiAgICAgICAgICByZXR1cm4gX3RoaXM0Lm9wdGlvbnMudmFsaWRhdG9yc1t2XSgkZWwsIHJlcXVpcmVkLCAkZWwucGFyZW50KCkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gY2xlYXIuaW5kZXhPZihmYWxzZSkgPT09IC0xO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBSZXNldHMgZm9ybSBpbnB1dHMgYW5kIHN0eWxlc1xcbiAgICAgICAqIEBmaXJlcyBBYmlkZSNmb3JtcmVzZXRcXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ3Jlc2V0Rm9ybScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHJlc2V0Rm9ybSgpIHtcXG4gICAgICAgIHZhciAkZm9ybSA9IHRoaXMuJGVsZW1lbnQsXFxuICAgICAgICAgICAgb3B0cyA9IHRoaXMub3B0aW9ucztcXG5cXG4gICAgICAgICQoJy4nICsgb3B0cy5sYWJlbEVycm9yQ2xhc3MsICRmb3JtKS5ub3QoJ3NtYWxsJykucmVtb3ZlQ2xhc3Mob3B0cy5sYWJlbEVycm9yQ2xhc3MpO1xcbiAgICAgICAgJCgnLicgKyBvcHRzLmlucHV0RXJyb3JDbGFzcywgJGZvcm0pLm5vdCgnc21hbGwnKS5yZW1vdmVDbGFzcyhvcHRzLmlucHV0RXJyb3JDbGFzcyk7XFxuICAgICAgICAkKG9wdHMuZm9ybUVycm9yU2VsZWN0b3IgKyAnLicgKyBvcHRzLmZvcm1FcnJvckNsYXNzKS5yZW1vdmVDbGFzcyhvcHRzLmZvcm1FcnJvckNsYXNzKTtcXG4gICAgICAgICRmb3JtLmZpbmQoJ1tkYXRhLWFiaWRlLWVycm9yXScpLmNzcygnZGlzcGxheScsICdub25lJyk7XFxuICAgICAgICAkKCc6aW5wdXQnLCAkZm9ybSkubm90KCc6YnV0dG9uLCA6c3VibWl0LCA6cmVzZXQsIDpoaWRkZW4sIDpyYWRpbywgOmNoZWNrYm94LCBbZGF0YS1hYmlkZS1pZ25vcmVdJykudmFsKCcnKS5yZW1vdmVBdHRyKCdkYXRhLWludmFsaWQnKTtcXG4gICAgICAgICQoJzppbnB1dDpyYWRpbycsICRmb3JtKS5ub3QoJ1tkYXRhLWFiaWRlLWlnbm9yZV0nKS5wcm9wKCdjaGVja2VkJywgZmFsc2UpLnJlbW92ZUF0dHIoJ2RhdGEtaW52YWxpZCcpO1xcbiAgICAgICAgJCgnOmlucHV0OmNoZWNrYm94JywgJGZvcm0pLm5vdCgnW2RhdGEtYWJpZGUtaWdub3JlXScpLnByb3AoJ2NoZWNrZWQnLCBmYWxzZSkucmVtb3ZlQXR0cignZGF0YS1pbnZhbGlkJyk7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGZvcm0gaGFzIGJlZW4gcmVzZXQuXFxuICAgICAgICAgKiBAZXZlbnQgQWJpZGUjZm9ybXJlc2V0XFxuICAgICAgICAgKi9cXG4gICAgICAgICRmb3JtLnRyaWdnZXIoJ2Zvcm1yZXNldC56Zi5hYmlkZScsIFskZm9ybV0pO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBBYmlkZS5cXG4gICAgICAgKiBSZW1vdmVzIGVycm9yIHN0eWxlcyBhbmQgY2xhc3NlcyBmcm9tIGVsZW1lbnRzLCB3aXRob3V0IHJlc2V0dGluZyB0aGVpciB2YWx1ZXMuXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdkZXN0cm95JyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignLmFiaWRlJykuZmluZCgnW2RhdGEtYWJpZGUtZXJyb3JdJykuY3NzKCdkaXNwbGF5JywgJ25vbmUnKTtcXG5cXG4gICAgICAgIHRoaXMuJGlucHV0cy5vZmYoJy5hYmlkZScpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBfdGhpcy5yZW1vdmVFcnJvckNsYXNzZXMoJCh0aGlzKSk7XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcXG4gICAgICB9XFxuICAgIH1dKTtcXG5cXG4gICAgcmV0dXJuIEFiaWRlO1xcbiAgfSgpO1xcblxcbiAgLyoqXFxuICAgKiBEZWZhdWx0IHNldHRpbmdzIGZvciBwbHVnaW5cXG4gICAqL1xcblxcblxcbiAgQWJpZGUuZGVmYXVsdHMgPSB7XFxuICAgIC8qKlxcbiAgICAgKiBUaGUgZGVmYXVsdCBldmVudCB0byB2YWxpZGF0ZSBpbnB1dHMuIENoZWNrYm94ZXMgYW5kIHJhZGlvcyB2YWxpZGF0ZSBpbW1lZGlhdGVseS5cXG4gICAgICogUmVtb3ZlIG9yIGNoYW5nZSB0aGlzIHZhbHVlIGZvciBtYW51YWwgdmFsaWRhdGlvbi5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAnZmllbGRDaGFuZ2UnXFxuICAgICAqL1xcbiAgICB2YWxpZGF0ZU9uOiAnZmllbGRDaGFuZ2UnLFxcblxcbiAgICAvKipcXG4gICAgICogQ2xhc3MgdG8gYmUgYXBwbGllZCB0byBpbnB1dCBsYWJlbHMgb24gZmFpbGVkIHZhbGlkYXRpb24uXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgJ2lzLWludmFsaWQtbGFiZWwnXFxuICAgICAqL1xcbiAgICBsYWJlbEVycm9yQ2xhc3M6ICdpcy1pbnZhbGlkLWxhYmVsJyxcXG5cXG4gICAgLyoqXFxuICAgICAqIENsYXNzIHRvIGJlIGFwcGxpZWQgdG8gaW5wdXRzIG9uIGZhaWxlZCB2YWxpZGF0aW9uLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlICdpcy1pbnZhbGlkLWlucHV0J1xcbiAgICAgKi9cXG4gICAgaW5wdXRFcnJvckNsYXNzOiAnaXMtaW52YWxpZC1pbnB1dCcsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDbGFzcyBzZWxlY3RvciB0byB1c2UgdG8gdGFyZ2V0IEZvcm0gRXJyb3JzIGZvciBzaG93L2hpZGUuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgJy5mb3JtLWVycm9yJ1xcbiAgICAgKi9cXG4gICAgZm9ybUVycm9yU2VsZWN0b3I6ICcuZm9ybS1lcnJvcicsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBDbGFzcyBhZGRlZCB0byBGb3JtIEVycm9ycyBvbiBmYWlsZWQgdmFsaWRhdGlvbi5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAnaXMtdmlzaWJsZSdcXG4gICAgICovXFxuICAgIGZvcm1FcnJvckNsYXNzOiAnaXMtdmlzaWJsZScsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBTZXQgdG8gdHJ1ZSB0byB2YWxpZGF0ZSB0ZXh0IGlucHV0cyBvbiBhbnkgdmFsdWUgY2hhbmdlLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIGZhbHNlXFxuICAgICAqL1xcbiAgICBsaXZlVmFsaWRhdGU6IGZhbHNlLFxcblxcbiAgICBwYXR0ZXJuczoge1xcbiAgICAgIGFscGhhOiAvXlthLXpBLVpdKyQvLFxcbiAgICAgIGFscGhhX251bWVyaWM6IC9eW2EtekEtWjAtOV0rJC8sXFxuICAgICAgaW50ZWdlcjogL15bLStdP1xcXFxkKyQvLFxcbiAgICAgIG51bWJlcjogL15bLStdP1xcXFxkKig/OltcXFxcLlxcXFwsXVxcXFxkKyk/JC8sXFxuXFxuICAgICAgLy8gYW1leCwgdmlzYSwgZGluZXJzXFxuICAgICAgY2FyZDogL14oPzo0WzAtOV17MTJ9KD86WzAtOV17M30pP3w1WzEtNV1bMC05XXsxNH18Nig/OjAxMXw1WzAtOV1bMC05XSlbMC05XXsxMn18M1s0N11bMC05XXsxM318Myg/OjBbMC01XXxbNjhdWzAtOV0pWzAtOV17MTF9fCg/OjIxMzF8MTgwMHwzNVxcXFxkezN9KVxcXFxkezExfSkkLyxcXG4gICAgICBjdnY6IC9eKFswLTldKXszLDR9JC8sXFxuXFxuICAgICAgLy8gaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2Uvc3RhdGVzLW9mLXRoZS10eXBlLWF0dHJpYnV0ZS5odG1sI3ZhbGlkLWUtbWFpbC1hZGRyZXNzXFxuICAgICAgZW1haWw6IC9eW2EtekEtWjAtOS4hIyQlJicqK1xcXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcXFwuW2EtekEtWjAtOV0oPzpbYS16QS1aMC05LV17MCw2MX1bYS16QS1aMC05XSk/KSskLyxcXG5cXG4gICAgICB1cmw6IC9eKGh0dHBzP3xmdHB8ZmlsZXxzc2gpOlxcXFwvXFxcXC8oKCgoW2EtekEtWl18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCglW1xcXFxkYS1mXXsyfSl8WyFcXFxcJCYnXFxcXChcXFxcKVxcXFwqXFxcXCssOz1dfDopKkApPygoKFxcXFxkfFsxLTldXFxcXGR8MVxcXFxkXFxcXGR8MlswLTRdXFxcXGR8MjVbMC01XSlcXFxcLihcXFxcZHxbMS05XVxcXFxkfDFcXFxcZFxcXFxkfDJbMC00XVxcXFxkfDI1WzAtNV0pXFxcXC4oXFxcXGR8WzEtOV1cXFxcZHwxXFxcXGRcXFxcZHwyWzAtNF1cXFxcZHwyNVswLTVdKVxcXFwuKFxcXFxkfFsxLTldXFxcXGR8MVxcXFxkXFxcXGR8MlswLTRdXFxcXGR8MjVbMC01XSkpfCgoKFthLXpBLVpdfFxcXFxkfFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKXwoKFthLXpBLVpdfFxcXFxkfFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKShbYS16QS1aXXxcXFxcZHwtfFxcXFwufF98fnxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSkqKFthLXpBLVpdfFxcXFxkfFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKSkpXFxcXC4pKygoW2EtekEtWl18W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCgoW2EtekEtWl18W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKFthLXpBLVpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKSooW2EtekEtWl18W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKSlcXFxcLj8pKDpcXFxcZCopPykoXFxcXC8oKChbYS16QS1aXXxcXFxcZHwtfFxcXFwufF98fnxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSl8KCVbXFxcXGRhLWZdezJ9KXxbIVxcXFwkJidcXFxcKFxcXFwpXFxcXCpcXFxcKyw7PV18OnxAKSsoXFxcXC8oKFthLXpBLVpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKXwoJVtcXFxcZGEtZl17Mn0pfFshXFxcXCQmJ1xcXFwoXFxcXClcXFxcKlxcXFwrLDs9XXw6fEApKikqKT8pPyhcXFxcPygoKFthLXpBLVpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKXwoJVtcXFxcZGEtZl17Mn0pfFshXFxcXCQmJ1xcXFwoXFxcXClcXFxcKlxcXFwrLDs9XXw6fEApfFtcXFxcdUUwMDAtXFxcXHVGOEZGXXxcXFxcL3xcXFxcPykqKT8oXFxcXCMoKChbYS16QS1aXXxcXFxcZHwtfFxcXFwufF98fnxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSl8KCVbXFxcXGRhLWZdezJ9KXxbIVxcXFwkJidcXFxcKFxcXFwpXFxcXCpcXFxcKyw7PV18OnxAKXxcXFxcL3xcXFxcPykqKT8kLyxcXG4gICAgICAvLyBhYmMuZGVcXG4gICAgICBkb21haW46IC9eKFthLXpBLVowLTldKFthLXpBLVowLTlcXFxcLV17MCw2MX1bYS16QS1aMC05XSk/XFxcXC4pK1thLXpBLVpdezIsOH0kLyxcXG5cXG4gICAgICBkYXRldGltZTogL14oWzAtMl1bMC05XXszfSlcXFxcLShbMC0xXVswLTldKVxcXFwtKFswLTNdWzAtOV0pVChbMC01XVswLTldKVxcXFw6KFswLTVdWzAtOV0pXFxcXDooWzAtNV1bMC05XSkoWnwoW1xcXFwtXFxcXCtdKFswLTFdWzAtOV0pXFxcXDowMCkpJC8sXFxuICAgICAgLy8gWVlZWS1NTS1ERFxcbiAgICAgIGRhdGU6IC8oPzoxOXwyMClbMC05XXsyfS0oPzooPzowWzEtOV18MVswLTJdKS0oPzowWzEtOV18MVswLTldfDJbMC05XSl8KD86KD8hMDIpKD86MFsxLTldfDFbMC0yXSktKD86MzApKXwoPzooPzowWzEzNTc4XXwxWzAyXSktMzEpKSQvLFxcbiAgICAgIC8vIEhIOk1NOlNTXFxuICAgICAgdGltZTogL14oMFswLTldfDFbMC05XXwyWzAtM10pKDpbMC01XVswLTldKXsyfSQvLFxcbiAgICAgIGRhdGVJU086IC9eXFxcXGR7NH1bXFxcXC9cXFxcLV1cXFxcZHsxLDJ9W1xcXFwvXFxcXC1dXFxcXGR7MSwyfSQvLFxcbiAgICAgIC8vIE1NL0REL1lZWVlcXG4gICAgICBtb250aF9kYXlfeWVhcjogL14oMFsxLTldfDFbMDEyXSlbLSBcXFxcLy5dKDBbMS05XXxbMTJdWzAtOV18M1swMV0pWy0gXFxcXC8uXVxcXFxkezR9JC8sXFxuICAgICAgLy8gREQvTU0vWVlZWVxcbiAgICAgIGRheV9tb250aF95ZWFyOiAvXigwWzEtOV18WzEyXVswLTldfDNbMDFdKVstIFxcXFwvLl0oMFsxLTldfDFbMDEyXSlbLSBcXFxcLy5dXFxcXGR7NH0kLyxcXG5cXG4gICAgICAvLyAjRkZGIG9yICNGRkZGRkZcXG4gICAgICBjb2xvcjogL14jPyhbYS1mQS1GMC05XXs2fXxbYS1mQS1GMC05XXszfSkkL1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogT3B0aW9uYWwgdmFsaWRhdGlvbiBmdW5jdGlvbnMgdG8gYmUgdXNlZC4gYGVxdWFsVG9gIGJlaW5nIHRoZSBvbmx5IGRlZmF1bHQgaW5jbHVkZWQgZnVuY3Rpb24uXFxuICAgICAqIEZ1bmN0aW9ucyBzaG91bGQgcmV0dXJuIG9ubHkgYSBib29sZWFuIGlmIHRoZSBpbnB1dCBpcyB2YWxpZCBvciBub3QuIEZ1bmN0aW9ucyBhcmUgZ2l2ZW4gdGhlIGZvbGxvd2luZyBhcmd1bWVudHM6XFxuICAgICAqIGVsIDogVGhlIGpRdWVyeSBlbGVtZW50IHRvIHZhbGlkYXRlLlxcbiAgICAgKiByZXF1aXJlZCA6IEJvb2xlYW4gdmFsdWUgb2YgdGhlIHJlcXVpcmVkIGF0dHJpYnV0ZSBiZSBwcmVzZW50IG9yIG5vdC5cXG4gICAgICogcGFyZW50IDogVGhlIGRpcmVjdCBwYXJlbnQgb2YgdGhlIGlucHV0LlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqL1xcbiAgICB2YWxpZGF0b3JzOiB7XFxuICAgICAgZXF1YWxUbzogZnVuY3Rpb24gKGVsLCByZXF1aXJlZCwgcGFyZW50KSB7XFxuICAgICAgICByZXR1cm4gJCgnIycgKyBlbC5hdHRyKCdkYXRhLWVxdWFsdG8nKSkudmFsKCkgPT09IGVsLnZhbCgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfTtcXG5cXG4gIC8vIFdpbmRvdyBleHBvcnRzXFxuICBGb3VuZGF0aW9uLnBsdWdpbihBYmlkZSwgJ0FiaWRlJyk7XFxufShqUXVlcnkpO1xcbid1c2Ugc3RyaWN0JztcXG5cXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG4hZnVuY3Rpb24gKCQpIHtcXG5cXG4gIC8qKlxcbiAgICogQWNjb3JkaW9uIG1vZHVsZS5cXG4gICAqIEBtb2R1bGUgZm91bmRhdGlvbi5hY2NvcmRpb25cXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXFxuICAgKi9cXG5cXG4gIHZhciBBY2NvcmRpb24gPSBmdW5jdGlvbiAoKSB7XFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIGFjY29yZGlvbi5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBmaXJlcyBBY2NvcmRpb24jaW5pdFxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGFuIGFjY29yZGlvbi5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBhIHBsYWluIG9iamVjdCB3aXRoIHNldHRpbmdzIHRvIG92ZXJyaWRlIHRoZSBkZWZhdWx0IG9wdGlvbnMuXFxuICAgICAqL1xcblxcbiAgICBmdW5jdGlvbiBBY2NvcmRpb24oZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBY2NvcmRpb24pO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBBY2NvcmRpb24uZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuXFxuICAgICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnQWNjb3JkaW9uJyk7XFxuICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcignQWNjb3JkaW9uJywge1xcbiAgICAgICAgJ0VOVEVSJzogJ3RvZ2dsZScsXFxuICAgICAgICAnU1BBQ0UnOiAndG9nZ2xlJyxcXG4gICAgICAgICdBUlJPV19ET1dOJzogJ25leHQnLFxcbiAgICAgICAgJ0FSUk9XX1VQJzogJ3ByZXZpb3VzJ1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgYWNjb3JkaW9uIGJ5IGFuaW1hdGluZyB0aGUgcHJlc2V0IGFjdGl2ZSBwYW5lKHMpLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG5cXG4gICAgX2NyZWF0ZUNsYXNzKEFjY29yZGlvbiwgW3tcXG4gICAgICBrZXk6ICdfaW5pdCcsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdyb2xlJywgJ3RhYmxpc3QnKTtcXG4gICAgICAgIHRoaXMuJHRhYnMgPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKCdsaSwgW2RhdGEtYWNjb3JkaW9uLWl0ZW1dJyk7XFxuXFxuICAgICAgICB0aGlzLiR0YWJzLmVhY2goZnVuY3Rpb24gKGlkeCwgZWwpIHtcXG4gICAgICAgICAgdmFyICRlbCA9ICQoZWwpLFxcbiAgICAgICAgICAgICAgJGNvbnRlbnQgPSAkZWwuY2hpbGRyZW4oJ1tkYXRhLXRhYi1jb250ZW50XScpLFxcbiAgICAgICAgICAgICAgaWQgPSAkY29udGVudFswXS5pZCB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsICdhY2NvcmRpb24nKSxcXG4gICAgICAgICAgICAgIGxpbmtJZCA9IGVsLmlkIHx8IGlkICsgJy1sYWJlbCc7XFxuXFxuICAgICAgICAgICRlbC5maW5kKCdhOmZpcnN0JykuYXR0cih7XFxuICAgICAgICAgICAgJ2FyaWEtY29udHJvbHMnOiBpZCxcXG4gICAgICAgICAgICAncm9sZSc6ICd0YWInLFxcbiAgICAgICAgICAgICdpZCc6IGxpbmtJZCxcXG4gICAgICAgICAgICAnYXJpYS1leHBhbmRlZCc6IGZhbHNlLFxcbiAgICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogZmFsc2VcXG4gICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICRjb250ZW50LmF0dHIoeyAncm9sZSc6ICd0YWJwYW5lbCcsICdhcmlhLWxhYmVsbGVkYnknOiBsaW5rSWQsICdhcmlhLWhpZGRlbic6IHRydWUsICdpZCc6IGlkIH0pO1xcbiAgICAgICAgfSk7XFxuICAgICAgICB2YXIgJGluaXRBY3RpdmUgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5pcy1hY3RpdmUnKS5jaGlsZHJlbignW2RhdGEtdGFiLWNvbnRlbnRdJyk7XFxuICAgICAgICBpZiAoJGluaXRBY3RpdmUubGVuZ3RoKSB7XFxuICAgICAgICAgIHRoaXMuZG93bigkaW5pdEFjdGl2ZSwgdHJ1ZSk7XFxuICAgICAgICB9XFxuICAgICAgICB0aGlzLl9ldmVudHMoKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogQWRkcyBldmVudCBoYW5kbGVycyBmb3IgaXRlbXMgd2l0aGluIHRoZSBhY2NvcmRpb24uXFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ19ldmVudHMnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICAgIHRoaXMuJHRhYnMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciAkZWxlbSA9ICQodGhpcyk7XFxuICAgICAgICAgIHZhciAkdGFiQ29udGVudCA9ICRlbGVtLmNoaWxkcmVuKCdbZGF0YS10YWItY29udGVudF0nKTtcXG4gICAgICAgICAgaWYgKCR0YWJDb250ZW50Lmxlbmd0aCkge1xcbiAgICAgICAgICAgICRlbGVtLmNoaWxkcmVuKCdhJykub2ZmKCdjbGljay56Zi5hY2NvcmRpb24ga2V5ZG93bi56Zi5hY2NvcmRpb24nKS5vbignY2xpY2suemYuYWNjb3JkaW9uJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICAgIC8vICQodGhpcykuY2hpbGRyZW4oJ2EnKS5vbignY2xpY2suemYuYWNjb3JkaW9uJywgZnVuY3Rpb24oZSkge1xcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgICAgaWYgKCRlbGVtLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSkge1xcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5hbGxvd0FsbENsb3NlZCB8fCAkZWxlbS5zaWJsaW5ncygpLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSkge1xcbiAgICAgICAgICAgICAgICAgIF90aGlzLnVwKCR0YWJDb250ZW50KTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgX3RoaXMuZG93bigkdGFiQ29udGVudCk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSkub24oJ2tleWRvd24uemYuYWNjb3JkaW9uJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdBY2NvcmRpb24nLCB7XFxuICAgICAgICAgICAgICAgIHRvZ2dsZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgIF90aGlzLnRvZ2dsZSgkdGFiQ29udGVudCk7XFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIG5leHQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgICB2YXIgJGEgPSAkZWxlbS5uZXh0KCkuZmluZCgnYScpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLm11bHRpRXhwYW5kKSB7XFxuICAgICAgICAgICAgICAgICAgICAkYS50cmlnZ2VyKCdjbGljay56Zi5hY2NvcmRpb24nKTtcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICAgIHByZXZpb3VzOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgdmFyICRhID0gJGVsZW0ucHJldigpLmZpbmQoJ2EnKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgICAgIGlmICghX3RoaXMub3B0aW9ucy5tdWx0aUV4cGFuZCkge1xcbiAgICAgICAgICAgICAgICAgICAgJGEudHJpZ2dlcignY2xpY2suemYuYWNjb3JkaW9uJyk7XFxuICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgICBoYW5kbGVkOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogVG9nZ2xlcyB0aGUgc2VsZWN0ZWQgY29udGVudCBwYW5lJ3Mgb3Blbi9jbG9zZSBzdGF0ZS5cXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIGpRdWVyeSBvYmplY3Qgb2YgdGhlIHBhbmUgdG8gdG9nZ2xlLlxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAndG9nZ2xlJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCR0YXJnZXQpIHtcXG4gICAgICAgIGlmICgkdGFyZ2V0LnBhcmVudCgpLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSkge1xcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFsbG93QWxsQ2xvc2VkIHx8ICR0YXJnZXQucGFyZW50KCkuc2libGluZ3MoKS5oYXNDbGFzcygnaXMtYWN0aXZlJykpIHtcXG4gICAgICAgICAgICB0aGlzLnVwKCR0YXJnZXQpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5kb3duKCR0YXJnZXQpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBPcGVucyB0aGUgYWNjb3JkaW9uIHRhYiBkZWZpbmVkIGJ5IGAkdGFyZ2V0YC5cXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIEFjY29yZGlvbiBwYW5lIHRvIG9wZW4uXFxuICAgICAgICogQHBhcmFtIHtCb29sZWFufSBmaXJzdFRpbWUgLSBmbGFnIHRvIGRldGVybWluZSBpZiByZWZsb3cgc2hvdWxkIGhhcHBlbi5cXG4gICAgICAgKiBAZmlyZXMgQWNjb3JkaW9uI2Rvd25cXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ2Rvd24nLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkb3duKCR0YXJnZXQsIGZpcnN0VGltZSkge1xcbiAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XFxuXFxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5tdWx0aUV4cGFuZCAmJiAhZmlyc3RUaW1lKSB7XFxuICAgICAgICAgIHZhciAkY3VycmVudEFjdGl2ZSA9IHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJy5pcy1hY3RpdmUnKS5jaGlsZHJlbignW2RhdGEtdGFiLWNvbnRlbnRdJyk7XFxuICAgICAgICAgIGlmICgkY3VycmVudEFjdGl2ZS5sZW5ndGgpIHtcXG4gICAgICAgICAgICB0aGlzLnVwKCRjdXJyZW50QWN0aXZlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgJHRhcmdldC5hdHRyKCdhcmlhLWhpZGRlbicsIGZhbHNlKS5wYXJlbnQoJ1tkYXRhLXRhYi1jb250ZW50XScpLmFkZEJhY2soKS5wYXJlbnQoKS5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XFxuXFxuICAgICAgICAkdGFyZ2V0LnNsaWRlRG93bih0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAvKipcXG4gICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdGFiIGlzIGRvbmUgb3BlbmluZy5cXG4gICAgICAgICAgICogQGV2ZW50IEFjY29yZGlvbiNkb3duXFxuICAgICAgICAgICAqL1xcbiAgICAgICAgICBfdGhpczIuJGVsZW1lbnQudHJpZ2dlcignZG93bi56Zi5hY2NvcmRpb24nLCBbJHRhcmdldF0pO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICAkKCcjJyArICR0YXJnZXQuYXR0cignYXJpYS1sYWJlbGxlZGJ5JykpLmF0dHIoe1xcbiAgICAgICAgICAnYXJpYS1leHBhbmRlZCc6IHRydWUsXFxuICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogdHJ1ZVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIENsb3NlcyB0aGUgdGFiIGRlZmluZWQgYnkgYCR0YXJnZXRgLlxcbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkdGFyZ2V0IC0gQWNjb3JkaW9uIHRhYiB0byBjbG9zZS5cXG4gICAgICAgKiBAZmlyZXMgQWNjb3JkaW9uI3VwXFxuICAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICd1cCcsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwKCR0YXJnZXQpIHtcXG4gICAgICAgIHZhciAkYXVudHMgPSAkdGFyZ2V0LnBhcmVudCgpLnNpYmxpbmdzKCksXFxuICAgICAgICAgICAgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgdmFyIGNhbkNsb3NlID0gdGhpcy5vcHRpb25zLm11bHRpRXhwYW5kID8gJGF1bnRzLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSA6ICR0YXJnZXQucGFyZW50KCkuaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpO1xcblxcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuYWxsb3dBbGxDbG9zZWQgJiYgIWNhbkNsb3NlKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIEZvdW5kYXRpb24uTW92ZSh0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgJHRhcmdldCwgZnVuY3Rpb24oKXtcXG4gICAgICAgICR0YXJnZXQuc2xpZGVVcChfdGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgLyoqXFxuICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHRhYiBpcyBkb25lIGNvbGxhcHNpbmcgdXAuXFxuICAgICAgICAgICAqIEBldmVudCBBY2NvcmRpb24jdXBcXG4gICAgICAgICAgICovXFxuICAgICAgICAgIF90aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3VwLnpmLmFjY29yZGlvbicsIFskdGFyZ2V0XSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIC8vIH0pO1xcblxcbiAgICAgICAgJHRhcmdldC5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpLnBhcmVudCgpLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKTtcXG5cXG4gICAgICAgICQoJyMnICsgJHRhcmdldC5hdHRyKCdhcmlhLWxhYmVsbGVkYnknKSkuYXR0cih7XFxuICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogZmFsc2UsXFxuICAgICAgICAgICdhcmlhLXNlbGVjdGVkJzogZmFsc2VcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBhbiBhY2NvcmRpb24uXFxuICAgICAgICogQGZpcmVzIEFjY29yZGlvbiNkZXN0cm95ZWRcXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ2Rlc3Ryb3knLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS10YWItY29udGVudF0nKS5zdG9wKHRydWUpLnNsaWRlVXAoMCkuY3NzKCdkaXNwbGF5JywgJycpO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdhJykub2ZmKCcuemYuYWNjb3JkaW9uJyk7XFxuXFxuICAgICAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XFxuICAgICAgfVxcbiAgICB9XSk7XFxuXFxuICAgIHJldHVybiBBY2NvcmRpb247XFxuICB9KCk7XFxuXFxuICBBY2NvcmRpb24uZGVmYXVsdHMgPSB7XFxuICAgIC8qKlxcbiAgICAgKiBBbW91bnQgb2YgdGltZSB0byBhbmltYXRlIHRoZSBvcGVuaW5nIG9mIGFuIGFjY29yZGlvbiBwYW5lLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIDI1MFxcbiAgICAgKi9cXG4gICAgc2xpZGVTcGVlZDogMjUwLFxcbiAgICAvKipcXG4gICAgICogQWxsb3cgdGhlIGFjY29yZGlvbiB0byBoYXZlIG11bHRpcGxlIG9wZW4gcGFuZXMuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgZmFsc2VcXG4gICAgICovXFxuICAgIG11bHRpRXhwYW5kOiBmYWxzZSxcXG4gICAgLyoqXFxuICAgICAqIEFsbG93IHRoZSBhY2NvcmRpb24gdG8gY2xvc2UgYWxsIHBhbmVzLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIGZhbHNlXFxuICAgICAqL1xcbiAgICBhbGxvd0FsbENsb3NlZDogZmFsc2VcXG4gIH07XFxuXFxuICAvLyBXaW5kb3cgZXhwb3J0c1xcbiAgRm91bmRhdGlvbi5wbHVnaW4oQWNjb3JkaW9uLCAnQWNjb3JkaW9uJyk7XFxufShqUXVlcnkpO1xcbid1c2Ugc3RyaWN0JztcXG5cXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG4hZnVuY3Rpb24gKCQpIHtcXG5cXG4gIC8qKlxcbiAgICogQWNjb3JkaW9uTWVudSBtb2R1bGUuXFxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24uYWNjb3JkaW9uTWVudVxcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubmVzdFxcbiAgICovXFxuXFxuICB2YXIgQWNjb3JkaW9uTWVudSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gYWNjb3JkaW9uIG1lbnUuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAZmlyZXMgQWNjb3JkaW9uTWVudSNpbml0XFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYW4gYWNjb3JkaW9uIG1lbnUuXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cXG4gICAgICovXFxuXFxuICAgIGZ1bmN0aW9uIEFjY29yZGlvbk1lbnUoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBBY2NvcmRpb25NZW51KTtcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgQWNjb3JkaW9uTWVudS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcblxcbiAgICAgIEZvdW5kYXRpb24uTmVzdC5GZWF0aGVyKHRoaXMuJGVsZW1lbnQsICdhY2NvcmRpb24nKTtcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuXFxuICAgICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnQWNjb3JkaW9uTWVudScpO1xcbiAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoJ0FjY29yZGlvbk1lbnUnLCB7XFxuICAgICAgICAnRU5URVInOiAndG9nZ2xlJyxcXG4gICAgICAgICdTUEFDRSc6ICd0b2dnbGUnLFxcbiAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ29wZW4nLFxcbiAgICAgICAgJ0FSUk9XX1VQJzogJ3VwJyxcXG4gICAgICAgICdBUlJPV19ET1dOJzogJ2Rvd24nLFxcbiAgICAgICAgJ0FSUk9XX0xFRlQnOiAnY2xvc2UnLFxcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZUFsbCcsXFxuICAgICAgICAnVEFCJzogJ2Rvd24nLFxcbiAgICAgICAgJ1NISUZUX1RBQic6ICd1cCdcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGFjY29yZGlvbiBtZW51IGJ5IGhpZGluZyBhbGwgbmVzdGVkIG1lbnVzLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG5cXG4gICAgX2NyZWF0ZUNsYXNzKEFjY29yZGlvbk1lbnUsIFt7XFxuICAgICAga2V5OiAnX2luaXQnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtc3VibWVudV0nKS5ub3QoJy5pcy1hY3RpdmUnKS5zbGlkZVVwKDApOyAvLy5maW5kKCdhJykuY3NzKCdwYWRkaW5nLWxlZnQnLCAnMXJlbScpO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcXG4gICAgICAgICAgJ3JvbGUnOiAndGFibGlzdCcsXFxuICAgICAgICAgICdhcmlhLW11bHRpc2VsZWN0YWJsZSc6IHRoaXMub3B0aW9ucy5tdWx0aU9wZW5cXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgdGhpcy4kbWVudUxpbmtzID0gdGhpcy4kZWxlbWVudC5maW5kKCcuaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50Jyk7XFxuICAgICAgICB0aGlzLiRtZW51TGlua3MuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciBsaW5rSWQgPSB0aGlzLmlkIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgJ2FjYy1tZW51LWxpbmsnKSxcXG4gICAgICAgICAgICAgICRlbGVtID0gJCh0aGlzKSxcXG4gICAgICAgICAgICAgICRzdWIgPSAkZWxlbS5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKSxcXG4gICAgICAgICAgICAgIHN1YklkID0gJHN1YlswXS5pZCB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsICdhY2MtbWVudScpLFxcbiAgICAgICAgICAgICAgaXNBY3RpdmUgPSAkc3ViLmhhc0NsYXNzKCdpcy1hY3RpdmUnKTtcXG4gICAgICAgICAgJGVsZW0uYXR0cih7XFxuICAgICAgICAgICAgJ2FyaWEtY29udHJvbHMnOiBzdWJJZCxcXG4gICAgICAgICAgICAnYXJpYS1leHBhbmRlZCc6IGlzQWN0aXZlLFxcbiAgICAgICAgICAgICdyb2xlJzogJ3RhYicsXFxuICAgICAgICAgICAgJ2lkJzogbGlua0lkXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICAkc3ViLmF0dHIoe1xcbiAgICAgICAgICAgICdhcmlhLWxhYmVsbGVkYnknOiBsaW5rSWQsXFxuICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogIWlzQWN0aXZlLFxcbiAgICAgICAgICAgICdyb2xlJzogJ3RhYnBhbmVsJyxcXG4gICAgICAgICAgICAnaWQnOiBzdWJJZFxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgdmFyIGluaXRQYW5lcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLmlzLWFjdGl2ZScpO1xcbiAgICAgICAgaWYgKGluaXRQYW5lcy5sZW5ndGgpIHtcXG4gICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICAgICAgaW5pdFBhbmVzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIF90aGlzLmRvd24oJCh0aGlzKSk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgZm9yIGl0ZW1zIHdpdGhpbiB0aGUgbWVudS5cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX2V2ZW50cycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdsaScpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgJHN1Ym1lbnUgPSAkKHRoaXMpLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpO1xcblxcbiAgICAgICAgICBpZiAoJHN1Ym1lbnUubGVuZ3RoKSB7XFxuICAgICAgICAgICAgJCh0aGlzKS5jaGlsZHJlbignYScpLm9mZignY2xpY2suemYuYWNjb3JkaW9uTWVudScpLm9uKCdjbGljay56Zi5hY2NvcmRpb25NZW51JywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG5cXG4gICAgICAgICAgICAgIF90aGlzLnRvZ2dsZSgkc3VibWVudSk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pLm9uKCdrZXlkb3duLnpmLmFjY29yZGlvbm1lbnUnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICB2YXIgJGVsZW1lbnQgPSAkKHRoaXMpLFxcbiAgICAgICAgICAgICAgJGVsZW1lbnRzID0gJGVsZW1lbnQucGFyZW50KCd1bCcpLmNoaWxkcmVuKCdsaScpLFxcbiAgICAgICAgICAgICAgJHByZXZFbGVtZW50LFxcbiAgICAgICAgICAgICAgJG5leHRFbGVtZW50LFxcbiAgICAgICAgICAgICAgJHRhcmdldCA9ICRlbGVtZW50LmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpO1xcblxcbiAgICAgICAgICAkZWxlbWVudHMuZWFjaChmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgICAgIGlmICgkKHRoaXMpLmlzKCRlbGVtZW50KSkge1xcbiAgICAgICAgICAgICAgJHByZXZFbGVtZW50ID0gJGVsZW1lbnRzLmVxKE1hdGgubWF4KDAsIGkgLSAxKSkuZmluZCgnYScpLmZpcnN0KCk7XFxuICAgICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5taW4oaSArIDEsICRlbGVtZW50cy5sZW5ndGggLSAxKSkuZmluZCgnYScpLmZpcnN0KCk7XFxuXFxuICAgICAgICAgICAgICBpZiAoJCh0aGlzKS5jaGlsZHJlbignW2RhdGEtc3VibWVudV06dmlzaWJsZScpLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAvLyBoYXMgb3BlbiBzdWIgbWVudVxcbiAgICAgICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudC5maW5kKCdsaTpmaXJzdC1jaGlsZCcpLmZpbmQoJ2EnKS5maXJzdCgpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgaWYgKCQodGhpcykuaXMoJzpmaXJzdC1jaGlsZCcpKSB7XFxuICAgICAgICAgICAgICAgIC8vIGlzIGZpcnN0IGVsZW1lbnQgb2Ygc3ViIG1lbnVcXG4gICAgICAgICAgICAgICAgJHByZXZFbGVtZW50ID0gJGVsZW1lbnQucGFyZW50cygnbGknKS5maXJzdCgpLmZpbmQoJ2EnKS5maXJzdCgpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgkcHJldkVsZW1lbnQuY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdOnZpc2libGUnKS5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgLy8gaWYgcHJldmlvdXMgZWxlbWVudCBoYXMgb3BlbiBzdWIgbWVudVxcbiAgICAgICAgICAgICAgICAkcHJldkVsZW1lbnQgPSAkcHJldkVsZW1lbnQuZmluZCgnbGk6bGFzdC1jaGlsZCcpLmZpbmQoJ2EnKS5maXJzdCgpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgaWYgKCQodGhpcykuaXMoJzpsYXN0LWNoaWxkJykpIHtcXG4gICAgICAgICAgICAgICAgLy8gaXMgbGFzdCBlbGVtZW50IG9mIHN1YiBtZW51XFxuICAgICAgICAgICAgICAgICRuZXh0RWxlbWVudCA9ICRlbGVtZW50LnBhcmVudHMoJ2xpJykuZmlyc3QoKS5uZXh0KCdsaScpLmZpbmQoJ2EnKS5maXJzdCgpO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdBY2NvcmRpb25NZW51Jywge1xcbiAgICAgICAgICAgIG9wZW46IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIGlmICgkdGFyZ2V0LmlzKCc6aGlkZGVuJykpIHtcXG4gICAgICAgICAgICAgICAgX3RoaXMuZG93bigkdGFyZ2V0KTtcXG4gICAgICAgICAgICAgICAgJHRhcmdldC5maW5kKCdsaScpLmZpcnN0KCkuZmluZCgnYScpLmZpcnN0KCkuZm9jdXMoKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBpZiAoJHRhcmdldC5sZW5ndGggJiYgISR0YXJnZXQuaXMoJzpoaWRkZW4nKSkge1xcbiAgICAgICAgICAgICAgICAvLyBjbG9zZSBhY3RpdmUgc3ViIG9mIHRoaXMgaXRlbVxcbiAgICAgICAgICAgICAgICBfdGhpcy51cCgkdGFyZ2V0KTtcXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoJGVsZW1lbnQucGFyZW50KCdbZGF0YS1zdWJtZW51XScpLmxlbmd0aCkge1xcbiAgICAgICAgICAgICAgICAvLyBjbG9zZSBjdXJyZW50bHkgb3BlbiBzdWJcXG4gICAgICAgICAgICAgICAgX3RoaXMudXAoJGVsZW1lbnQucGFyZW50KCdbZGF0YS1zdWJtZW51XScpKTtcXG4gICAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50cygnbGknKS5maXJzdCgpLmZpbmQoJ2EnKS5maXJzdCgpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICB1cDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgJHByZXZFbGVtZW50LmF0dHIoJ3RhYmluZGV4JywgLTEpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGRvd246IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICRuZXh0RWxlbWVudC5hdHRyKCd0YWJpbmRleCcsIC0xKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICB0b2dnbGU6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIGlmICgkZWxlbWVudC5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKS5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgICAgX3RoaXMudG9nZ2xlKCRlbGVtZW50LmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGNsb3NlQWxsOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBfdGhpcy5oaWRlQWxsKCk7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBoYW5kbGVkOiBmdW5jdGlvbiAocHJldmVudERlZmF1bHQpIHtcXG4gICAgICAgICAgICAgIGlmIChwcmV2ZW50RGVmYXVsdCkge1xcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9KTsgLy8uYXR0cigndGFiaW5kZXgnLCAwKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogQ2xvc2VzIGFsbCBwYW5lcyBvZiB0aGUgbWVudS5cXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ2hpZGVBbGwnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlQWxsKCkge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1zdWJtZW51XScpLnNsaWRlVXAodGhpcy5vcHRpb25zLnNsaWRlU3BlZWQpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBUb2dnbGVzIHRoZSBvcGVuL2Nsb3NlIHN0YXRlIG9mIGEgc3VibWVudS5cXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIHRoZSBzdWJtZW51IHRvIHRvZ2dsZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAndG9nZ2xlJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCR0YXJnZXQpIHtcXG4gICAgICAgIGlmICghJHRhcmdldC5pcygnOmFuaW1hdGVkJykpIHtcXG4gICAgICAgICAgaWYgKCEkdGFyZ2V0LmlzKCc6aGlkZGVuJykpIHtcXG4gICAgICAgICAgICB0aGlzLnVwKCR0YXJnZXQpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHRoaXMuZG93bigkdGFyZ2V0KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBPcGVucyB0aGUgc3ViLW1lbnUgZGVmaW5lZCBieSBgJHRhcmdldGAuXFxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBTdWItbWVudSB0byBvcGVuLlxcbiAgICAgICAqIEBmaXJlcyBBY2NvcmRpb25NZW51I2Rvd25cXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ2Rvd24nLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkb3duKCR0YXJnZXQpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5tdWx0aU9wZW4pIHtcXG4gICAgICAgICAgdGhpcy51cCh0aGlzLiRlbGVtZW50LmZpbmQoJy5pcy1hY3RpdmUnKS5ub3QoJHRhcmdldC5wYXJlbnRzVW50aWwodGhpcy4kZWxlbWVudCkuYWRkKCR0YXJnZXQpKSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkdGFyZ2V0LmFkZENsYXNzKCdpcy1hY3RpdmUnKS5hdHRyKHsgJ2FyaWEtaGlkZGVuJzogZmFsc2UgfSkucGFyZW50KCcuaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50JykuYXR0cih7ICdhcmlhLWV4cGFuZGVkJzogdHJ1ZSB9KTtcXG5cXG4gICAgICAgIC8vRm91bmRhdGlvbi5Nb3ZlKHRoaXMub3B0aW9ucy5zbGlkZVNwZWVkLCAkdGFyZ2V0LCBmdW5jdGlvbigpIHtcXG4gICAgICAgICR0YXJnZXQuc2xpZGVEb3duKF90aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAvKipcXG4gICAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgbWVudSBpcyBkb25lIG9wZW5pbmcuXFxuICAgICAgICAgICAqIEBldmVudCBBY2NvcmRpb25NZW51I2Rvd25cXG4gICAgICAgICAgICovXFxuICAgICAgICAgIF90aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Rvd24uemYuYWNjb3JkaW9uTWVudScsIFskdGFyZ2V0XSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIC8vfSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIENsb3NlcyB0aGUgc3ViLW1lbnUgZGVmaW5lZCBieSBgJHRhcmdldGAuIEFsbCBzdWItbWVudXMgaW5zaWRlIHRoZSB0YXJnZXQgd2lsbCBiZSBjbG9zZWQgYXMgd2VsbC5cXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJHRhcmdldCAtIFN1Yi1tZW51IHRvIGNsb3NlLlxcbiAgICAgICAqIEBmaXJlcyBBY2NvcmRpb25NZW51I3VwXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICd1cCcsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHVwKCR0YXJnZXQpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICAvL0ZvdW5kYXRpb24uTW92ZSh0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgJHRhcmdldCwgZnVuY3Rpb24oKXtcXG4gICAgICAgICR0YXJnZXQuc2xpZGVVcChfdGhpcy5vcHRpb25zLnNsaWRlU3BlZWQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgLyoqXFxuICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG1lbnUgaXMgZG9uZSBjb2xsYXBzaW5nIHVwLlxcbiAgICAgICAgICAgKiBAZXZlbnQgQWNjb3JkaW9uTWVudSN1cFxcbiAgICAgICAgICAgKi9cXG4gICAgICAgICAgX3RoaXMuJGVsZW1lbnQudHJpZ2dlcigndXAuemYuYWNjb3JkaW9uTWVudScsIFskdGFyZ2V0XSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIC8vfSk7XFxuXFxuICAgICAgICB2YXIgJG1lbnVzID0gJHRhcmdldC5maW5kKCdbZGF0YS1zdWJtZW51XScpLnNsaWRlVXAoMCkuYWRkQmFjaygpLmF0dHIoJ2FyaWEtaGlkZGVuJywgdHJ1ZSk7XFxuXFxuICAgICAgICAkbWVudXMucGFyZW50KCcuaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50JykuYXR0cignYXJpYS1leHBhbmRlZCcsIGZhbHNlKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgYWNjb3JkaW9uIG1lbnUuXFxuICAgICAgICogQGZpcmVzIEFjY29yZGlvbk1lbnUjZGVzdHJveWVkXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdkZXN0cm95JyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtc3VibWVudV0nKS5zbGlkZURvd24oMCkuY3NzKCdkaXNwbGF5JywgJycpO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdhJykub2ZmKCdjbGljay56Zi5hY2NvcmRpb25NZW51Jyk7XFxuXFxuICAgICAgICBGb3VuZGF0aW9uLk5lc3QuQnVybih0aGlzLiRlbGVtZW50LCAnYWNjb3JkaW9uJyk7XFxuICAgICAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XFxuICAgICAgfVxcbiAgICB9XSk7XFxuXFxuICAgIHJldHVybiBBY2NvcmRpb25NZW51O1xcbiAgfSgpO1xcblxcbiAgQWNjb3JkaW9uTWVudS5kZWZhdWx0cyA9IHtcXG4gICAgLyoqXFxuICAgICAqIEFtb3VudCBvZiB0aW1lIHRvIGFuaW1hdGUgdGhlIG9wZW5pbmcgb2YgYSBzdWJtZW51IGluIG1zLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIDI1MFxcbiAgICAgKi9cXG4gICAgc2xpZGVTcGVlZDogMjUwLFxcbiAgICAvKipcXG4gICAgICogQWxsb3cgdGhlIG1lbnUgdG8gaGF2ZSBtdWx0aXBsZSBvcGVuIHBhbmVzLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIHRydWVcXG4gICAgICovXFxuICAgIG11bHRpT3BlbjogdHJ1ZVxcbiAgfTtcXG5cXG4gIC8vIFdpbmRvdyBleHBvcnRzXFxuICBGb3VuZGF0aW9uLnBsdWdpbihBY2NvcmRpb25NZW51LCAnQWNjb3JkaW9uTWVudScpO1xcbn0oalF1ZXJ5KTtcXG4ndXNlIHN0cmljdCc7XFxuXFxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuIWZ1bmN0aW9uICgkKSB7XFxuXFxuICAvKipcXG4gICAqIERyaWxsZG93biBtb2R1bGUuXFxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24uZHJpbGxkb3duXFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5uZXN0XFxuICAgKi9cXG5cXG4gIHZhciBEcmlsbGRvd24gPSBmdW5jdGlvbiAoKSB7XFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgZHJpbGxkb3duIG1lbnUuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGFuIGFjY29yZGlvbiBtZW51LlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcblxcbiAgICBmdW5jdGlvbiBEcmlsbGRvd24oZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcmlsbGRvd24pO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBEcmlsbGRvd24uZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG5cXG4gICAgICBGb3VuZGF0aW9uLk5lc3QuRmVhdGhlcih0aGlzLiRlbGVtZW50LCAnZHJpbGxkb3duJyk7XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcblxcbiAgICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ0RyaWxsZG93bicpO1xcbiAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoJ0RyaWxsZG93bicsIHtcXG4gICAgICAgICdFTlRFUic6ICdvcGVuJyxcXG4gICAgICAgICdTUEFDRSc6ICdvcGVuJyxcXG4gICAgICAgICdBUlJPV19SSUdIVCc6ICduZXh0JyxcXG4gICAgICAgICdBUlJPV19VUCc6ICd1cCcsXFxuICAgICAgICAnQVJST1dfRE9XTic6ICdkb3duJyxcXG4gICAgICAgICdBUlJPV19MRUZUJzogJ3ByZXZpb3VzJyxcXG4gICAgICAgICdFU0NBUEUnOiAnY2xvc2UnLFxcbiAgICAgICAgJ1RBQic6ICdkb3duJyxcXG4gICAgICAgICdTSElGVF9UQUInOiAndXAnXFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSBkcmlsbGRvd24gYnkgY3JlYXRpbmcgalF1ZXJ5IGNvbGxlY3Rpb25zIG9mIGVsZW1lbnRzXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcblxcbiAgICBfY3JlYXRlQ2xhc3MoRHJpbGxkb3duLCBbe1xcbiAgICAgIGtleTogJ19pbml0JyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgICB0aGlzLiRzdWJtZW51QW5jaG9ycyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnbGkuaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50JykuY2hpbGRyZW4oJ2EnKTtcXG4gICAgICAgIHRoaXMuJHN1Ym1lbnVzID0gdGhpcy4kc3VibWVudUFuY2hvcnMucGFyZW50KCdsaScpLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpO1xcbiAgICAgICAgdGhpcy4kbWVudUl0ZW1zID0gdGhpcy4kZWxlbWVudC5maW5kKCdsaScpLm5vdCgnLmpzLWRyaWxsZG93bi1iYWNrJykuYXR0cigncm9sZScsICdtZW51aXRlbScpLmZpbmQoJ2EnKTtcXG5cXG4gICAgICAgIHRoaXMuX3ByZXBhcmVNZW51KCk7XFxuXFxuICAgICAgICB0aGlzLl9rZXlib2FyZEV2ZW50cygpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBwcmVwYXJlcyBkcmlsbGRvd24gbWVudSBieSBzZXR0aW5nIGF0dHJpYnV0ZXMgdG8gbGlua3MgYW5kIGVsZW1lbnRzXFxuICAgICAgICogc2V0cyBhIG1pbiBoZWlnaHQgdG8gcHJldmVudCBjb250ZW50IGp1bXBpbmdcXG4gICAgICAgKiB3cmFwcyB0aGUgZWxlbWVudCBpZiBub3QgYWxyZWFkeSB3cmFwcGVkXFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ19wcmVwYXJlTWVudScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wcmVwYXJlTWVudSgpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICAvLyBpZighdGhpcy5vcHRpb25zLmhvbGRPcGVuKXtcXG4gICAgICAgIC8vICAgdGhpcy5fbWVudUxpbmtFdmVudHMoKTtcXG4gICAgICAgIC8vIH1cXG4gICAgICAgIHRoaXMuJHN1Ym1lbnVBbmNob3JzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgJGxpbmsgPSAkKHRoaXMpO1xcbiAgICAgICAgICB2YXIgJHN1YiA9ICRsaW5rLnBhcmVudCgpO1xcbiAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5wYXJlbnRMaW5rKSB7XFxuICAgICAgICAgICAgJGxpbmsuY2xvbmUoKS5wcmVwZW5kVG8oJHN1Yi5jaGlsZHJlbignW2RhdGEtc3VibWVudV0nKSkud3JhcCgnPGxpIGNsYXNzPVxcXCJpcy1zdWJtZW51LXBhcmVudC1pdGVtIGlzLXN1Ym1lbnUtaXRlbSBpcy1kcmlsbGRvd24tc3VibWVudS1pdGVtXFxcIiByb2xlPVxcXCJtZW51LWl0ZW1cXFwiPjwvbGk+Jyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgJGxpbmsuZGF0YSgnc2F2ZWRIcmVmJywgJGxpbmsuYXR0cignaHJlZicpKS5yZW1vdmVBdHRyKCdocmVmJyk7XFxuICAgICAgICAgICRsaW5rLmNoaWxkcmVuKCdbZGF0YS1zdWJtZW51XScpLmF0dHIoe1xcbiAgICAgICAgICAgICdhcmlhLWhpZGRlbic6IHRydWUsXFxuICAgICAgICAgICAgJ3RhYmluZGV4JzogMCxcXG4gICAgICAgICAgICAncm9sZSc6ICdtZW51J1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgX3RoaXMuX2V2ZW50cygkbGluayk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHRoaXMuJHN1Ym1lbnVzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgJG1lbnUgPSAkKHRoaXMpLFxcbiAgICAgICAgICAgICAgJGJhY2sgPSAkbWVudS5maW5kKCcuanMtZHJpbGxkb3duLWJhY2snKTtcXG4gICAgICAgICAgaWYgKCEkYmFjay5sZW5ndGgpIHtcXG4gICAgICAgICAgICAkbWVudS5wcmVwZW5kKF90aGlzLm9wdGlvbnMuYmFja0J1dHRvbik7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgX3RoaXMuX2JhY2soJG1lbnUpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICBpZiAoIXRoaXMuJGVsZW1lbnQucGFyZW50KCkuaGFzQ2xhc3MoJ2lzLWRyaWxsZG93bicpKSB7XFxuICAgICAgICAgIHRoaXMuJHdyYXBwZXIgPSAkKHRoaXMub3B0aW9ucy53cmFwcGVyKS5hZGRDbGFzcygnaXMtZHJpbGxkb3duJyk7XFxuICAgICAgICAgIHRoaXMuJHdyYXBwZXIgPSB0aGlzLiRlbGVtZW50LndyYXAodGhpcy4kd3JhcHBlcikucGFyZW50KCkuY3NzKHRoaXMuX2dldE1heERpbXMoKSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgdG8gZWxlbWVudHMgaW4gdGhlIG1lbnUuXFxuICAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgY3VycmVudCBtZW51IGl0ZW0gdG8gYWRkIGhhbmRsZXJzIHRvLlxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX2V2ZW50cycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoJGVsZW0pIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgICAkZWxlbS5vZmYoJ2NsaWNrLnpmLmRyaWxsZG93bicpLm9uKCdjbGljay56Zi5kcmlsbGRvd24nLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBpZiAoJChlLnRhcmdldCkucGFyZW50c1VudGlsKCd1bCcsICdsaScpLmhhc0NsYXNzKCdpcy1kcmlsbGRvd24tc3VibWVudS1wYXJlbnQnKSkge1xcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIC8vIGlmKGUudGFyZ2V0ICE9PSBlLmN1cnJlbnRUYXJnZXQuZmlyc3RFbGVtZW50Q2hpbGQpe1xcbiAgICAgICAgICAvLyAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgLy8gfVxcbiAgICAgICAgICBfdGhpcy5fc2hvdygkZWxlbS5wYXJlbnQoJ2xpJykpO1xcblxcbiAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spIHtcXG4gICAgICAgICAgICB2YXIgJGJvZHkgPSAkKCdib2R5Jyk7XFxuICAgICAgICAgICAgJGJvZHkub2ZmKCcuemYuZHJpbGxkb3duJykub24oJ2NsaWNrLnpmLmRyaWxsZG93bicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IF90aGlzLiRlbGVtZW50WzBdIHx8ICQuY29udGFpbnMoX3RoaXMuJGVsZW1lbnRbMF0sIGUudGFyZ2V0KSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgICBfdGhpcy5faGlkZUFsbCgpO1xcbiAgICAgICAgICAgICAgJGJvZHkub2ZmKCcuemYuZHJpbGxkb3duJyk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBBZGRzIGtleWRvd24gZXZlbnQgbGlzdGVuZXIgdG8gYGxpYCdzIGluIHRoZSBtZW51LlxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfa2V5Ym9hcmRFdmVudHMnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfa2V5Ym9hcmRFdmVudHMoKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgICAgdGhpcy4kbWVudUl0ZW1zLmFkZCh0aGlzLiRlbGVtZW50LmZpbmQoJy5qcy1kcmlsbGRvd24tYmFjayA+IGEnKSkub24oJ2tleWRvd24uemYuZHJpbGxkb3duJywgZnVuY3Rpb24gKGUpIHtcXG5cXG4gICAgICAgICAgdmFyICRlbGVtZW50ID0gJCh0aGlzKSxcXG4gICAgICAgICAgICAgICRlbGVtZW50cyA9ICRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykuY2hpbGRyZW4oJ2xpJykuY2hpbGRyZW4oJ2EnKSxcXG4gICAgICAgICAgICAgICRwcmV2RWxlbWVudCxcXG4gICAgICAgICAgICAgICRuZXh0RWxlbWVudDtcXG5cXG4gICAgICAgICAgJGVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgICAgICBpZiAoJCh0aGlzKS5pcygkZWxlbWVudCkpIHtcXG4gICAgICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRlbGVtZW50cy5lcShNYXRoLm1heCgwLCBpIC0gMSkpO1xcbiAgICAgICAgICAgICAgJG5leHRFbGVtZW50ID0gJGVsZW1lbnRzLmVxKE1hdGgubWluKGkgKyAxLCAkZWxlbWVudHMubGVuZ3RoIC0gMSkpO1xcbiAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdEcmlsbGRvd24nLCB7XFxuICAgICAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgaWYgKCRlbGVtZW50LmlzKF90aGlzLiRzdWJtZW51QW5jaG9ycykpIHtcXG4gICAgICAgICAgICAgICAgX3RoaXMuX3Nob3coJGVsZW1lbnQucGFyZW50KCdsaScpKTtcXG4gICAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQoJGVsZW1lbnQpLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLmZpbmQoJ3VsIGxpIGEnKS5maWx0ZXIoX3RoaXMuJG1lbnVJdGVtcykuZmlyc3QoKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBwcmV2aW91czogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgX3RoaXMuX2hpZGUoJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKSk7XFxuICAgICAgICAgICAgICAkZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQoJGVsZW1lbnQpLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5wYXJlbnQoJ3VsJykucGFyZW50KCdsaScpLmNoaWxkcmVuKCdhJykuZmlyc3QoKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgICB9LCAxKTtcXG4gICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICB1cDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgJHByZXZFbGVtZW50LmZvY3VzKCk7XFxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGRvd246IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICRuZXh0RWxlbWVudC5mb2N1cygpO1xcbiAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgX3RoaXMuX2JhY2soKTtcXG4gICAgICAgICAgICAgIC8vX3RoaXMuJG1lbnVJdGVtcy5maXJzdCgpLmZvY3VzKCk7IC8vIGZvY3VzIHRvIGZpcnN0IGVsZW1lbnRcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIG9wZW46IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIGlmICghJGVsZW1lbnQuaXMoX3RoaXMuJG1lbnVJdGVtcykpIHtcXG4gICAgICAgICAgICAgICAgLy8gbm90IG1lbnUgaXRlbSBtZWFucyBiYWNrIGJ1dHRvblxcbiAgICAgICAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbWVudC5wYXJlbnQoJ2xpJykucGFyZW50KCd1bCcpKTtcXG4gICAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKCRlbGVtZW50KSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICAgJGVsZW1lbnQucGFyZW50KCdsaScpLnBhcmVudCgndWwnKS5wYXJlbnQoJ2xpJykuY2hpbGRyZW4oJ2EnKS5maXJzdCgpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICAgICAgfSwgMSk7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgkZWxlbWVudC5pcyhfdGhpcy4kc3VibWVudUFuY2hvcnMpKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLl9zaG93KCRlbGVtZW50LnBhcmVudCgnbGknKSk7XFxuICAgICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKCRlbGVtZW50KSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICAgICRlbGVtZW50LnBhcmVudCgnbGknKS5maW5kKCd1bCBsaSBhJykuZmlsdGVyKF90aGlzLiRtZW51SXRlbXMpLmZpcnN0KCkuZm9jdXMoKTtcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uIChwcmV2ZW50RGVmYXVsdCkge1xcbiAgICAgICAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XFxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0pOyAvLyBlbmQga2V5Ym9hcmRBY2Nlc3NcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogQ2xvc2VzIGFsbCBvcGVuIGVsZW1lbnRzLCBhbmQgcmV0dXJucyB0byByb290IG1lbnUuXFxuICAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgICogQGZpcmVzIERyaWxsZG93biNjbG9zZWRcXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ19oaWRlQWxsJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGVBbGwoKSB7XFxuICAgICAgICB2YXIgJGVsZW0gPSB0aGlzLiRlbGVtZW50LmZpbmQoJy5pcy1kcmlsbGRvd24tc3VibWVudS5pcy1hY3RpdmUnKS5hZGRDbGFzcygnaXMtY2xvc2luZycpO1xcbiAgICAgICAgJGVsZW0ub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZCgkZWxlbSksIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgICRlbGVtLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUgaXMtY2xvc2luZycpO1xcbiAgICAgICAgfSk7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIG1lbnUgaXMgZnVsbHkgY2xvc2VkLlxcbiAgICAgICAgICogQGV2ZW50IERyaWxsZG93biNjbG9zZWRcXG4gICAgICAgICAqL1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZWQuemYuZHJpbGxkb3duJyk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXIgZm9yIGVhY2ggYGJhY2tgIGJ1dHRvbiwgYW5kIGNsb3NlcyBvcGVuIG1lbnVzLlxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqIEBmaXJlcyBEcmlsbGRvd24jYmFja1xcbiAgICAgICAqIEBwYXJhbSB7alF1ZXJ5fSAkZWxlbSAtIHRoZSBjdXJyZW50IHN1Yi1tZW51IHRvIGFkZCBgYmFja2AgZXZlbnQuXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfYmFjaycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9iYWNrKCRlbGVtKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgJGVsZW0ub2ZmKCdjbGljay56Zi5kcmlsbGRvd24nKTtcXG4gICAgICAgICRlbGVtLmNoaWxkcmVuKCcuanMtZHJpbGxkb3duLWJhY2snKS5vbignY2xpY2suemYuZHJpbGxkb3duJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgLy8gY29uc29sZS5sb2coJ21vdXNldXAgb24gYmFjaycpO1xcbiAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbSk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogQWRkcyBldmVudCBsaXN0ZW5lciB0byBtZW51IGl0ZW1zIHcvbyBzdWJtZW51cyB0byBjbG9zZSBvcGVuIG1lbnVzIG9uIGNsaWNrLlxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfbWVudUxpbmtFdmVudHMnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfbWVudUxpbmtFdmVudHMoKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgdGhpcy4kbWVudUl0ZW1zLm5vdCgnLmlzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudCcpLm9mZignY2xpY2suemYuZHJpbGxkb3duJykub24oJ2NsaWNrLnpmLmRyaWxsZG93bicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIC8vIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIF90aGlzLl9oaWRlQWxsKCk7XFxuICAgICAgICAgIH0sIDApO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIE9wZW5zIGEgc3VibWVudS5cXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKiBAZmlyZXMgRHJpbGxkb3duI29wZW5cXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgY3VycmVudCBlbGVtZW50IHdpdGggYSBzdWJtZW51IHRvIG9wZW4sIGkuZS4gdGhlIGBsaWAgdGFnLlxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX3Nob3cnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hvdygkZWxlbSkge1xcbiAgICAgICAgJGVsZW0uY2hpbGRyZW4oJ1tkYXRhLXN1Ym1lbnVdJykuYWRkQ2xhc3MoJ2lzLWFjdGl2ZScpO1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBzdWJtZW51IGhhcyBvcGVuZWQuXFxuICAgICAgICAgKiBAZXZlbnQgRHJpbGxkb3duI29wZW5cXG4gICAgICAgICAqL1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdvcGVuLnpmLmRyaWxsZG93bicsIFskZWxlbV0pO1xcbiAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ19oaWRlJyxcXG5cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBIaWRlcyBhIHN1Ym1lbnVcXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKiBAZmlyZXMgRHJpbGxkb3duI2hpZGVcXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGVsZW0gLSB0aGUgY3VycmVudCBzdWItbWVudSB0byBoaWRlLCBpLmUuIHRoZSBgdWxgIHRhZy5cXG4gICAgICAgKi9cXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2hpZGUoJGVsZW0pIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICAkZWxlbS5hZGRDbGFzcygnaXMtY2xvc2luZycpLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQoJGVsZW0pLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICRlbGVtLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUgaXMtY2xvc2luZycpO1xcbiAgICAgICAgICAkZWxlbS5ibHVyKCk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgc3VibWVudSBoYXMgY2xvc2VkLlxcbiAgICAgICAgICogQGV2ZW50IERyaWxsZG93biNoaWRlXFxuICAgICAgICAgKi9cXG4gICAgICAgICRlbGVtLnRyaWdnZXIoJ2hpZGUuemYuZHJpbGxkb3duJywgWyRlbGVtXSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEl0ZXJhdGVzIHRocm91Z2ggdGhlIG5lc3RlZCBtZW51cyB0byBjYWxjdWxhdGUgdGhlIG1pbi1oZWlnaHQsIGFuZCBtYXgtd2lkdGggZm9yIHRoZSBtZW51LlxcbiAgICAgICAqIFByZXZlbnRzIGNvbnRlbnQganVtcGluZy5cXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX2dldE1heERpbXMnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0TWF4RGltcygpIHtcXG4gICAgICAgIHZhciBtYXggPSAwLFxcbiAgICAgICAgICAgIHJlc3VsdCA9IHt9O1xcbiAgICAgICAgdGhpcy4kc3VibWVudXMuYWRkKHRoaXMuJGVsZW1lbnQpLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgbnVtT2ZFbGVtcyA9ICQodGhpcykuY2hpbGRyZW4oJ2xpJykubGVuZ3RoO1xcbiAgICAgICAgICBtYXggPSBudW1PZkVsZW1zID4gbWF4ID8gbnVtT2ZFbGVtcyA6IG1heDtcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgcmVzdWx0WydtaW4taGVpZ2h0J10gPSBtYXggKiB0aGlzLiRtZW51SXRlbXNbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0ICsgJ3B4JztcXG4gICAgICAgIHJlc3VsdFsnbWF4LXdpZHRoJ10gPSB0aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICsgJ3B4JztcXG5cXG4gICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIERlc3Ryb3lzIHRoZSBEcmlsbGRvd24gTWVudVxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnZGVzdHJveScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuICAgICAgICB0aGlzLl9oaWRlQWxsKCk7XFxuICAgICAgICBGb3VuZGF0aW9uLk5lc3QuQnVybih0aGlzLiRlbGVtZW50LCAnZHJpbGxkb3duJyk7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LnVud3JhcCgpLmZpbmQoJy5qcy1kcmlsbGRvd24tYmFjaywgLmlzLXN1Ym1lbnUtcGFyZW50LWl0ZW0nKS5yZW1vdmUoKS5lbmQoKS5maW5kKCcuaXMtYWN0aXZlLCAuaXMtY2xvc2luZywgLmlzLWRyaWxsZG93bi1zdWJtZW51JykucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZSBpcy1jbG9zaW5nIGlzLWRyaWxsZG93bi1zdWJtZW51JykuZW5kKCkuZmluZCgnW2RhdGEtc3VibWVudV0nKS5yZW1vdmVBdHRyKCdhcmlhLWhpZGRlbiB0YWJpbmRleCByb2xlJyk7XFxuICAgICAgICB0aGlzLiRzdWJtZW51QW5jaG9ycy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgJCh0aGlzKS5vZmYoJy56Zi5kcmlsbGRvd24nKTtcXG4gICAgICAgIH0pO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5maW5kKCdhJykuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciAkbGluayA9ICQodGhpcyk7XFxuICAgICAgICAgIGlmICgkbGluay5kYXRhKCdzYXZlZEhyZWYnKSkge1xcbiAgICAgICAgICAgICRsaW5rLmF0dHIoJ2hyZWYnLCAkbGluay5kYXRhKCdzYXZlZEhyZWYnKSkucmVtb3ZlRGF0YSgnc2F2ZWRIcmVmJyk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcXG4gICAgICB9XFxuICAgIH1dKTtcXG5cXG4gICAgcmV0dXJuIERyaWxsZG93bjtcXG4gIH0oKTtcXG5cXG4gIERyaWxsZG93bi5kZWZhdWx0cyA9IHtcXG4gICAgLyoqXFxuICAgICAqIE1hcmt1cCB1c2VkIGZvciBKUyBnZW5lcmF0ZWQgYmFjayBidXR0b24uIFByZXBlbmRlZCB0byBzdWJtZW51IGxpc3RzIGFuZCBkZWxldGVkIG9uIGBkZXN0cm95YCBtZXRob2QsICdqcy1kcmlsbGRvd24tYmFjaycgY2xhc3MgcmVxdWlyZWQuIFJlbW92ZSB0aGUgYmFja3NsYXNoIChgXFxcXGApIGlmIGNvcHkgYW5kIHBhc3RpbmcuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgJzxcXFxcbGk+PFxcXFxhPkJhY2s8XFxcXC9hPjxcXFxcL2xpPidcXG4gICAgICovXFxuICAgIGJhY2tCdXR0b246ICc8bGkgY2xhc3M9XFxcImpzLWRyaWxsZG93bi1iYWNrXFxcIj48YSB0YWJpbmRleD1cXFwiMFxcXCI+QmFjazwvYT48L2xpPicsXFxuICAgIC8qKlxcbiAgICAgKiBNYXJrdXAgdXNlZCB0byB3cmFwIGRyaWxsZG93biBtZW51LiBVc2UgYSBjbGFzcyBuYW1lIGZvciBpbmRlcGVuZGVudCBzdHlsaW5nOyB0aGUgSlMgYXBwbGllZCBjbGFzczogYGlzLWRyaWxsZG93bmAgaXMgcmVxdWlyZWQuIFJlbW92ZSB0aGUgYmFja3NsYXNoIChgXFxcXGApIGlmIGNvcHkgYW5kIHBhc3RpbmcuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgJzxcXFxcZGl2IGNsYXNzPVxcXCJpcy1kcmlsbGRvd25cXFwiPjxcXFxcL2Rpdj4nXFxuICAgICAqL1xcbiAgICB3cmFwcGVyOiAnPGRpdj48L2Rpdj4nLFxcbiAgICAvKipcXG4gICAgICogQWRkcyB0aGUgcGFyZW50IGxpbmsgdG8gdGhlIHN1Ym1lbnUuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgZmFsc2VcXG4gICAgICovXFxuICAgIHBhcmVudExpbms6IGZhbHNlLFxcbiAgICAvKipcXG4gICAgICogQWxsb3cgdGhlIG1lbnUgdG8gcmV0dXJuIHRvIHJvb3QgbGlzdCBvbiBib2R5IGNsaWNrLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIGZhbHNlXFxuICAgICAqL1xcbiAgICBjbG9zZU9uQ2xpY2s6IGZhbHNlXFxuICAgIC8vIGhvbGRPcGVuOiBmYWxzZVxcbiAgfTtcXG5cXG4gIC8vIFdpbmRvdyBleHBvcnRzXFxuICBGb3VuZGF0aW9uLnBsdWdpbihEcmlsbGRvd24sICdEcmlsbGRvd24nKTtcXG59KGpRdWVyeSk7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbiFmdW5jdGlvbiAoJCkge1xcblxcbiAgLyoqXFxuICAgKiBEcm9wZG93biBtb2R1bGUuXFxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24uZHJvcGRvd25cXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRyaWdnZXJzXFxuICAgKi9cXG5cXG4gIHZhciBEcm9wZG93biA9IGZ1bmN0aW9uICgpIHtcXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSBkcm9wZG93bi5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYSBkcm9wZG93bi5cXG4gICAgICogICAgICAgIE9iamVjdCBzaG91bGQgYmUgb2YgdGhlIGRyb3Bkb3duIHBhbmVsLCByYXRoZXIgdGhhbiBpdHMgYW5jaG9yLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcblxcbiAgICBmdW5jdGlvbiBEcm9wZG93bihlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIERyb3Bkb3duKTtcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgRHJvcGRvd24uZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLl9pbml0KCk7XFxuXFxuICAgICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnRHJvcGRvd24nKTtcXG4gICAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdEcm9wZG93bicsIHtcXG4gICAgICAgICdFTlRFUic6ICdvcGVuJyxcXG4gICAgICAgICdTUEFDRSc6ICdvcGVuJyxcXG4gICAgICAgICdFU0NBUEUnOiAnY2xvc2UnLFxcbiAgICAgICAgJ1RBQic6ICd0YWJfZm9yd2FyZCcsXFxuICAgICAgICAnU0hJRlRfVEFCJzogJ3RhYl9iYWNrd2FyZCdcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHBsdWdpbiBieSBzZXR0aW5nL2NoZWNraW5nIG9wdGlvbnMgYW5kIGF0dHJpYnV0ZXMsIGFkZGluZyBoZWxwZXIgdmFyaWFibGVzLCBhbmQgc2F2aW5nIHRoZSBhbmNob3IuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG5cXG4gICAgX2NyZWF0ZUNsYXNzKERyb3Bkb3duLCBbe1xcbiAgICAgIGtleTogJ19pbml0JyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgICB2YXIgJGlkID0gdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpO1xcblxcbiAgICAgICAgdGhpcy4kYW5jaG9yID0gJCgnW2RhdGEtdG9nZ2xlPVxcXCInICsgJGlkICsgJ1xcXCJdJykgfHwgJCgnW2RhdGEtb3Blbj1cXFwiJyArICRpZCArICdcXFwiXScpO1xcbiAgICAgICAgdGhpcy4kYW5jaG9yLmF0dHIoe1xcbiAgICAgICAgICAnYXJpYS1jb250cm9scyc6ICRpZCxcXG4gICAgICAgICAgJ2RhdGEtaXMtZm9jdXMnOiBmYWxzZSxcXG4gICAgICAgICAgJ2RhdGEteWV0aS1ib3gnOiAkaWQsXFxuICAgICAgICAgICdhcmlhLWhhc3BvcHVwJzogdHJ1ZSxcXG4gICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZVxcblxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICB0aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcyA9IHRoaXMuZ2V0UG9zaXRpb25DbGFzcygpO1xcbiAgICAgICAgdGhpcy5jb3VudGVyID0gNDtcXG4gICAgICAgIHRoaXMudXNlZFBvc2l0aW9ucyA9IFtdO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcXG4gICAgICAgICAgJ2FyaWEtaGlkZGVuJzogJ3RydWUnLFxcbiAgICAgICAgICAnZGF0YS15ZXRpLWJveCc6ICRpZCxcXG4gICAgICAgICAgJ2RhdGEtcmVzaXplJzogJGlkLFxcbiAgICAgICAgICAnYXJpYS1sYWJlbGxlZGJ5JzogdGhpcy4kYW5jaG9yWzBdLmlkIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgJ2RkLWFuY2hvcicpXFxuICAgICAgICB9KTtcXG4gICAgICAgIHRoaXMuX2V2ZW50cygpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGN1cnJlbnQgb3JpZW50YXRpb24gb2YgZHJvcGRvd24gcGFuZS5cXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBwb3NpdGlvbiAtIHN0cmluZyB2YWx1ZSBvZiBhIHBvc2l0aW9uIGNsYXNzLlxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnZ2V0UG9zaXRpb25DbGFzcycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldFBvc2l0aW9uQ2xhc3MoKSB7XFxuICAgICAgICB2YXIgdmVydGljYWxQb3NpdGlvbiA9IHRoaXMuJGVsZW1lbnRbMF0uY2xhc3NOYW1lLm1hdGNoKC8odG9wfGxlZnR8cmlnaHR8Ym90dG9tKS9nKTtcXG4gICAgICAgIHZlcnRpY2FsUG9zaXRpb24gPSB2ZXJ0aWNhbFBvc2l0aW9uID8gdmVydGljYWxQb3NpdGlvblswXSA6ICcnO1xcbiAgICAgICAgdmFyIGhvcml6b250YWxQb3NpdGlvbiA9IC9mbG9hdC0oXFxcXFMrKVxcXFxzLy5leGVjKHRoaXMuJGFuY2hvclswXS5jbGFzc05hbWUpO1xcbiAgICAgICAgaG9yaXpvbnRhbFBvc2l0aW9uID0gaG9yaXpvbnRhbFBvc2l0aW9uID8gaG9yaXpvbnRhbFBvc2l0aW9uWzFdIDogJyc7XFxuICAgICAgICB2YXIgcG9zaXRpb24gPSBob3Jpem9udGFsUG9zaXRpb24gPyBob3Jpem9udGFsUG9zaXRpb24gKyAnICcgKyB2ZXJ0aWNhbFBvc2l0aW9uIDogdmVydGljYWxQb3NpdGlvbjtcXG4gICAgICAgIHJldHVybiBwb3NpdGlvbjtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogQWRqdXN0cyB0aGUgZHJvcGRvd24gcGFuZXMgb3JpZW50YXRpb24gYnkgYWRkaW5nL3JlbW92aW5nIHBvc2l0aW9uaW5nIGNsYXNzZXMuXFxuICAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gcG9zaXRpb24gLSBwb3NpdGlvbiBjbGFzcyB0byByZW1vdmUuXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfcmVwb3NpdGlvbicsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZXBvc2l0aW9uKHBvc2l0aW9uKSB7XFxuICAgICAgICB0aGlzLnVzZWRQb3NpdGlvbnMucHVzaChwb3NpdGlvbiA/IHBvc2l0aW9uIDogJ2JvdHRvbScpO1xcbiAgICAgICAgLy9kZWZhdWx0LCB0cnkgc3dpdGNoaW5nIHRvIG9wcG9zaXRlIHNpZGVcXG4gICAgICAgIGlmICghcG9zaXRpb24gJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ3RvcCcpIDwgMCkge1xcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKCd0b3AnKTtcXG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICd0b3AnICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdib3R0b20nKSA8IDApIHtcXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhwb3NpdGlvbik7XFxuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ3JpZ2h0JykgPCAwKSB7XFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MocG9zaXRpb24pLmFkZENsYXNzKCdyaWdodCcpO1xcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3JpZ2h0JyAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignbGVmdCcpIDwgMCkge1xcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHBvc2l0aW9uKS5hZGRDbGFzcygnbGVmdCcpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLy9pZiBkZWZhdWx0IGNoYW5nZSBkaWRuJ3Qgd29yaywgdHJ5IGJvdHRvbSBvciBsZWZ0IGZpcnN0XFxuICAgICAgICBlbHNlIGlmICghcG9zaXRpb24gJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ3RvcCcpID4gLTEgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2xlZnQnKSA8IDApIHtcXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKCdsZWZ0Jyk7XFxuICAgICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICd0b3AnICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdib3R0b20nKSA+IC0xICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdsZWZ0JykgPCAwKSB7XFxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhwb3NpdGlvbikuYWRkQ2xhc3MoJ2xlZnQnKTtcXG4gICAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ2xlZnQnICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdyaWdodCcpID4gLTEgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpIDwgMCkge1xcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MocG9zaXRpb24pO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdsZWZ0JykgPiAtMSAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignYm90dG9tJykgPCAwKSB7XFxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhwb3NpdGlvbik7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgLy9pZiBub3RoaW5nIGNsZWFyZWQsIHNldCB0byBib3R0b21cXG4gICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHBvc2l0aW9uKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB0aGlzLmNsYXNzQ2hhbmdlZCA9IHRydWU7XFxuICAgICAgICB0aGlzLmNvdW50ZXItLTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogU2V0cyB0aGUgcG9zaXRpb24gYW5kIG9yaWVudGF0aW9uIG9mIHRoZSBkcm9wZG93biBwYW5lLCBjaGVja3MgZm9yIGNvbGxpc2lvbnMuXFxuICAgICAgICogUmVjdXJzaXZlbHkgY2FsbHMgaXRzZWxmIGlmIGEgY29sbGlzaW9uIGlzIGRldGVjdGVkLCB3aXRoIGEgbmV3IHBvc2l0aW9uIGNsYXNzLlxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfc2V0UG9zaXRpb24nLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2V0UG9zaXRpb24oKSB7XFxuICAgICAgICBpZiAodGhpcy4kYW5jaG9yLmF0dHIoJ2FyaWEtZXhwYW5kZWQnKSA9PT0gJ2ZhbHNlJykge1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLmdldFBvc2l0aW9uQ2xhc3MoKSxcXG4gICAgICAgICAgICAkZWxlRGltcyA9IEZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy4kZWxlbWVudCksXFxuICAgICAgICAgICAgJGFuY2hvckRpbXMgPSBGb3VuZGF0aW9uLkJveC5HZXREaW1lbnNpb25zKHRoaXMuJGFuY2hvciksXFxuICAgICAgICAgICAgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IHBvc2l0aW9uID09PSAnbGVmdCcgPyAnbGVmdCcgOiBwb3NpdGlvbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICd0b3AnLFxcbiAgICAgICAgICAgIHBhcmFtID0gZGlyZWN0aW9uID09PSAndG9wJyA/ICdoZWlnaHQnIDogJ3dpZHRoJyxcXG4gICAgICAgICAgICBvZmZzZXQgPSBwYXJhbSA9PT0gJ2hlaWdodCcgPyB0aGlzLm9wdGlvbnMudk9mZnNldCA6IHRoaXMub3B0aW9ucy5oT2Zmc2V0O1xcblxcbiAgICAgICAgaWYgKCRlbGVEaW1zLndpZHRoID49ICRlbGVEaW1zLndpbmRvd0RpbXMud2lkdGggfHwgIXRoaXMuY291bnRlciAmJiAhRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSh0aGlzLiRlbGVtZW50KSkge1xcbiAgICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZnNldChGb3VuZGF0aW9uLkJveC5HZXRPZmZzZXRzKHRoaXMuJGVsZW1lbnQsIHRoaXMuJGFuY2hvciwgJ2NlbnRlciBib3R0b20nLCB0aGlzLm9wdGlvbnMudk9mZnNldCwgdGhpcy5vcHRpb25zLmhPZmZzZXQsIHRydWUpKS5jc3Moe1xcbiAgICAgICAgICAgICd3aWR0aCc6ICRlbGVEaW1zLndpbmRvd0RpbXMud2lkdGggLSB0aGlzLm9wdGlvbnMuaE9mZnNldCAqIDIsXFxuICAgICAgICAgICAgJ2hlaWdodCc6ICdhdXRvJ1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgdGhpcy5jbGFzc0NoYW5nZWQgPSB0cnVlO1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZnNldChGb3VuZGF0aW9uLkJveC5HZXRPZmZzZXRzKHRoaXMuJGVsZW1lbnQsIHRoaXMuJGFuY2hvciwgcG9zaXRpb24sIHRoaXMub3B0aW9ucy52T2Zmc2V0LCB0aGlzLm9wdGlvbnMuaE9mZnNldCkpO1xcblxcbiAgICAgICAgd2hpbGUgKCFGb3VuZGF0aW9uLkJveC5JbU5vdFRvdWNoaW5nWW91KHRoaXMuJGVsZW1lbnQsIGZhbHNlLCB0cnVlKSAmJiB0aGlzLmNvdW50ZXIpIHtcXG4gICAgICAgICAgdGhpcy5fcmVwb3NpdGlvbihwb3NpdGlvbik7XFxuICAgICAgICAgIHRoaXMuX3NldFBvc2l0aW9uKCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEFkZHMgZXZlbnQgbGlzdGVuZXJzIHRvIHRoZSBlbGVtZW50IHV0aWxpemluZyB0aGUgdHJpZ2dlcnMgdXRpbGl0eSBsaWJyYXJ5LlxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfZXZlbnRzJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKHtcXG4gICAgICAgICAgJ29wZW4uemYudHJpZ2dlcic6IHRoaXMub3Blbi5iaW5kKHRoaXMpLFxcbiAgICAgICAgICAnY2xvc2UuemYudHJpZ2dlcic6IHRoaXMuY2xvc2UuYmluZCh0aGlzKSxcXG4gICAgICAgICAgJ3RvZ2dsZS56Zi50cmlnZ2VyJzogdGhpcy50b2dnbGUuYmluZCh0aGlzKSxcXG4gICAgICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiB0aGlzLl9zZXRQb3NpdGlvbi5iaW5kKHRoaXMpXFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaG92ZXIpIHtcXG4gICAgICAgICAgdGhpcy4kYW5jaG9yLm9mZignbW91c2VlbnRlci56Zi5kcm9wZG93biBtb3VzZWxlYXZlLnpmLmRyb3Bkb3duJykub24oJ21vdXNlZW50ZXIuemYuZHJvcGRvd24nLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xcbiAgICAgICAgICAgIF90aGlzLnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIF90aGlzLm9wZW4oKTtcXG4gICAgICAgICAgICAgIF90aGlzLiRhbmNob3IuZGF0YSgnaG92ZXInLCB0cnVlKTtcXG4gICAgICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmhvdmVyRGVsYXkpO1xcbiAgICAgICAgICB9KS5vbignbW91c2VsZWF2ZS56Zi5kcm9wZG93bicsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XFxuICAgICAgICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcXG4gICAgICAgICAgICAgIF90aGlzLiRhbmNob3IuZGF0YSgnaG92ZXInLCBmYWxzZSk7XFxuICAgICAgICAgICAgfSwgX3RoaXMub3B0aW9ucy5ob3ZlckRlbGF5KTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaG92ZXJQYW5lKSB7XFxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ21vdXNlZW50ZXIuemYuZHJvcGRvd24gbW91c2VsZWF2ZS56Zi5kcm9wZG93bicpLm9uKCdtb3VzZWVudGVyLnpmLmRyb3Bkb3duJywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xcbiAgICAgICAgICAgIH0pLm9uKCdtb3VzZWxlYXZlLnpmLmRyb3Bkb3duJywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLnRpbWVvdXQpO1xcbiAgICAgICAgICAgICAgX3RoaXMudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xcbiAgICAgICAgICAgICAgICBfdGhpcy4kYW5jaG9yLmRhdGEoJ2hvdmVyJywgZmFsc2UpO1xcbiAgICAgICAgICAgICAgfSwgX3RoaXMub3B0aW9ucy5ob3ZlckRlbGF5KTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy4kYW5jaG9yLmFkZCh0aGlzLiRlbGVtZW50KS5vbigna2V5ZG93bi56Zi5kcm9wZG93bicsIGZ1bmN0aW9uIChlKSB7XFxuXFxuICAgICAgICAgIHZhciAkdGFyZ2V0ID0gJCh0aGlzKSxcXG4gICAgICAgICAgICAgIHZpc2libGVGb2N1c2FibGVFbGVtZW50cyA9IEZvdW5kYXRpb24uS2V5Ym9hcmQuZmluZEZvY3VzYWJsZShfdGhpcy4kZWxlbWVudCk7XFxuXFxuICAgICAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdEcm9wZG93bicsIHtcXG4gICAgICAgICAgICB0YWJfZm9yd2FyZDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgaWYgKF90aGlzLiRlbGVtZW50LmZpbmQoJzpmb2N1cycpLmlzKHZpc2libGVGb2N1c2FibGVFbGVtZW50cy5lcSgtMSkpKSB7XFxuICAgICAgICAgICAgICAgIC8vIGxlZnQgbW9kYWwgZG93bndhcmRzLCBzZXR0aW5nIGZvY3VzIHRvIGZpcnN0IGVsZW1lbnRcXG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMudHJhcEZvY3VzKSB7XFxuICAgICAgICAgICAgICAgICAgLy8gaWYgZm9jdXMgc2hhbGwgYmUgdHJhcHBlZFxcbiAgICAgICAgICAgICAgICAgIHZpc2libGVGb2N1c2FibGVFbGVtZW50cy5lcSgwKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAvLyBpZiBmb2N1cyBpcyBub3QgdHJhcHBlZCwgY2xvc2UgZHJvcGRvd24gb24gZm9jdXMgb3V0XFxuICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgdGFiX2JhY2t3YXJkOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBpZiAoX3RoaXMuJGVsZW1lbnQuZmluZCgnOmZvY3VzJykuaXModmlzaWJsZUZvY3VzYWJsZUVsZW1lbnRzLmVxKDApKSB8fCBfdGhpcy4kZWxlbWVudC5pcygnOmZvY3VzJykpIHtcXG4gICAgICAgICAgICAgICAgLy8gbGVmdCBtb2RhbCB1cHdhcmRzLCBzZXR0aW5nIGZvY3VzIHRvIGxhc3QgZWxlbWVudFxcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy50cmFwRm9jdXMpIHtcXG4gICAgICAgICAgICAgICAgICAvLyBpZiBmb2N1cyBzaGFsbCBiZSB0cmFwcGVkXFxuICAgICAgICAgICAgICAgICAgdmlzaWJsZUZvY3VzYWJsZUVsZW1lbnRzLmVxKC0xKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgICAvLyBpZiBmb2N1cyBpcyBub3QgdHJhcHBlZCwgY2xvc2UgZHJvcGRvd24gb24gZm9jdXMgb3V0XFxuICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgb3BlbjogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgaWYgKCR0YXJnZXQuaXMoX3RoaXMuJGFuY2hvcikpIHtcXG4gICAgICAgICAgICAgICAgX3RoaXMub3BlbigpO1xcbiAgICAgICAgICAgICAgICBfdGhpcy4kZWxlbWVudC5hdHRyKCd0YWJpbmRleCcsIC0xKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcXG4gICAgICAgICAgICAgIF90aGlzLiRhbmNob3IuZm9jdXMoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEFkZHMgYW4gZXZlbnQgaGFuZGxlciB0byB0aGUgYm9keSB0byBjbG9zZSBhbnkgZHJvcGRvd25zIG9uIGEgY2xpY2suXFxuICAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ19hZGRCb2R5SGFuZGxlcicsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRCb2R5SGFuZGxlcigpIHtcXG4gICAgICAgIHZhciAkYm9keSA9ICQoZG9jdW1lbnQuYm9keSkubm90KHRoaXMuJGVsZW1lbnQpLFxcbiAgICAgICAgICAgIF90aGlzID0gdGhpcztcXG4gICAgICAgICRib2R5Lm9mZignY2xpY2suemYuZHJvcGRvd24nKS5vbignY2xpY2suemYuZHJvcGRvd24nLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBpZiAoX3RoaXMuJGFuY2hvci5pcyhlLnRhcmdldCkgfHwgX3RoaXMuJGFuY2hvci5maW5kKGUudGFyZ2V0KS5sZW5ndGgpIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgaWYgKF90aGlzLiRlbGVtZW50LmZpbmQoZS50YXJnZXQpLmxlbmd0aCkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xcbiAgICAgICAgICAkYm9keS5vZmYoJ2NsaWNrLnpmLmRyb3Bkb3duJyk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogT3BlbnMgdGhlIGRyb3Bkb3duIHBhbmUsIGFuZCBmaXJlcyBhIGJ1YmJsaW5nIGV2ZW50IHRvIGNsb3NlIG90aGVyIGRyb3Bkb3ducy5cXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKiBAZmlyZXMgRHJvcGRvd24jY2xvc2VtZVxcbiAgICAgICAqIEBmaXJlcyBEcm9wZG93biNzaG93XFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdvcGVuJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gb3BlbigpIHtcXG4gICAgICAgIC8vIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEZpcmVzIHRvIGNsb3NlIG90aGVyIG9wZW4gZHJvcGRvd25zXFxuICAgICAgICAgKiBAZXZlbnQgRHJvcGRvd24jY2xvc2VtZVxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Nsb3NlbWUuemYuZHJvcGRvd24nLCB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJykpO1xcbiAgICAgICAgdGhpcy4kYW5jaG9yLmFkZENsYXNzKCdob3ZlcicpLmF0dHIoeyAnYXJpYS1leHBhbmRlZCc6IHRydWUgfSk7XFxuICAgICAgICAvLyB0aGlzLiRlbGVtZW50Lyouc2hvdygpKi87XFxuICAgICAgICB0aGlzLl9zZXRQb3NpdGlvbigpO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcygnaXMtb3BlbicpLmF0dHIoeyAnYXJpYS1oaWRkZW4nOiBmYWxzZSB9KTtcXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0ZvY3VzKSB7XFxuICAgICAgICAgIHZhciAkZm9jdXNhYmxlID0gRm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKHRoaXMuJGVsZW1lbnQpO1xcbiAgICAgICAgICBpZiAoJGZvY3VzYWJsZS5sZW5ndGgpIHtcXG4gICAgICAgICAgICAkZm9jdXNhYmxlLmVxKDApLmZvY3VzKCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7XFxuICAgICAgICAgIHRoaXMuX2FkZEJvZHlIYW5kbGVyKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEZpcmVzIG9uY2UgdGhlIGRyb3Bkb3duIGlzIHZpc2libGUuXFxuICAgICAgICAgKiBAZXZlbnQgRHJvcGRvd24jc2hvd1xcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Nob3cuemYuZHJvcGRvd24nLCBbdGhpcy4kZWxlbWVudF0pO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBDbG9zZXMgdGhlIG9wZW4gZHJvcGRvd24gcGFuZS5cXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKiBAZmlyZXMgRHJvcGRvd24jaGlkZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnY2xvc2UnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZSgpIHtcXG4gICAgICAgIGlmICghdGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtb3BlbicpKSB7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3MoJ2lzLW9wZW4nKS5hdHRyKHsgJ2FyaWEtaGlkZGVuJzogdHJ1ZSB9KTtcXG5cXG4gICAgICAgIHRoaXMuJGFuY2hvci5yZW1vdmVDbGFzcygnaG92ZXInKS5hdHRyKCdhcmlhLWV4cGFuZGVkJywgZmFsc2UpO1xcblxcbiAgICAgICAgaWYgKHRoaXMuY2xhc3NDaGFuZ2VkKSB7XFxuICAgICAgICAgIHZhciBjdXJQb3NpdGlvbkNsYXNzID0gdGhpcy5nZXRQb3NpdGlvbkNsYXNzKCk7XFxuICAgICAgICAgIGlmIChjdXJQb3NpdGlvbkNsYXNzKSB7XFxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhjdXJQb3NpdGlvbkNsYXNzKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5wb3NpdGlvbkNsYXNzKVxcbiAgICAgICAgICAvKi5oaWRlKCkqLy5jc3MoeyBoZWlnaHQ6ICcnLCB3aWR0aDogJycgfSk7XFxuICAgICAgICAgIHRoaXMuY2xhc3NDaGFuZ2VkID0gZmFsc2U7XFxuICAgICAgICAgIHRoaXMuY291bnRlciA9IDQ7XFxuICAgICAgICAgIHRoaXMudXNlZFBvc2l0aW9ucy5sZW5ndGggPSAwO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdoaWRlLnpmLmRyb3Bkb3duJywgW3RoaXMuJGVsZW1lbnRdKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogVG9nZ2xlcyB0aGUgZHJvcGRvd24gcGFuZSdzIHZpc2liaWxpdHkuXFxuICAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICd0b2dnbGUnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGUoKSB7XFxuICAgICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnaXMtb3BlbicpKSB7XFxuICAgICAgICAgIGlmICh0aGlzLiRhbmNob3IuZGF0YSgnaG92ZXInKSkgcmV0dXJuO1xcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aGlzLm9wZW4oKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogRGVzdHJveXMgdGhlIGRyb3Bkb3duLlxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnZGVzdHJveScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnRyaWdnZXInKS5oaWRlKCk7XFxuICAgICAgICB0aGlzLiRhbmNob3Iub2ZmKCcuemYuZHJvcGRvd24nKTtcXG5cXG4gICAgICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcXG4gICAgICB9XFxuICAgIH1dKTtcXG5cXG4gICAgcmV0dXJuIERyb3Bkb3duO1xcbiAgfSgpO1xcblxcbiAgRHJvcGRvd24uZGVmYXVsdHMgPSB7XFxuICAgIC8qKlxcbiAgICAgKiBBbW91bnQgb2YgdGltZSB0byBkZWxheSBvcGVuaW5nIGEgc3VibWVudSBvbiBob3ZlciBldmVudC5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAyNTBcXG4gICAgICovXFxuICAgIGhvdmVyRGVsYXk6IDI1MCxcXG4gICAgLyoqXFxuICAgICAqIEFsbG93IHN1Ym1lbnVzIHRvIG9wZW4gb24gaG92ZXIgZXZlbnRzXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgZmFsc2VcXG4gICAgICovXFxuICAgIGhvdmVyOiBmYWxzZSxcXG4gICAgLyoqXFxuICAgICAqIERvbid0IGNsb3NlIGRyb3Bkb3duIHdoZW4gaG92ZXJpbmcgb3ZlciBkcm9wZG93biBwYW5lXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxcbiAgICAgKi9cXG4gICAgaG92ZXJQYW5lOiBmYWxzZSxcXG4gICAgLyoqXFxuICAgICAqIE51bWJlciBvZiBwaXhlbHMgYmV0d2VlbiB0aGUgZHJvcGRvd24gcGFuZSBhbmQgdGhlIHRyaWdnZXJpbmcgZWxlbWVudCBvbiBvcGVuLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIDFcXG4gICAgICovXFxuICAgIHZPZmZzZXQ6IDEsXFxuICAgIC8qKlxcbiAgICAgKiBOdW1iZXIgb2YgcGl4ZWxzIGJldHdlZW4gdGhlIGRyb3Bkb3duIHBhbmUgYW5kIHRoZSB0cmlnZ2VyaW5nIGVsZW1lbnQgb24gb3Blbi5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAxXFxuICAgICAqL1xcbiAgICBoT2Zmc2V0OiAxLFxcbiAgICAvKipcXG4gICAgICogQ2xhc3MgYXBwbGllZCB0byBhZGp1c3Qgb3BlbiBwb3NpdGlvbi4gSlMgd2lsbCB0ZXN0IGFuZCBmaWxsIHRoaXMgaW4uXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgJ3RvcCdcXG4gICAgICovXFxuICAgIHBvc2l0aW9uQ2xhc3M6ICcnLFxcbiAgICAvKipcXG4gICAgICogQWxsb3cgdGhlIHBsdWdpbiB0byB0cmFwIGZvY3VzIHRvIHRoZSBkcm9wZG93biBwYW5lIGlmIG9wZW5lZCB3aXRoIGtleWJvYXJkIGNvbW1hbmRzLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIGZhbHNlXFxuICAgICAqL1xcbiAgICB0cmFwRm9jdXM6IGZhbHNlLFxcbiAgICAvKipcXG4gICAgICogQWxsb3cgdGhlIHBsdWdpbiB0byBzZXQgZm9jdXMgdG8gdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50IHdpdGhpbiB0aGUgcGFuZSwgcmVnYXJkbGVzcyBvZiBtZXRob2Qgb2Ygb3BlbmluZy5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSB0cnVlXFxuICAgICAqL1xcbiAgICBhdXRvRm9jdXM6IGZhbHNlLFxcbiAgICAvKipcXG4gICAgICogQWxsb3dzIGEgY2xpY2sgb24gdGhlIGJvZHkgdG8gY2xvc2UgdGhlIGRyb3Bkb3duLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIGZhbHNlXFxuICAgICAqL1xcbiAgICBjbG9zZU9uQ2xpY2s6IGZhbHNlXFxuICB9O1xcblxcbiAgLy8gV2luZG93IGV4cG9ydHNcXG4gIEZvdW5kYXRpb24ucGx1Z2luKERyb3Bkb3duLCAnRHJvcGRvd24nKTtcXG59KGpRdWVyeSk7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbiFmdW5jdGlvbiAoJCkge1xcblxcbiAgLyoqXFxuICAgKiBEcm9wZG93bk1lbnUgbW9kdWxlLlxcbiAgICogQG1vZHVsZSBmb3VuZGF0aW9uLmRyb3Bkb3duLW1lbnVcXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwuYm94XFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm5lc3RcXG4gICAqL1xcblxcbiAgdmFyIERyb3Bkb3duTWVudSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgRHJvcGRvd25NZW51LlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQGZpcmVzIERyb3Bkb3duTWVudSNpbml0XFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYSBkcm9wZG93biBtZW51LlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcblxcbiAgICBmdW5jdGlvbiBEcm9wZG93bk1lbnUoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBEcm9wZG93bk1lbnUpO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBEcm9wZG93bk1lbnUuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG5cXG4gICAgICBGb3VuZGF0aW9uLk5lc3QuRmVhdGhlcih0aGlzLiRlbGVtZW50LCAnZHJvcGRvd24nKTtcXG4gICAgICB0aGlzLl9pbml0KCk7XFxuXFxuICAgICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnRHJvcGRvd25NZW51Jyk7XFxuICAgICAgRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcignRHJvcGRvd25NZW51Jywge1xcbiAgICAgICAgJ0VOVEVSJzogJ29wZW4nLFxcbiAgICAgICAgJ1NQQUNFJzogJ29wZW4nLFxcbiAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ25leHQnLFxcbiAgICAgICAgJ0FSUk9XX1VQJzogJ3VwJyxcXG4gICAgICAgICdBUlJPV19ET1dOJzogJ2Rvd24nLFxcbiAgICAgICAgJ0FSUk9XX0xFRlQnOiAncHJldmlvdXMnLFxcbiAgICAgICAgJ0VTQ0FQRSc6ICdjbG9zZSdcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHBsdWdpbiwgYW5kIGNhbGxzIF9wcmVwYXJlTWVudVxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICovXFxuXFxuXFxuICAgIF9jcmVhdGVDbGFzcyhEcm9wZG93bk1lbnUsIFt7XFxuICAgICAga2V5OiAnX2luaXQnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICAgIHZhciBzdWJzID0gdGhpcy4kZWxlbWVudC5maW5kKCdsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5jaGlsZHJlbignLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50JykuY2hpbGRyZW4oJy5pcy1kcm9wZG93bi1zdWJtZW51JykuYWRkQ2xhc3MoJ2ZpcnN0LXN1YicpO1xcblxcbiAgICAgICAgdGhpcy4kbWVudUl0ZW1zID0gdGhpcy4kZWxlbWVudC5maW5kKCdbcm9sZT1cXFwibWVudWl0ZW1cXFwiXScpO1xcbiAgICAgICAgdGhpcy4kdGFicyA9IHRoaXMuJGVsZW1lbnQuY2hpbGRyZW4oJ1tyb2xlPVxcXCJtZW51aXRlbVxcXCJdJyk7XFxuICAgICAgICB0aGlzLiR0YWJzLmZpbmQoJ3VsLmlzLWRyb3Bkb3duLXN1Ym1lbnUnKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMudmVydGljYWxDbGFzcyk7XFxuXFxuICAgICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLm9wdGlvbnMucmlnaHRDbGFzcykgfHwgdGhpcy5vcHRpb25zLmFsaWdubWVudCA9PT0gJ3JpZ2h0JyB8fCBGb3VuZGF0aW9uLnJ0bCgpIHx8IHRoaXMuJGVsZW1lbnQucGFyZW50cygnLnRvcC1iYXItcmlnaHQnKS5pcygnKicpKSB7XFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5hbGlnbm1lbnQgPSAncmlnaHQnO1xcbiAgICAgICAgICBzdWJzLmFkZENsYXNzKCdvcGVucy1sZWZ0Jyk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzdWJzLmFkZENsYXNzKCdvcGVucy1yaWdodCcpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5jaGFuZ2VkID0gZmFsc2U7XFxuICAgICAgICB0aGlzLl9ldmVudHMoKTtcXG4gICAgICB9XFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfZXZlbnRzJyxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byBlbGVtZW50cyB3aXRoaW4gdGhlIG1lbnVcXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqL1xcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcyxcXG4gICAgICAgICAgICBoYXNUb3VjaCA9ICdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyB8fCB0eXBlb2Ygd2luZG93Lm9udG91Y2hzdGFydCAhPT0gJ3VuZGVmaW5lZCcsXFxuICAgICAgICAgICAgcGFyQ2xhc3MgPSAnaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQnO1xcblxcbiAgICAgICAgLy8gdXNlZCBmb3Igb25DbGljayBhbmQgaW4gdGhlIGtleWJvYXJkIGhhbmRsZXJzXFxuICAgICAgICB2YXIgaGFuZGxlQ2xpY2tGbiA9IGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIHZhciAkZWxlbSA9ICQoZS50YXJnZXQpLnBhcmVudHNVbnRpbCgndWwnLCAnLicgKyBwYXJDbGFzcyksXFxuICAgICAgICAgICAgICBoYXNTdWIgPSAkZWxlbS5oYXNDbGFzcyhwYXJDbGFzcyksXFxuICAgICAgICAgICAgICBoYXNDbGlja2VkID0gJGVsZW0uYXR0cignZGF0YS1pcy1jbGljaycpID09PSAndHJ1ZScsXFxuICAgICAgICAgICAgICAkc3ViID0gJGVsZW0uY2hpbGRyZW4oJy5pcy1kcm9wZG93bi1zdWJtZW51Jyk7XFxuXFxuICAgICAgICAgIGlmIChoYXNTdWIpIHtcXG4gICAgICAgICAgICBpZiAoaGFzQ2xpY2tlZCkge1xcbiAgICAgICAgICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayB8fCAhX3RoaXMub3B0aW9ucy5jbGlja09wZW4gJiYgIWhhc1RvdWNoIHx8IF90aGlzLm9wdGlvbnMuZm9yY2VGb2xsb3cgJiYgaGFzVG91Y2gpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgICAgICBfdGhpcy5faGlkZSgkZWxlbSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgICAgICBfdGhpcy5fc2hvdygkZWxlbS5jaGlsZHJlbignLmlzLWRyb3Bkb3duLXN1Ym1lbnUnKSk7XFxuICAgICAgICAgICAgICAkZWxlbS5hZGQoJGVsZW0ucGFyZW50c1VudGlsKF90aGlzLiRlbGVtZW50LCAnLicgKyBwYXJDbGFzcykpLmF0dHIoJ2RhdGEtaXMtY2xpY2snLCB0cnVlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbGlja09wZW4gfHwgaGFzVG91Y2gpIHtcXG4gICAgICAgICAgdGhpcy4kbWVudUl0ZW1zLm9uKCdjbGljay56Zi5kcm9wZG93bm1lbnUgdG91Y2hzdGFydC56Zi5kcm9wZG93bm1lbnUnLCBoYW5kbGVDbGlja0ZuKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLmRpc2FibGVIb3Zlcikge1xcbiAgICAgICAgICB0aGlzLiRtZW51SXRlbXMub24oJ21vdXNlZW50ZXIuemYuZHJvcGRvd25tZW51JywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICB2YXIgJGVsZW0gPSAkKHRoaXMpLFxcbiAgICAgICAgICAgICAgICBoYXNTdWIgPSAkZWxlbS5oYXNDbGFzcyhwYXJDbGFzcyk7XFxuXFxuICAgICAgICAgICAgaWYgKGhhc1N1Yikge1xcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmRlbGF5KTtcXG4gICAgICAgICAgICAgIF90aGlzLmRlbGF5ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLl9zaG93KCRlbGVtLmNoaWxkcmVuKCcuaXMtZHJvcGRvd24tc3VibWVudScpKTtcXG4gICAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuaG92ZXJEZWxheSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KS5vbignbW91c2VsZWF2ZS56Zi5kcm9wZG93bm1lbnUnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIHZhciAkZWxlbSA9ICQodGhpcyksXFxuICAgICAgICAgICAgICAgIGhhc1N1YiA9ICRlbGVtLmhhc0NsYXNzKHBhckNsYXNzKTtcXG4gICAgICAgICAgICBpZiAoaGFzU3ViICYmIF90aGlzLm9wdGlvbnMuYXV0b2Nsb3NlKSB7XFxuICAgICAgICAgICAgICBpZiAoJGVsZW0uYXR0cignZGF0YS1pcy1jbGljaycpID09PSAndHJ1ZScgJiYgX3RoaXMub3B0aW9ucy5jbGlja09wZW4pIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF90aGlzLmRlbGF5KTtcXG4gICAgICAgICAgICAgIF90aGlzLmRlbGF5ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLl9oaWRlKCRlbGVtKTtcXG4gICAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuY2xvc2luZ1RpbWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgICB0aGlzLiRtZW51SXRlbXMub24oJ2tleWRvd24uemYuZHJvcGRvd25tZW51JywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgdmFyICRlbGVtZW50ID0gJChlLnRhcmdldCkucGFyZW50c1VudGlsKCd1bCcsICdbcm9sZT1cXFwibWVudWl0ZW1cXFwiXScpLFxcbiAgICAgICAgICAgICAgaXNUYWIgPSBfdGhpcy4kdGFicy5pbmRleCgkZWxlbWVudCkgPiAtMSxcXG4gICAgICAgICAgICAgICRlbGVtZW50cyA9IGlzVGFiID8gX3RoaXMuJHRhYnMgOiAkZWxlbWVudC5zaWJsaW5ncygnbGknKS5hZGQoJGVsZW1lbnQpLFxcbiAgICAgICAgICAgICAgJHByZXZFbGVtZW50LFxcbiAgICAgICAgICAgICAgJG5leHRFbGVtZW50O1xcblxcbiAgICAgICAgICAkZWxlbWVudHMuZWFjaChmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgICAgIGlmICgkKHRoaXMpLmlzKCRlbGVtZW50KSkge1xcbiAgICAgICAgICAgICAgJHByZXZFbGVtZW50ID0gJGVsZW1lbnRzLmVxKGkgLSAxKTtcXG4gICAgICAgICAgICAgICRuZXh0RWxlbWVudCA9ICRlbGVtZW50cy5lcShpICsgMSk7XFxuICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgdmFyIG5leHRTaWJsaW5nID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmICghJGVsZW1lbnQuaXMoJzpsYXN0LWNoaWxkJykpIHtcXG4gICAgICAgICAgICAgICRuZXh0RWxlbWVudC5jaGlsZHJlbignYTpmaXJzdCcpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgcHJldlNpYmxpbmcgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgJHByZXZFbGVtZW50LmNoaWxkcmVuKCdhOmZpcnN0JykuZm9jdXMoKTtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICBvcGVuU3ViID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHZhciAkc3ViID0gJGVsZW1lbnQuY2hpbGRyZW4oJ3VsLmlzLWRyb3Bkb3duLXN1Ym1lbnUnKTtcXG4gICAgICAgICAgICBpZiAoJHN1Yi5sZW5ndGgpIHtcXG4gICAgICAgICAgICAgIF90aGlzLl9zaG93KCRzdWIpO1xcbiAgICAgICAgICAgICAgJGVsZW1lbnQuZmluZCgnbGkgPiBhOmZpcnN0JykuZm9jdXMoKTtcXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgICAgIGNsb3NlU3ViID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIC8vaWYgKCRlbGVtZW50LmlzKCc6Zmlyc3QtY2hpbGQnKSkge1xcbiAgICAgICAgICAgIHZhciBjbG9zZSA9ICRlbGVtZW50LnBhcmVudCgndWwnKS5wYXJlbnQoJ2xpJyk7XFxuICAgICAgICAgICAgY2xvc2UuY2hpbGRyZW4oJ2E6Zmlyc3QnKS5mb2N1cygpO1xcbiAgICAgICAgICAgIF90aGlzLl9oaWRlKGNsb3NlKTtcXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgLy99XFxuICAgICAgICAgIH07XFxuICAgICAgICAgIHZhciBmdW5jdGlvbnMgPSB7XFxuICAgICAgICAgICAgb3Blbjogb3BlblN1YixcXG4gICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgX3RoaXMuX2hpZGUoX3RoaXMuJGVsZW1lbnQpO1xcbiAgICAgICAgICAgICAgX3RoaXMuJG1lbnVJdGVtcy5maW5kKCdhOmZpcnN0JykuZm9jdXMoKTsgLy8gZm9jdXMgdG8gZmlyc3QgZWxlbWVudFxcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgaGFuZGxlZDogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH07XFxuXFxuICAgICAgICAgIGlmIChpc1RhYikge1xcbiAgICAgICAgICAgIGlmIChfdGhpcy4kZWxlbWVudC5oYXNDbGFzcyhfdGhpcy5vcHRpb25zLnZlcnRpY2FsQ2xhc3MpKSB7XFxuICAgICAgICAgICAgICAvLyB2ZXJ0aWNhbCBtZW51XFxuICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5hbGlnbm1lbnQgPT09ICdsZWZ0Jykge1xcbiAgICAgICAgICAgICAgICAvLyBsZWZ0IGFsaWduZWRcXG4gICAgICAgICAgICAgICAgJC5leHRlbmQoZnVuY3Rpb25zLCB7XFxuICAgICAgICAgICAgICAgICAgZG93bjogbmV4dFNpYmxpbmcsXFxuICAgICAgICAgICAgICAgICAgdXA6IHByZXZTaWJsaW5nLFxcbiAgICAgICAgICAgICAgICAgIG5leHQ6IG9wZW5TdWIsXFxuICAgICAgICAgICAgICAgICAgcHJldmlvdXM6IGNsb3NlU3ViXFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICAgLy8gcmlnaHQgYWxpZ25lZFxcbiAgICAgICAgICAgICAgICAkLmV4dGVuZChmdW5jdGlvbnMsIHtcXG4gICAgICAgICAgICAgICAgICBkb3duOiBuZXh0U2libGluZyxcXG4gICAgICAgICAgICAgICAgICB1cDogcHJldlNpYmxpbmcsXFxuICAgICAgICAgICAgICAgICAgbmV4dDogY2xvc2VTdWIsXFxuICAgICAgICAgICAgICAgICAgcHJldmlvdXM6IG9wZW5TdWJcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIC8vIGhvcml6b250YWwgbWVudVxcbiAgICAgICAgICAgICAgJC5leHRlbmQoZnVuY3Rpb25zLCB7XFxuICAgICAgICAgICAgICAgIG5leHQ6IG5leHRTaWJsaW5nLFxcbiAgICAgICAgICAgICAgICBwcmV2aW91czogcHJldlNpYmxpbmcsXFxuICAgICAgICAgICAgICAgIGRvd246IG9wZW5TdWIsXFxuICAgICAgICAgICAgICAgIHVwOiBjbG9zZVN1YlxcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIC8vIG5vdCB0YWJzIC0+IG9uZSBzdWJcXG4gICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5hbGlnbm1lbnQgPT09ICdsZWZ0Jykge1xcbiAgICAgICAgICAgICAgLy8gbGVmdCBhbGlnbmVkXFxuICAgICAgICAgICAgICAkLmV4dGVuZChmdW5jdGlvbnMsIHtcXG4gICAgICAgICAgICAgICAgbmV4dDogb3BlblN1YixcXG4gICAgICAgICAgICAgICAgcHJldmlvdXM6IGNsb3NlU3ViLFxcbiAgICAgICAgICAgICAgICBkb3duOiBuZXh0U2libGluZyxcXG4gICAgICAgICAgICAgICAgdXA6IHByZXZTaWJsaW5nXFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgLy8gcmlnaHQgYWxpZ25lZFxcbiAgICAgICAgICAgICAgJC5leHRlbmQoZnVuY3Rpb25zLCB7XFxuICAgICAgICAgICAgICAgIG5leHQ6IGNsb3NlU3ViLFxcbiAgICAgICAgICAgICAgICBwcmV2aW91czogb3BlblN1YixcXG4gICAgICAgICAgICAgICAgZG93bjogbmV4dFNpYmxpbmcsXFxuICAgICAgICAgICAgICAgIHVwOiBwcmV2U2libGluZ1xcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdEcm9wZG93bk1lbnUnLCBmdW5jdGlvbnMpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEFkZHMgYW4gZXZlbnQgaGFuZGxlciB0byB0aGUgYm9keSB0byBjbG9zZSBhbnkgZHJvcGRvd25zIG9uIGEgY2xpY2suXFxuICAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ19hZGRCb2R5SGFuZGxlcicsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9hZGRCb2R5SGFuZGxlcigpIHtcXG4gICAgICAgIHZhciAkYm9keSA9ICQoZG9jdW1lbnQuYm9keSksXFxuICAgICAgICAgICAgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgJGJvZHkub2ZmKCdtb3VzZXVwLnpmLmRyb3Bkb3dubWVudSB0b3VjaGVuZC56Zi5kcm9wZG93bm1lbnUnKS5vbignbW91c2V1cC56Zi5kcm9wZG93bm1lbnUgdG91Y2hlbmQuemYuZHJvcGRvd25tZW51JywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgdmFyICRsaW5rID0gX3RoaXMuJGVsZW1lbnQuZmluZChlLnRhcmdldCk7XFxuICAgICAgICAgIGlmICgkbGluay5sZW5ndGgpIHtcXG4gICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgX3RoaXMuX2hpZGUoKTtcXG4gICAgICAgICAgJGJvZHkub2ZmKCdtb3VzZXVwLnpmLmRyb3Bkb3dubWVudSB0b3VjaGVuZC56Zi5kcm9wZG93bm1lbnUnKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBPcGVucyBhIGRyb3Bkb3duIHBhbmUsIGFuZCBjaGVja3MgZm9yIGNvbGxpc2lvbnMgZmlyc3QuXFxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9ICRzdWIgLSB1bCBlbGVtZW50IHRoYXQgaXMgYSBzdWJtZW51IHRvIHNob3dcXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqIEBmaXJlcyBEcm9wZG93bk1lbnUjc2hvd1xcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX3Nob3cnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfc2hvdygkc3ViKSB7XFxuICAgICAgICB2YXIgaWR4ID0gdGhpcy4kdGFicy5pbmRleCh0aGlzLiR0YWJzLmZpbHRlcihmdW5jdGlvbiAoaSwgZWwpIHtcXG4gICAgICAgICAgcmV0dXJuICQoZWwpLmZpbmQoJHN1YikubGVuZ3RoID4gMDtcXG4gICAgICAgIH0pKTtcXG4gICAgICAgIHZhciAkc2licyA9ICRzdWIucGFyZW50KCdsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpLnNpYmxpbmdzKCdsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpO1xcbiAgICAgICAgdGhpcy5faGlkZSgkc2licywgaWR4KTtcXG4gICAgICAgICRzdWIuY3NzKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpLmFkZENsYXNzKCdqcy1kcm9wZG93bi1hY3RpdmUnKS5hdHRyKHsgJ2FyaWEtaGlkZGVuJzogZmFsc2UgfSkucGFyZW50KCdsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpLmFkZENsYXNzKCdpcy1hY3RpdmUnKS5hdHRyKHsgJ2FyaWEtZXhwYW5kZWQnOiB0cnVlIH0pO1xcbiAgICAgICAgdmFyIGNsZWFyID0gRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSgkc3ViLCBudWxsLCB0cnVlKTtcXG4gICAgICAgIGlmICghY2xlYXIpIHtcXG4gICAgICAgICAgdmFyIG9sZENsYXNzID0gdGhpcy5vcHRpb25zLmFsaWdubWVudCA9PT0gJ2xlZnQnID8gJy1yaWdodCcgOiAnLWxlZnQnLFxcbiAgICAgICAgICAgICAgJHBhcmVudExpID0gJHN1Yi5wYXJlbnQoJy5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudCcpO1xcbiAgICAgICAgICAkcGFyZW50TGkucmVtb3ZlQ2xhc3MoJ29wZW5zJyArIG9sZENsYXNzKS5hZGRDbGFzcygnb3BlbnMtJyArIHRoaXMub3B0aW9ucy5hbGlnbm1lbnQpO1xcbiAgICAgICAgICBjbGVhciA9IEZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UoJHN1YiwgbnVsbCwgdHJ1ZSk7XFxuICAgICAgICAgIGlmICghY2xlYXIpIHtcXG4gICAgICAgICAgICAkcGFyZW50TGkucmVtb3ZlQ2xhc3MoJ29wZW5zLScgKyB0aGlzLm9wdGlvbnMuYWxpZ25tZW50KS5hZGRDbGFzcygnb3BlbnMtaW5uZXInKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICB0aGlzLmNoYW5nZWQgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgJHN1Yi5jc3MoJ3Zpc2liaWxpdHknLCAnJyk7XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljaykge1xcbiAgICAgICAgICB0aGlzLl9hZGRCb2R5SGFuZGxlcigpO1xcbiAgICAgICAgfVxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBuZXcgZHJvcGRvd24gcGFuZSBpcyB2aXNpYmxlLlxcbiAgICAgICAgICogQGV2ZW50IERyb3Bkb3duTWVudSNzaG93XFxuICAgICAgICAgKi9cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignc2hvdy56Zi5kcm9wZG93bm1lbnUnLCBbJHN1Yl0pO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBIaWRlcyBhIHNpbmdsZSwgY3VycmVudGx5IG9wZW4gZHJvcGRvd24gcGFuZSwgaWYgcGFzc2VkIGEgcGFyYW1ldGVyLCBvdGhlcndpc2UsIGhpZGVzIGV2ZXJ5dGhpbmcuXFxuICAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9ICRlbGVtIC0gZWxlbWVudCB3aXRoIGEgc3VibWVudSB0byBoaWRlXFxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkeCAtIGluZGV4IG9mIHRoZSAkdGFicyBjb2xsZWN0aW9uIHRvIGhpZGVcXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX2hpZGUnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGlkZSgkZWxlbSwgaWR4KSB7XFxuICAgICAgICB2YXIgJHRvQ2xvc2U7XFxuICAgICAgICBpZiAoJGVsZW0gJiYgJGVsZW0ubGVuZ3RoKSB7XFxuICAgICAgICAgICR0b0Nsb3NlID0gJGVsZW07XFxuICAgICAgICB9IGVsc2UgaWYgKGlkeCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICR0b0Nsb3NlID0gdGhpcy4kdGFicy5ub3QoZnVuY3Rpb24gKGksIGVsKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGkgPT09IGlkeDtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAkdG9DbG9zZSA9IHRoaXMuJGVsZW1lbnQ7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgc29tZXRoaW5nVG9DbG9zZSA9ICR0b0Nsb3NlLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSB8fCAkdG9DbG9zZS5maW5kKCcuaXMtYWN0aXZlJykubGVuZ3RoID4gMDtcXG5cXG4gICAgICAgIGlmIChzb21ldGhpbmdUb0Nsb3NlKSB7XFxuICAgICAgICAgICR0b0Nsb3NlLmZpbmQoJ2xpLmlzLWFjdGl2ZScpLmFkZCgkdG9DbG9zZSkuYXR0cih7XFxuICAgICAgICAgICAgJ2FyaWEtZXhwYW5kZWQnOiBmYWxzZSxcXG4gICAgICAgICAgICAnZGF0YS1pcy1jbGljayc6IGZhbHNlXFxuICAgICAgICAgIH0pLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKTtcXG5cXG4gICAgICAgICAgJHRvQ2xvc2UuZmluZCgndWwuanMtZHJvcGRvd24tYWN0aXZlJykuYXR0cih7XFxuICAgICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZVxcbiAgICAgICAgICB9KS5yZW1vdmVDbGFzcygnanMtZHJvcGRvd24tYWN0aXZlJyk7XFxuXFxuICAgICAgICAgIGlmICh0aGlzLmNoYW5nZWQgfHwgJHRvQ2xvc2UuZmluZCgnb3BlbnMtaW5uZXInKS5sZW5ndGgpIHtcXG4gICAgICAgICAgICB2YXIgb2xkQ2xhc3MgPSB0aGlzLm9wdGlvbnMuYWxpZ25tZW50ID09PSAnbGVmdCcgPyAncmlnaHQnIDogJ2xlZnQnO1xcbiAgICAgICAgICAgICR0b0Nsb3NlLmZpbmQoJ2xpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50JykuYWRkKCR0b0Nsb3NlKS5yZW1vdmVDbGFzcygnb3BlbnMtaW5uZXIgb3BlbnMtJyArIHRoaXMub3B0aW9ucy5hbGlnbm1lbnQpLmFkZENsYXNzKCdvcGVucy0nICsgb2xkQ2xhc3MpO1xcbiAgICAgICAgICAgIHRoaXMuY2hhbmdlZCA9IGZhbHNlO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIC8qKlxcbiAgICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBvcGVuIG1lbnVzIGFyZSBjbG9zZWQuXFxuICAgICAgICAgICAqIEBldmVudCBEcm9wZG93bk1lbnUjaGlkZVxcbiAgICAgICAgICAgKi9cXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdoaWRlLnpmLmRyb3Bkb3dubWVudScsIFskdG9DbG9zZV0pO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBEZXN0cm95cyB0aGUgcGx1Z2luLlxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnZGVzdHJveScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuICAgICAgICB0aGlzLiRtZW51SXRlbXMub2ZmKCcuemYuZHJvcGRvd25tZW51JykucmVtb3ZlQXR0cignZGF0YS1pcy1jbGljaycpLnJlbW92ZUNsYXNzKCdpcy1yaWdodC1hcnJvdyBpcy1sZWZ0LWFycm93IGlzLWRvd24tYXJyb3cgb3BlbnMtcmlnaHQgb3BlbnMtbGVmdCBvcGVucy1pbm5lcicpO1xcbiAgICAgICAgJChkb2N1bWVudC5ib2R5KS5vZmYoJy56Zi5kcm9wZG93bm1lbnUnKTtcXG4gICAgICAgIEZvdW5kYXRpb24uTmVzdC5CdXJuKHRoaXMuJGVsZW1lbnQsICdkcm9wZG93bicpO1xcbiAgICAgICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xcbiAgICAgIH1cXG4gICAgfV0pO1xcblxcbiAgICByZXR1cm4gRHJvcGRvd25NZW51O1xcbiAgfSgpO1xcblxcbiAgLyoqXFxuICAgKiBEZWZhdWx0IHNldHRpbmdzIGZvciBwbHVnaW5cXG4gICAqL1xcblxcblxcbiAgRHJvcGRvd25NZW51LmRlZmF1bHRzID0ge1xcbiAgICAvKipcXG4gICAgICogRGlzYWxsb3dzIGhvdmVyIGV2ZW50cyBmcm9tIG9wZW5pbmcgc3VibWVudXNcXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSBmYWxzZVxcbiAgICAgKi9cXG4gICAgZGlzYWJsZUhvdmVyOiBmYWxzZSxcXG4gICAgLyoqXFxuICAgICAqIEFsbG93IGEgc3VibWVudSB0byBhdXRvbWF0aWNhbGx5IGNsb3NlIG9uIGEgbW91c2VsZWF2ZSBldmVudCwgaWYgbm90IGNsaWNrZWQgb3Blbi5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSB0cnVlXFxuICAgICAqL1xcbiAgICBhdXRvY2xvc2U6IHRydWUsXFxuICAgIC8qKlxcbiAgICAgKiBBbW91bnQgb2YgdGltZSB0byBkZWxheSBvcGVuaW5nIGEgc3VibWVudSBvbiBob3ZlciBldmVudC5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSA1MFxcbiAgICAgKi9cXG4gICAgaG92ZXJEZWxheTogNTAsXFxuICAgIC8qKlxcbiAgICAgKiBBbGxvdyBhIHN1Ym1lbnUgdG8gb3Blbi9yZW1haW4gb3BlbiBvbiBwYXJlbnQgY2xpY2sgZXZlbnQuIEFsbG93cyBjdXJzb3IgdG8gbW92ZSBhd2F5IGZyb20gbWVudS5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSB0cnVlXFxuICAgICAqL1xcbiAgICBjbGlja09wZW46IGZhbHNlLFxcbiAgICAvKipcXG4gICAgICogQW1vdW50IG9mIHRpbWUgdG8gZGVsYXkgY2xvc2luZyBhIHN1Ym1lbnUgb24gYSBtb3VzZWxlYXZlIGV2ZW50LlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIDUwMFxcbiAgICAgKi9cXG5cXG4gICAgY2xvc2luZ1RpbWU6IDUwMCxcXG4gICAgLyoqXFxuICAgICAqIFBvc2l0aW9uIG9mIHRoZSBtZW51IHJlbGF0aXZlIHRvIHdoYXQgZGlyZWN0aW9uIHRoZSBzdWJtZW51cyBzaG91bGQgb3Blbi4gSGFuZGxlZCBieSBKUy5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAnbGVmdCdcXG4gICAgICovXFxuICAgIGFsaWdubWVudDogJ2xlZnQnLFxcbiAgICAvKipcXG4gICAgICogQWxsb3cgY2xpY2tzIG9uIHRoZSBib2R5IHRvIGNsb3NlIGFueSBvcGVuIHN1Ym1lbnVzLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIHRydWVcXG4gICAgICovXFxuICAgIGNsb3NlT25DbGljazogdHJ1ZSxcXG4gICAgLyoqXFxuICAgICAqIENsYXNzIGFwcGxpZWQgdG8gdmVydGljYWwgb3JpZW50ZWQgbWVudXMsIEZvdW5kYXRpb24gZGVmYXVsdCBpcyBgdmVydGljYWxgLiBVcGRhdGUgdGhpcyBpZiB1c2luZyB5b3VyIG93biBjbGFzcy5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAndmVydGljYWwnXFxuICAgICAqL1xcbiAgICB2ZXJ0aWNhbENsYXNzOiAndmVydGljYWwnLFxcbiAgICAvKipcXG4gICAgICogQ2xhc3MgYXBwbGllZCB0byByaWdodC1zaWRlIG9yaWVudGVkIG1lbnVzLCBGb3VuZGF0aW9uIGRlZmF1bHQgaXMgYGFsaWduLXJpZ2h0YC4gVXBkYXRlIHRoaXMgaWYgdXNpbmcgeW91ciBvd24gY2xhc3MuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgJ2FsaWduLXJpZ2h0J1xcbiAgICAgKi9cXG4gICAgcmlnaHRDbGFzczogJ2FsaWduLXJpZ2h0JyxcXG4gICAgLyoqXFxuICAgICAqIEJvb2xlYW4gdG8gZm9yY2Ugb3ZlcmlkZSB0aGUgY2xpY2tpbmcgb2YgbGlua3MgdG8gcGVyZm9ybSBkZWZhdWx0IGFjdGlvbiwgb24gc2Vjb25kIHRvdWNoIGV2ZW50IGZvciBtb2JpbGUuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgZmFsc2VcXG4gICAgICovXFxuICAgIGZvcmNlRm9sbG93OiB0cnVlXFxuICB9O1xcblxcbiAgLy8gV2luZG93IGV4cG9ydHNcXG4gIEZvdW5kYXRpb24ucGx1Z2luKERyb3Bkb3duTWVudSwgJ0Ryb3Bkb3duTWVudScpO1xcbn0oalF1ZXJ5KTtcXG4ndXNlIHN0cmljdCc7XFxuXFxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuIWZ1bmN0aW9uICgkKSB7XFxuXFxuICAvKipcXG4gICAqIEVxdWFsaXplciBtb2R1bGUuXFxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24uZXF1YWxpemVyXFxuICAgKi9cXG5cXG4gIHZhciBFcXVhbGl6ZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIEVxdWFsaXplci5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjaW5pdFxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYWRkIHRoZSB0cmlnZ2VyIHRvLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcblxcbiAgICBmdW5jdGlvbiBFcXVhbGl6ZXIoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBFcXVhbGl6ZXIpO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBFcXVhbGl6ZXIuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuXFxuICAgICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnRXF1YWxpemVyJyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSBFcXVhbGl6ZXIgcGx1Z2luIGFuZCBjYWxscyBmdW5jdGlvbnMgdG8gZ2V0IGVxdWFsaXplciBmdW5jdGlvbmluZyBvbiBsb2FkLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG5cXG4gICAgX2NyZWF0ZUNsYXNzKEVxdWFsaXplciwgW3tcXG4gICAgICBrZXk6ICdfaW5pdCcsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgICAgdmFyIGVxSWQgPSB0aGlzLiRlbGVtZW50LmF0dHIoJ2RhdGEtZXF1YWxpemVyJykgfHwgJyc7XFxuICAgICAgICB2YXIgJHdhdGNoZWQgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLWVxdWFsaXplci13YXRjaD1cXFwiJyArIGVxSWQgKyAnXFxcIl0nKTtcXG5cXG4gICAgICAgIHRoaXMuJHdhdGNoZWQgPSAkd2F0Y2hlZC5sZW5ndGggPyAkd2F0Y2hlZCA6IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtZXF1YWxpemVyLXdhdGNoXScpO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdkYXRhLXJlc2l6ZScsIGVxSWQgfHwgRm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LCAnZXEnKSk7XFxuXFxuICAgICAgICB0aGlzLmhhc05lc3RlZCA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtZXF1YWxpemVyXScpLmxlbmd0aCA+IDA7XFxuICAgICAgICB0aGlzLmlzTmVzdGVkID0gdGhpcy4kZWxlbWVudC5wYXJlbnRzVW50aWwoZG9jdW1lbnQuYm9keSwgJ1tkYXRhLWVxdWFsaXplcl0nKS5sZW5ndGggPiAwO1xcbiAgICAgICAgdGhpcy5pc09uID0gZmFsc2U7XFxuICAgICAgICB0aGlzLl9iaW5kSGFuZGxlciA9IHtcXG4gICAgICAgICAgb25SZXNpemVNZUJvdW5kOiB0aGlzLl9vblJlc2l6ZU1lLmJpbmQodGhpcyksXFxuICAgICAgICAgIG9uUG9zdEVxdWFsaXplZEJvdW5kOiB0aGlzLl9vblBvc3RFcXVhbGl6ZWQuYmluZCh0aGlzKVxcbiAgICAgICAgfTtcXG5cXG4gICAgICAgIHZhciBpbWdzID0gdGhpcy4kZWxlbWVudC5maW5kKCdpbWcnKTtcXG4gICAgICAgIHZhciB0b29TbWFsbDtcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXF1YWxpemVPbikge1xcbiAgICAgICAgICB0b29TbWFsbCA9IHRoaXMuX2NoZWNrTVEoKTtcXG4gICAgICAgICAgJCh3aW5kb3cpLm9uKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl9jaGVja01RLmJpbmQodGhpcykpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodG9vU21hbGwgIT09IHVuZGVmaW5lZCAmJiB0b29TbWFsbCA9PT0gZmFsc2UgfHwgdG9vU21hbGwgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgICBpZiAoaW1ncy5sZW5ndGgpIHtcXG4gICAgICAgICAgICBGb3VuZGF0aW9uLm9uSW1hZ2VzTG9hZGVkKGltZ3MsIHRoaXMuX3JlZmxvdy5iaW5kKHRoaXMpKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aGlzLl9yZWZsb3coKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBSZW1vdmVzIGV2ZW50IGxpc3RlbmVycyBpZiB0aGUgYnJlYWtwb2ludCBpcyB0b28gc21hbGwuXFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ19wYXVzZUV2ZW50cycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wYXVzZUV2ZW50cygpIHtcXG4gICAgICAgIHRoaXMuaXNPbiA9IGZhbHNlO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoe1xcbiAgICAgICAgICAnLnpmLmVxdWFsaXplcic6IHRoaXMuX2JpbmRIYW5kbGVyLm9uUG9zdEVxdWFsaXplZEJvdW5kLFxcbiAgICAgICAgICAncmVzaXplbWUuemYudHJpZ2dlcic6IHRoaXMuX2JpbmRIYW5kbGVyLm9uUmVzaXplTWVCb3VuZFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIGZ1bmN0aW9uIHRvIGhhbmRsZSAkZWxlbWVudHMgcmVzaXplbWUuemYudHJpZ2dlciwgd2l0aCBib3VuZCB0aGlzIG9uIF9iaW5kSGFuZGxlci5vblJlc2l6ZU1lQm91bmRcXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX29uUmVzaXplTWUnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfb25SZXNpemVNZShlKSB7XFxuICAgICAgICB0aGlzLl9yZWZsb3coKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogZnVuY3Rpb24gdG8gaGFuZGxlICRlbGVtZW50cyBwb3N0ZXF1YWxpemVkLnpmLmVxdWFsaXplciwgd2l0aCBib3VuZCB0aGlzIG9uIF9iaW5kSGFuZGxlci5vblBvc3RFcXVhbGl6ZWRCb3VuZFxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfb25Qb3N0RXF1YWxpemVkJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX29uUG9zdEVxdWFsaXplZChlKSB7XFxuICAgICAgICBpZiAoZS50YXJnZXQgIT09IHRoaXMuJGVsZW1lbnRbMF0pIHtcXG4gICAgICAgICAgdGhpcy5fcmVmbG93KCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEluaXRpYWxpemVzIGV2ZW50cyBmb3IgRXF1YWxpemVyLlxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfZXZlbnRzJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICB0aGlzLl9wYXVzZUV2ZW50cygpO1xcbiAgICAgICAgaWYgKHRoaXMuaGFzTmVzdGVkKSB7XFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3Bvc3RlcXVhbGl6ZWQuemYuZXF1YWxpemVyJywgdGhpcy5fYmluZEhhbmRsZXIub25Qb3N0RXF1YWxpemVkQm91bmQpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5vbigncmVzaXplbWUuemYudHJpZ2dlcicsIHRoaXMuX2JpbmRIYW5kbGVyLm9uUmVzaXplTWVCb3VuZCk7XFxuICAgICAgICB9XFxuICAgICAgICB0aGlzLmlzT24gPSB0cnVlO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBDaGVja3MgdGhlIGN1cnJlbnQgYnJlYWtwb2ludCB0byB0aGUgbWluaW11bSByZXF1aXJlZCBzaXplLlxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfY2hlY2tNUScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja01RKCkge1xcbiAgICAgICAgdmFyIHRvb1NtYWxsID0gIUZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHRoaXMub3B0aW9ucy5lcXVhbGl6ZU9uKTtcXG4gICAgICAgIGlmICh0b29TbWFsbCkge1xcbiAgICAgICAgICBpZiAodGhpcy5pc09uKSB7XFxuICAgICAgICAgICAgdGhpcy5fcGF1c2VFdmVudHMoKTtcXG4gICAgICAgICAgICB0aGlzLiR3YXRjaGVkLmNzcygnaGVpZ2h0JywgJ2F1dG8nKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaWYgKCF0aGlzLmlzT24pIHtcXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHRvb1NtYWxsO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBBIG5vb3AgdmVyc2lvbiBmb3IgdGhlIHBsdWdpblxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfa2lsbHN3aXRjaCcsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9raWxsc3dpdGNoKCkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBDYWxscyBuZWNlc3NhcnkgZnVuY3Rpb25zIHRvIHVwZGF0ZSBFcXVhbGl6ZXIgdXBvbiBET00gY2hhbmdlXFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ19yZWZsb3cnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcmVmbG93KCkge1xcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZXF1YWxpemVPblN0YWNrKSB7XFxuICAgICAgICAgIGlmICh0aGlzLl9pc1N0YWNrZWQoKSkge1xcbiAgICAgICAgICAgIHRoaXMuJHdhdGNoZWQuY3NzKCdoZWlnaHQnLCAnYXV0bycpO1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lcXVhbGl6ZUJ5Um93KSB7XFxuICAgICAgICAgIHRoaXMuZ2V0SGVpZ2h0c0J5Um93KHRoaXMuYXBwbHlIZWlnaHRCeVJvdy5iaW5kKHRoaXMpKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMuZ2V0SGVpZ2h0cyh0aGlzLmFwcGx5SGVpZ2h0LmJpbmQodGhpcykpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBNYW51YWxseSBkZXRlcm1pbmVzIGlmIHRoZSBmaXJzdCAyIGVsZW1lbnRzIGFyZSAqTk9UKiBzdGFja2VkLlxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfaXNTdGFja2VkJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2lzU3RhY2tlZCgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLiR3YXRjaGVkWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCAhPT0gdGhpcy4kd2F0Y2hlZFsxXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3A7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEZpbmRzIHRoZSBvdXRlciBoZWlnaHRzIG9mIGNoaWxkcmVuIGNvbnRhaW5lZCB3aXRoaW4gYW4gRXF1YWxpemVyIHBhcmVudCBhbmQgcmV0dXJucyB0aGVtIGluIGFuIGFycmF5XFxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBBIG5vbi1vcHRpb25hbCBjYWxsYmFjayB0byByZXR1cm4gdGhlIGhlaWdodHMgYXJyYXkgdG8uXFxuICAgICAgICogQHJldHVybnMge0FycmF5fSBoZWlnaHRzIC0gQW4gYXJyYXkgb2YgaGVpZ2h0cyBvZiBjaGlsZHJlbiB3aXRoaW4gRXF1YWxpemVyIGNvbnRhaW5lclxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnZ2V0SGVpZ2h0cycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdldEhlaWdodHMoY2IpIHtcXG4gICAgICAgIHZhciBoZWlnaHRzID0gW107XFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy4kd2F0Y2hlZC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xcbiAgICAgICAgICB0aGlzLiR3YXRjaGVkW2ldLnN0eWxlLmhlaWdodCA9ICdhdXRvJztcXG4gICAgICAgICAgaGVpZ2h0cy5wdXNoKHRoaXMuJHdhdGNoZWRbaV0ub2Zmc2V0SGVpZ2h0KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNiKGhlaWdodHMpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBGaW5kcyB0aGUgb3V0ZXIgaGVpZ2h0cyBvZiBjaGlsZHJlbiBjb250YWluZWQgd2l0aGluIGFuIEVxdWFsaXplciBwYXJlbnQgYW5kIHJldHVybnMgdGhlbSBpbiBhbiBhcnJheVxcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIC0gQSBub24tb3B0aW9uYWwgY2FsbGJhY2sgdG8gcmV0dXJuIHRoZSBoZWlnaHRzIGFycmF5IHRvLlxcbiAgICAgICAqIEByZXR1cm5zIHtBcnJheX0gZ3JvdXBzIC0gQW4gYXJyYXkgb2YgaGVpZ2h0cyBvZiBjaGlsZHJlbiB3aXRoaW4gRXF1YWxpemVyIGNvbnRhaW5lciBncm91cGVkIGJ5IHJvdyB3aXRoIGVsZW1lbnQsaGVpZ2h0IGFuZCBtYXggYXMgbGFzdCBjaGlsZFxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnZ2V0SGVpZ2h0c0J5Um93JyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZ2V0SGVpZ2h0c0J5Um93KGNiKSB7XFxuICAgICAgICB2YXIgbGFzdEVsVG9wT2Zmc2V0ID0gdGhpcy4kd2F0Y2hlZC5sZW5ndGggPyB0aGlzLiR3YXRjaGVkLmZpcnN0KCkub2Zmc2V0KCkudG9wIDogMCxcXG4gICAgICAgICAgICBncm91cHMgPSBbXSxcXG4gICAgICAgICAgICBncm91cCA9IDA7XFxuICAgICAgICAvL2dyb3VwIGJ5IFJvd1xcbiAgICAgICAgZ3JvdXBzW2dyb3VwXSA9IFtdO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuJHdhdGNoZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgICAgICAgdGhpcy4kd2F0Y2hlZFtpXS5zdHlsZS5oZWlnaHQgPSAnYXV0byc7XFxuICAgICAgICAgIC8vbWF5YmUgY291bGQgdXNlIHRoaXMuJHdhdGNoZWRbaV0ub2Zmc2V0VG9wXFxuICAgICAgICAgIHZhciBlbE9mZnNldFRvcCA9ICQodGhpcy4kd2F0Y2hlZFtpXSkub2Zmc2V0KCkudG9wO1xcbiAgICAgICAgICBpZiAoZWxPZmZzZXRUb3AgIT0gbGFzdEVsVG9wT2Zmc2V0KSB7XFxuICAgICAgICAgICAgZ3JvdXArKztcXG4gICAgICAgICAgICBncm91cHNbZ3JvdXBdID0gW107XFxuICAgICAgICAgICAgbGFzdEVsVG9wT2Zmc2V0ID0gZWxPZmZzZXRUb3A7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgZ3JvdXBzW2dyb3VwXS5wdXNoKFt0aGlzLiR3YXRjaGVkW2ldLCB0aGlzLiR3YXRjaGVkW2ldLm9mZnNldEhlaWdodF0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgZm9yICh2YXIgaiA9IDAsIGxuID0gZ3JvdXBzLmxlbmd0aDsgaiA8IGxuOyBqKyspIHtcXG4gICAgICAgICAgdmFyIGhlaWdodHMgPSAkKGdyb3Vwc1tqXSkubWFwKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpc1sxXTtcXG4gICAgICAgICAgfSkuZ2V0KCk7XFxuICAgICAgICAgIHZhciBtYXggPSBNYXRoLm1heC5hcHBseShudWxsLCBoZWlnaHRzKTtcXG4gICAgICAgICAgZ3JvdXBzW2pdLnB1c2gobWF4KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNiKGdyb3Vwcyk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIENoYW5nZXMgdGhlIENTUyBoZWlnaHQgcHJvcGVydHkgb2YgZWFjaCBjaGlsZCBpbiBhbiBFcXVhbGl6ZXIgcGFyZW50IHRvIG1hdGNoIHRoZSB0YWxsZXN0XFxuICAgICAgICogQHBhcmFtIHthcnJheX0gaGVpZ2h0cyAtIEFuIGFycmF5IG9mIGhlaWdodHMgb2YgY2hpbGRyZW4gd2l0aGluIEVxdWFsaXplciBjb250YWluZXJcXG4gICAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3ByZWVxdWFsaXplZFxcbiAgICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjcG9zdGVxdWFsaXplZFxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnYXBwbHlIZWlnaHQnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseUhlaWdodChoZWlnaHRzKSB7XFxuICAgICAgICB2YXIgbWF4ID0gTWF0aC5tYXguYXBwbHkobnVsbCwgaGVpZ2h0cyk7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEZpcmVzIGJlZm9yZSB0aGUgaGVpZ2h0cyBhcmUgYXBwbGllZFxcbiAgICAgICAgICogQGV2ZW50IEVxdWFsaXplciNwcmVlcXVhbGl6ZWRcXG4gICAgICAgICAqL1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwcmVlcXVhbGl6ZWQuemYuZXF1YWxpemVyJyk7XFxuXFxuICAgICAgICB0aGlzLiR3YXRjaGVkLmNzcygnaGVpZ2h0JywgbWF4KTtcXG5cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgaGVpZ2h0cyBoYXZlIGJlZW4gYXBwbGllZFxcbiAgICAgICAgICogQGV2ZW50IEVxdWFsaXplciNwb3N0ZXF1YWxpemVkXFxuICAgICAgICAgKi9cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXInKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogQ2hhbmdlcyB0aGUgQ1NTIGhlaWdodCBwcm9wZXJ0eSBvZiBlYWNoIGNoaWxkIGluIGFuIEVxdWFsaXplciBwYXJlbnQgdG8gbWF0Y2ggdGhlIHRhbGxlc3QgYnkgcm93XFxuICAgICAgICogQHBhcmFtIHthcnJheX0gZ3JvdXBzIC0gQW4gYXJyYXkgb2YgaGVpZ2h0cyBvZiBjaGlsZHJlbiB3aXRoaW4gRXF1YWxpemVyIGNvbnRhaW5lciBncm91cGVkIGJ5IHJvdyB3aXRoIGVsZW1lbnQsaGVpZ2h0IGFuZCBtYXggYXMgbGFzdCBjaGlsZFxcbiAgICAgICAqIEBmaXJlcyBFcXVhbGl6ZXIjcHJlZXF1YWxpemVkXFxuICAgICAgICogQGZpcmVzIEVxdWFsaXplciNwcmVlcXVhbGl6ZWRSb3dcXG4gICAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRSb3dcXG4gICAgICAgKiBAZmlyZXMgRXF1YWxpemVyI3Bvc3RlcXVhbGl6ZWRcXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ2FwcGx5SGVpZ2h0QnlSb3cnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBhcHBseUhlaWdodEJ5Um93KGdyb3Vwcykge1xcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBGaXJlcyBiZWZvcmUgdGhlIGhlaWdodHMgYXJlIGFwcGxpZWRcXG4gICAgICAgICAqL1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdwcmVlcXVhbGl6ZWQuemYuZXF1YWxpemVyJyk7XFxuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZ3JvdXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgICAgICAgIHZhciBncm91cHNJTGVuZ3RoID0gZ3JvdXBzW2ldLmxlbmd0aCxcXG4gICAgICAgICAgICAgIG1heCA9IGdyb3Vwc1tpXVtncm91cHNJTGVuZ3RoIC0gMV07XFxuICAgICAgICAgIGlmIChncm91cHNJTGVuZ3RoIDw9IDIpIHtcXG4gICAgICAgICAgICAkKGdyb3Vwc1tpXVswXVswXSkuY3NzKHsgJ2hlaWdodCc6ICdhdXRvJyB9KTtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICAvKipcXG4gICAgICAgICAgICAqIEZpcmVzIGJlZm9yZSB0aGUgaGVpZ2h0cyBwZXIgcm93IGFyZSBhcHBsaWVkXFxuICAgICAgICAgICAgKiBAZXZlbnQgRXF1YWxpemVyI3ByZWVxdWFsaXplZFJvd1xcbiAgICAgICAgICAgICovXFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncHJlZXF1YWxpemVkcm93LnpmLmVxdWFsaXplcicpO1xcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgbGVuSiA9IGdyb3Vwc0lMZW5ndGggLSAxOyBqIDwgbGVuSjsgaisrKSB7XFxuICAgICAgICAgICAgJChncm91cHNbaV1bal1bMF0pLmNzcyh7ICdoZWlnaHQnOiBtYXggfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgLyoqXFxuICAgICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBoZWlnaHRzIHBlciByb3cgaGF2ZSBiZWVuIGFwcGxpZWRcXG4gICAgICAgICAgICAqIEBldmVudCBFcXVhbGl6ZXIjcG9zdGVxdWFsaXplZFJvd1xcbiAgICAgICAgICAgICovXFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigncG9zdGVxdWFsaXplZHJvdy56Zi5lcXVhbGl6ZXInKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgaGVpZ2h0cyBoYXZlIGJlZW4gYXBwbGllZFxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3Bvc3RlcXVhbGl6ZWQuemYuZXF1YWxpemVyJyk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIEVxdWFsaXplci5cXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ2Rlc3Ryb3knLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xcbiAgICAgICAgdGhpcy5fcGF1c2VFdmVudHMoKTtcXG4gICAgICAgIHRoaXMuJHdhdGNoZWQuY3NzKCdoZWlnaHQnLCAnYXV0bycpO1xcblxcbiAgICAgICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xcbiAgICAgIH1cXG4gICAgfV0pO1xcblxcbiAgICByZXR1cm4gRXF1YWxpemVyO1xcbiAgfSgpO1xcblxcbiAgLyoqXFxuICAgKiBEZWZhdWx0IHNldHRpbmdzIGZvciBwbHVnaW5cXG4gICAqL1xcblxcblxcbiAgRXF1YWxpemVyLmRlZmF1bHRzID0ge1xcbiAgICAvKipcXG4gICAgICogRW5hYmxlIGhlaWdodCBlcXVhbGl6YXRpb24gd2hlbiBzdGFja2VkIG9uIHNtYWxsZXIgc2NyZWVucy5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSB0cnVlXFxuICAgICAqL1xcbiAgICBlcXVhbGl6ZU9uU3RhY2s6IHRydWUsXFxuICAgIC8qKlxcbiAgICAgKiBFbmFibGUgaGVpZ2h0IGVxdWFsaXphdGlvbiByb3cgYnkgcm93LlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIGZhbHNlXFxuICAgICAqL1xcbiAgICBlcXVhbGl6ZUJ5Um93OiBmYWxzZSxcXG4gICAgLyoqXFxuICAgICAqIFN0cmluZyByZXByZXNlbnRpbmcgdGhlIG1pbmltdW0gYnJlYWtwb2ludCBzaXplIHRoZSBwbHVnaW4gc2hvdWxkIGVxdWFsaXplIGhlaWdodHMgb24uXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgJ21lZGl1bSdcXG4gICAgICovXFxuICAgIGVxdWFsaXplT246ICcnXFxuICB9O1xcblxcbiAgLy8gV2luZG93IGV4cG9ydHNcXG4gIEZvdW5kYXRpb24ucGx1Z2luKEVxdWFsaXplciwgJ0VxdWFsaXplcicpO1xcbn0oalF1ZXJ5KTtcXG4ndXNlIHN0cmljdCc7XFxuXFxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuIWZ1bmN0aW9uICgkKSB7XFxuXFxuICAvKipcXG4gICAqIEludGVyY2hhbmdlIG1vZHVsZS5cXG4gICAqIEBtb2R1bGUgZm91bmRhdGlvbi5pbnRlcmNoYW5nZVxcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRpbWVyQW5kSW1hZ2VMb2FkZXJcXG4gICAqL1xcblxcbiAgdmFyIEludGVyY2hhbmdlID0gZnVuY3Rpb24gKCkge1xcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBJbnRlcmNoYW5nZS5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBmaXJlcyBJbnRlcmNoYW5nZSNpbml0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cXG4gICAgICovXFxuXFxuICAgIGZ1bmN0aW9uIEludGVyY2hhbmdlKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgSW50ZXJjaGFuZ2UpO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBJbnRlcmNoYW5nZS5kZWZhdWx0cywgb3B0aW9ucyk7XFxuICAgICAgdGhpcy5ydWxlcyA9IFtdO1xcbiAgICAgIHRoaXMuY3VycmVudFBhdGggPSAnJztcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuXFxuICAgICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnSW50ZXJjaGFuZ2UnKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIEludGVyY2hhbmdlIHBsdWdpbiBhbmQgY2FsbHMgZnVuY3Rpb25zIHRvIGdldCBpbnRlcmNoYW5nZSBmdW5jdGlvbmluZyBvbiBsb2FkLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuXFxuICAgIF9jcmVhdGVDbGFzcyhJbnRlcmNoYW5nZSwgW3tcXG4gICAgICBrZXk6ICdfaW5pdCcsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgICAgdGhpcy5fYWRkQnJlYWtwb2ludHMoKTtcXG4gICAgICAgIHRoaXMuX2dlbmVyYXRlUnVsZXMoKTtcXG4gICAgICAgIHRoaXMuX3JlZmxvdygpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIEludGVyY2hhbmdlLlxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfZXZlbnRzJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICAgICQod2luZG93KS5vbigncmVzaXplLnpmLmludGVyY2hhbmdlJywgRm91bmRhdGlvbi51dGlsLnRocm90dGxlKHRoaXMuX3JlZmxvdy5iaW5kKHRoaXMpLCA1MCkpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBDYWxscyBuZWNlc3NhcnkgZnVuY3Rpb25zIHRvIHVwZGF0ZSBJbnRlcmNoYW5nZSB1cG9uIERPTSBjaGFuZ2VcXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX3JlZmxvdycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZWZsb3coKSB7XFxuICAgICAgICB2YXIgbWF0Y2g7XFxuXFxuICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBydWxlLCBidXQgb25seSBzYXZlIHRoZSBsYXN0IG1hdGNoXFxuICAgICAgICBmb3IgKHZhciBpIGluIHRoaXMucnVsZXMpIHtcXG4gICAgICAgICAgaWYgKHRoaXMucnVsZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICB2YXIgcnVsZSA9IHRoaXMucnVsZXNbaV07XFxuXFxuICAgICAgICAgICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKHJ1bGUucXVlcnkpLm1hdGNoZXMpIHtcXG4gICAgICAgICAgICAgIG1hdGNoID0gcnVsZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChtYXRjaCkge1xcbiAgICAgICAgICB0aGlzLnJlcGxhY2UobWF0Y2gucGF0aCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEdldHMgdGhlIEZvdW5kYXRpb24gYnJlYWtwb2ludHMgYW5kIGFkZHMgdGhlbSB0byB0aGUgSW50ZXJjaGFuZ2UuU1BFQ0lBTF9RVUVSSUVTIG9iamVjdC5cXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX2FkZEJyZWFrcG9pbnRzJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2FkZEJyZWFrcG9pbnRzKCkge1xcbiAgICAgICAgZm9yICh2YXIgaSBpbiBGb3VuZGF0aW9uLk1lZGlhUXVlcnkucXVlcmllcykge1xcbiAgICAgICAgICBpZiAoRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LnF1ZXJpZXMuaGFzT3duUHJvcGVydHkoaSkpIHtcXG4gICAgICAgICAgICB2YXIgcXVlcnkgPSBGb3VuZGF0aW9uLk1lZGlhUXVlcnkucXVlcmllc1tpXTtcXG4gICAgICAgICAgICBJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVNbcXVlcnkubmFtZV0gPSBxdWVyeS52YWx1ZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBDaGVja3MgdGhlIEludGVyY2hhbmdlIGVsZW1lbnQgZm9yIHRoZSBwcm92aWRlZCBtZWRpYSBxdWVyeSArIGNvbnRlbnQgcGFpcmluZ3NcXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0aGF0IGlzIGFuIEludGVyY2hhbmdlIGluc3RhbmNlXFxuICAgICAgICogQHJldHVybnMge0FycmF5fSBzY2VuYXJpb3MgLSBBcnJheSBvZiBvYmplY3RzIHRoYXQgaGF2ZSAnbXEnIGFuZCAncGF0aCcga2V5cyB3aXRoIGNvcnJlc3BvbmRpbmcga2V5c1xcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX2dlbmVyYXRlUnVsZXMnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2VuZXJhdGVSdWxlcyhlbGVtZW50KSB7XFxuICAgICAgICB2YXIgcnVsZXNMaXN0ID0gW107XFxuICAgICAgICB2YXIgcnVsZXM7XFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJ1bGVzKSB7XFxuICAgICAgICAgIHJ1bGVzID0gdGhpcy5vcHRpb25zLnJ1bGVzO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgcnVsZXMgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ2ludGVyY2hhbmdlJykubWF0Y2goL1xcXFxbLio/XFxcXF0vZyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBmb3IgKHZhciBpIGluIHJ1bGVzKSB7XFxuICAgICAgICAgIGlmIChydWxlcy5oYXNPd25Qcm9wZXJ0eShpKSkge1xcbiAgICAgICAgICAgIHZhciBydWxlID0gcnVsZXNbaV0uc2xpY2UoMSwgLTEpLnNwbGl0KCcsICcpO1xcbiAgICAgICAgICAgIHZhciBwYXRoID0gcnVsZS5zbGljZSgwLCAtMSkuam9pbignJyk7XFxuICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gcnVsZVtydWxlLmxlbmd0aCAtIDFdO1xcblxcbiAgICAgICAgICAgIGlmIChJbnRlcmNoYW5nZS5TUEVDSUFMX1FVRVJJRVNbcXVlcnldKSB7XFxuICAgICAgICAgICAgICBxdWVyeSA9IEludGVyY2hhbmdlLlNQRUNJQUxfUVVFUklFU1txdWVyeV07XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJ1bGVzTGlzdC5wdXNoKHtcXG4gICAgICAgICAgICAgIHBhdGg6IHBhdGgsXFxuICAgICAgICAgICAgICBxdWVyeTogcXVlcnlcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5ydWxlcyA9IHJ1bGVzTGlzdDtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogVXBkYXRlIHRoZSBgc3JjYCBwcm9wZXJ0eSBvZiBhbiBpbWFnZSwgb3IgY2hhbmdlIHRoZSBIVE1MIG9mIGEgY29udGFpbmVyLCB0byB0aGUgc3BlY2lmaWVkIHBhdGguXFxuICAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBhdGggLSBQYXRoIHRvIHRoZSBpbWFnZSBvciBIVE1MIHBhcnRpYWwuXFxuICAgICAgICogQGZpcmVzIEludGVyY2hhbmdlI3JlcGxhY2VkXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdyZXBsYWNlJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVwbGFjZShwYXRoKSB7XFxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aCA9PT0gcGF0aCkgcmV0dXJuO1xcblxcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcyxcXG4gICAgICAgICAgICB0cmlnZ2VyID0gJ3JlcGxhY2VkLnpmLmludGVyY2hhbmdlJztcXG5cXG4gICAgICAgIC8vIFJlcGxhY2luZyBpbWFnZXNcXG4gICAgICAgIGlmICh0aGlzLiRlbGVtZW50WzBdLm5vZGVOYW1lID09PSAnSU1HJykge1xcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ3NyYycsIHBhdGgpLmxvYWQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIF90aGlzLmN1cnJlbnRQYXRoID0gcGF0aDtcXG4gICAgICAgICAgfSkudHJpZ2dlcih0cmlnZ2VyKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIFJlcGxhY2luZyBiYWNrZ3JvdW5kIGltYWdlc1xcbiAgICAgICAgZWxzZSBpZiAocGF0aC5tYXRjaCgvXFxcXC4oZ2lmfGpwZ3xqcGVnfHBuZ3xzdmd8dGlmZikoWz8jXS4qKT8vaSkpIHtcXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LmNzcyh7ICdiYWNrZ3JvdW5kLWltYWdlJzogJ3VybCgnICsgcGF0aCArICcpJyB9KS50cmlnZ2VyKHRyaWdnZXIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIC8vIFJlcGxhY2luZyBIVE1MXFxuICAgICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgICAgJC5nZXQocGF0aCwgZnVuY3Rpb24gKHJlc3BvbnNlKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLiRlbGVtZW50Lmh0bWwocmVzcG9uc2UpLnRyaWdnZXIodHJpZ2dlcik7XFxuICAgICAgICAgICAgICAgICQocmVzcG9uc2UpLmZvdW5kYXRpb24oKTtcXG4gICAgICAgICAgICAgICAgX3RoaXMuY3VycmVudFBhdGggPSBwYXRoO1xcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBGaXJlcyB3aGVuIGNvbnRlbnQgaW4gYW4gSW50ZXJjaGFuZ2UgZWxlbWVudCBpcyBkb25lIGJlaW5nIGxvYWRlZC5cXG4gICAgICAgICAqIEBldmVudCBJbnRlcmNoYW5nZSNyZXBsYWNlZFxcbiAgICAgICAgICovXFxuICAgICAgICAvLyB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3JlcGxhY2VkLnpmLmludGVyY2hhbmdlJyk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIGludGVyY2hhbmdlLlxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnZGVzdHJveScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuICAgICAgICAvL1RPRE8gdGhpcy5cXG4gICAgICB9XFxuICAgIH1dKTtcXG5cXG4gICAgcmV0dXJuIEludGVyY2hhbmdlO1xcbiAgfSgpO1xcblxcbiAgLyoqXFxuICAgKiBEZWZhdWx0IHNldHRpbmdzIGZvciBwbHVnaW5cXG4gICAqL1xcblxcblxcbiAgSW50ZXJjaGFuZ2UuZGVmYXVsdHMgPSB7XFxuICAgIC8qKlxcbiAgICAgKiBSdWxlcyB0byBiZSBhcHBsaWVkIHRvIEludGVyY2hhbmdlIGVsZW1lbnRzLiBTZXQgd2l0aCB0aGUgYGRhdGEtaW50ZXJjaGFuZ2VgIGFycmF5IG5vdGF0aW9uLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqL1xcbiAgICBydWxlczogbnVsbFxcbiAgfTtcXG5cXG4gIEludGVyY2hhbmdlLlNQRUNJQUxfUVVFUklFUyA9IHtcXG4gICAgJ2xhbmRzY2FwZSc6ICdzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKScsXFxuICAgICdwb3J0cmFpdCc6ICdzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogcG9ydHJhaXQpJyxcXG4gICAgJ3JldGluYSc6ICdvbmx5IHNjcmVlbiBhbmQgKC13ZWJraXQtbWluLWRldmljZS1waXhlbC1yYXRpbzogMiksIG9ubHkgc2NyZWVuIGFuZCAobWluLS1tb3otZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwgb25seSBzY3JlZW4gYW5kICgtby1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyLzEpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAxOTJkcGkpLCBvbmx5IHNjcmVlbiBhbmQgKG1pbi1yZXNvbHV0aW9uOiAyZHBweCknXFxuICB9O1xcblxcbiAgLy8gV2luZG93IGV4cG9ydHNcXG4gIEZvdW5kYXRpb24ucGx1Z2luKEludGVyY2hhbmdlLCAnSW50ZXJjaGFuZ2UnKTtcXG59KGpRdWVyeSk7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbiFmdW5jdGlvbiAoJCkge1xcblxcbiAgLyoqXFxuICAgKiBNYWdlbGxhbiBtb2R1bGUuXFxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24ubWFnZWxsYW5cXG4gICAqL1xcblxcbiAgdmFyIE1hZ2VsbGFuID0gZnVuY3Rpb24gKCkge1xcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBNYWdlbGxhbi5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBmaXJlcyBNYWdlbGxhbiNpbml0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cXG4gICAgICovXFxuXFxuICAgIGZ1bmN0aW9uIE1hZ2VsbGFuKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgTWFnZWxsYW4pO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBNYWdlbGxhbi5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcblxcbiAgICAgIHRoaXMuX2luaXQoKTtcXG5cXG4gICAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdNYWdlbGxhbicpO1xcbiAgICB9XFxuXFxuICAgIC8qKlxcbiAgICAgKiBJbml0aWFsaXplcyB0aGUgTWFnZWxsYW4gcGx1Z2luIGFuZCBjYWxscyBmdW5jdGlvbnMgdG8gZ2V0IGVxdWFsaXplciBmdW5jdGlvbmluZyBvbiBsb2FkLlxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG5cXG4gICAgX2NyZWF0ZUNsYXNzKE1hZ2VsbGFuLCBbe1xcbiAgICAgIGtleTogJ19pbml0JyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgICB2YXIgaWQgPSB0aGlzLiRlbGVtZW50WzBdLmlkIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgJ21hZ2VsbGFuJyk7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgdGhpcy4kdGFyZ2V0cyA9ICQoJ1tkYXRhLW1hZ2VsbGFuLXRhcmdldF0nKTtcXG4gICAgICAgIHRoaXMuJGxpbmtzID0gdGhpcy4kZWxlbWVudC5maW5kKCdhJyk7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmF0dHIoe1xcbiAgICAgICAgICAnZGF0YS1yZXNpemUnOiBpZCxcXG4gICAgICAgICAgJ2RhdGEtc2Nyb2xsJzogaWQsXFxuICAgICAgICAgICdpZCc6IGlkXFxuICAgICAgICB9KTtcXG4gICAgICAgIHRoaXMuJGFjdGl2ZSA9ICQoKTtcXG4gICAgICAgIHRoaXMuc2Nyb2xsUG9zID0gcGFyc2VJbnQod2luZG93LnBhZ2VZT2Zmc2V0LCAxMCk7XFxuXFxuICAgICAgICB0aGlzLl9ldmVudHMoKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogQ2FsY3VsYXRlcyBhbiBhcnJheSBvZiBwaXhlbCB2YWx1ZXMgdGhhdCBhcmUgdGhlIGRlbWFyY2F0aW9uIGxpbmVzIGJldHdlZW4gbG9jYXRpb25zIG9uIHRoZSBwYWdlLlxcbiAgICAgICAqIENhbiBiZSBpbnZva2VkIGlmIG5ldyBlbGVtZW50cyBhcmUgYWRkZWQgb3IgdGhlIHNpemUgb2YgYSBsb2NhdGlvbiBjaGFuZ2VzLlxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnY2FsY1BvaW50cycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNhbGNQb2ludHMoKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICAgIGJvZHkgPSBkb2N1bWVudC5ib2R5LFxcbiAgICAgICAgICAgIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XFxuXFxuICAgICAgICB0aGlzLnBvaW50cyA9IFtdO1xcbiAgICAgICAgdGhpcy53aW5IZWlnaHQgPSBNYXRoLnJvdW5kKE1hdGgubWF4KHdpbmRvdy5pbm5lckhlaWdodCwgaHRtbC5jbGllbnRIZWlnaHQpKTtcXG4gICAgICAgIHRoaXMuZG9jSGVpZ2h0ID0gTWF0aC5yb3VuZChNYXRoLm1heChib2R5LnNjcm9sbEhlaWdodCwgYm9keS5vZmZzZXRIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBodG1sLnNjcm9sbEhlaWdodCwgaHRtbC5vZmZzZXRIZWlnaHQpKTtcXG5cXG4gICAgICAgIHRoaXMuJHRhcmdldHMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciAkdGFyID0gJCh0aGlzKSxcXG4gICAgICAgICAgICAgIHB0ID0gTWF0aC5yb3VuZCgkdGFyLm9mZnNldCgpLnRvcCAtIF90aGlzLm9wdGlvbnMudGhyZXNob2xkKTtcXG4gICAgICAgICAgJHRhci50YXJnZXRQb2ludCA9IHB0O1xcbiAgICAgICAgICBfdGhpcy5wb2ludHMucHVzaChwdCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogSW5pdGlhbGl6ZXMgZXZlbnRzIGZvciBNYWdlbGxhbi5cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX2V2ZW50cycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICAgICRib2R5ID0gJCgnaHRtbCwgYm9keScpLFxcbiAgICAgICAgICAgIG9wdHMgPSB7XFxuICAgICAgICAgIGR1cmF0aW9uOiBfdGhpcy5vcHRpb25zLmFuaW1hdGlvbkR1cmF0aW9uLFxcbiAgICAgICAgICBlYXNpbmc6IF90aGlzLm9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nXFxuICAgICAgICB9O1xcbiAgICAgICAgJCh3aW5kb3cpLm9uZSgnbG9hZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgaWYgKF90aGlzLm9wdGlvbnMuZGVlcExpbmtpbmcpIHtcXG4gICAgICAgICAgICBpZiAobG9jYXRpb24uaGFzaCkge1xcbiAgICAgICAgICAgICAgX3RoaXMuc2Nyb2xsVG9Mb2MobG9jYXRpb24uaGFzaCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIF90aGlzLmNhbGNQb2ludHMoKTtcXG4gICAgICAgICAgX3RoaXMuX3VwZGF0ZUFjdGl2ZSgpO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKHtcXG4gICAgICAgICAgJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInOiB0aGlzLnJlZmxvdy5iaW5kKHRoaXMpLFxcbiAgICAgICAgICAnc2Nyb2xsbWUuemYudHJpZ2dlcic6IHRoaXMuX3VwZGF0ZUFjdGl2ZS5iaW5kKHRoaXMpXFxuICAgICAgICB9KS5vbignY2xpY2suemYubWFnZWxsYW4nLCAnYVtocmVmXj1cXFwiI1xcXCJdJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICB2YXIgYXJyaXZhbCA9IHRoaXMuZ2V0QXR0cmlidXRlKCdocmVmJyk7XFxuICAgICAgICAgIF90aGlzLnNjcm9sbFRvTG9jKGFycml2YWwpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEZ1bmN0aW9uIHRvIHNjcm9sbCB0byBhIGdpdmVuIGxvY2F0aW9uIG9uIHRoZSBwYWdlLlxcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBsb2MgLSBhIHByb3Blcmx5IGZvcm1hdHRlZCBqUXVlcnkgaWQgc2VsZWN0b3IuIEV4YW1wbGU6ICcjZm9vJ1xcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnc2Nyb2xsVG9Mb2MnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBzY3JvbGxUb0xvYyhsb2MpIHtcXG4gICAgICAgIHZhciBzY3JvbGxQb3MgPSBNYXRoLnJvdW5kKCQobG9jKS5vZmZzZXQoKS50b3AgLSB0aGlzLm9wdGlvbnMudGhyZXNob2xkIC8gMiAtIHRoaXMub3B0aW9ucy5iYXJPZmZzZXQpO1xcblxcbiAgICAgICAgJCgnaHRtbCwgYm9keScpLnN0b3AodHJ1ZSkuYW5pbWF0ZSh7IHNjcm9sbFRvcDogc2Nyb2xsUG9zIH0sIHRoaXMub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbiwgdGhpcy5vcHRpb25zLmFuaW1hdGlvbkVhc2luZyk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIENhbGxzIG5lY2Vzc2FyeSBmdW5jdGlvbnMgdG8gdXBkYXRlIE1hZ2VsbGFuIHVwb24gRE9NIGNoYW5nZVxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAncmVmbG93JyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gcmVmbG93KCkge1xcbiAgICAgICAgdGhpcy5jYWxjUG9pbnRzKCk7XFxuICAgICAgICB0aGlzLl91cGRhdGVBY3RpdmUoKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogVXBkYXRlcyB0aGUgdmlzaWJpbGl0eSBvZiBhbiBhY3RpdmUgbG9jYXRpb24gbGluaywgYW5kIHVwZGF0ZXMgdGhlIHVybCBoYXNoIGZvciB0aGUgcGFnZSwgaWYgZGVlcExpbmtpbmcgZW5hYmxlZC5cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqIEBmaXJlcyBNYWdlbGxhbiN1cGRhdGVcXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ191cGRhdGVBY3RpdmUnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQWN0aXZlKCkgLypldnQsIGVsZW0sIHNjcm9sbFBvcyove1xcbiAgICAgICAgdmFyIHdpblBvcyA9IC8qc2Nyb2xsUG9zIHx8Ki9wYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQsIDEwKSxcXG4gICAgICAgICAgICBjdXJJZHg7XFxuXFxuICAgICAgICBpZiAod2luUG9zICsgdGhpcy53aW5IZWlnaHQgPT09IHRoaXMuZG9jSGVpZ2h0KSB7XFxuICAgICAgICAgIGN1cklkeCA9IHRoaXMucG9pbnRzLmxlbmd0aCAtIDE7XFxuICAgICAgICB9IGVsc2UgaWYgKHdpblBvcyA8IHRoaXMucG9pbnRzWzBdKSB7XFxuICAgICAgICAgIGN1cklkeCA9IDA7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB2YXIgaXNEb3duID0gdGhpcy5zY3JvbGxQb3MgPCB3aW5Qb3MsXFxuICAgICAgICAgICAgICBfdGhpcyA9IHRoaXMsXFxuICAgICAgICAgICAgICBjdXJWaXNpYmxlID0gdGhpcy5wb2ludHMuZmlsdGVyKGZ1bmN0aW9uIChwLCBpKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGlzRG93biA/IHAgLSBfdGhpcy5vcHRpb25zLmJhck9mZnNldCA8PSB3aW5Qb3MgOiBwIC0gX3RoaXMub3B0aW9ucy5iYXJPZmZzZXQgLSBfdGhpcy5vcHRpb25zLnRocmVzaG9sZCA8PSB3aW5Qb3M7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBjdXJJZHggPSBjdXJWaXNpYmxlLmxlbmd0aCA/IGN1clZpc2libGUubGVuZ3RoIC0gMSA6IDA7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLiRhY3RpdmUucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcXG4gICAgICAgIHRoaXMuJGFjdGl2ZSA9IHRoaXMuJGxpbmtzLmVxKGN1cklkeCkuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmtpbmcpIHtcXG4gICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLiRhY3RpdmVbMF0uZ2V0QXR0cmlidXRlKCdocmVmJyk7XFxuICAgICAgICAgIGlmICh3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUpIHtcXG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgbnVsbCwgaGFzaCk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSBoYXNoO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLnNjcm9sbFBvcyA9IHdpblBvcztcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiBtYWdlbGxhbiBpcyBmaW5pc2hlZCB1cGRhdGluZyB0byB0aGUgbmV3IGFjdGl2ZSBlbGVtZW50LlxcbiAgICAgICAgICogQGV2ZW50IE1hZ2VsbGFuI3VwZGF0ZVxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3VwZGF0ZS56Zi5tYWdlbGxhbicsIFt0aGlzLiRhY3RpdmVdKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgTWFnZWxsYW4gYW5kIHJlc2V0cyB0aGUgdXJsIG9mIHRoZSB3aW5kb3cuXFxuICAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdkZXN0cm95JyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYudHJpZ2dlciAuemYubWFnZWxsYW4nKS5maW5kKCcuJyArIHRoaXMub3B0aW9ucy5hY3RpdmVDbGFzcykucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKTtcXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmtpbmcpIHtcXG4gICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLiRhY3RpdmVbMF0uZ2V0QXR0cmlidXRlKCdocmVmJyk7XFxuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoLnJlcGxhY2UoaGFzaCwgJycpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xcbiAgICAgIH1cXG4gICAgfV0pO1xcblxcbiAgICByZXR1cm4gTWFnZWxsYW47XFxuICB9KCk7XFxuXFxuICAvKipcXG4gICAqIERlZmF1bHQgc2V0dGluZ3MgZm9yIHBsdWdpblxcbiAgICovXFxuXFxuXFxuICBNYWdlbGxhbi5kZWZhdWx0cyA9IHtcXG4gICAgLyoqXFxuICAgICAqIEFtb3VudCBvZiB0aW1lLCBpbiBtcywgdGhlIGFuaW1hdGVkIHNjcm9sbGluZyBzaG91bGQgdGFrZSBiZXR3ZWVuIGxvY2F0aW9ucy5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSA1MDBcXG4gICAgICovXFxuICAgIGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsXFxuICAgIC8qKlxcbiAgICAgKiBBbmltYXRpb24gc3R5bGUgdG8gdXNlIHdoZW4gc2Nyb2xsaW5nIGJldHdlZW4gbG9jYXRpb25zLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlICdlYXNlLWluLW91dCdcXG4gICAgICovXFxuICAgIGFuaW1hdGlvbkVhc2luZzogJ2xpbmVhcicsXFxuICAgIC8qKlxcbiAgICAgKiBOdW1iZXIgb2YgcGl4ZWxzIHRvIHVzZSBhcyBhIG1hcmtlciBmb3IgbG9jYXRpb24gY2hhbmdlcy5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSA1MFxcbiAgICAgKi9cXG4gICAgdGhyZXNob2xkOiA1MCxcXG4gICAgLyoqXFxuICAgICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGFjdGl2ZSBsb2NhdGlvbnMgbGluayBvbiB0aGUgbWFnZWxsYW4gY29udGFpbmVyLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlICdhY3RpdmUnXFxuICAgICAqL1xcbiAgICBhY3RpdmVDbGFzczogJ2FjdGl2ZScsXFxuICAgIC8qKlxcbiAgICAgKiBBbGxvd3MgdGhlIHNjcmlwdCB0byBtYW5pcHVsYXRlIHRoZSB1cmwgb2YgdGhlIGN1cnJlbnQgcGFnZSwgYW5kIGlmIHN1cHBvcnRlZCwgYWx0ZXIgdGhlIGhpc3RvcnkuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxcbiAgICAgKi9cXG4gICAgZGVlcExpbmtpbmc6IGZhbHNlLFxcbiAgICAvKipcXG4gICAgICogTnVtYmVyIG9mIHBpeGVscyB0byBvZmZzZXQgdGhlIHNjcm9sbCBvZiB0aGUgcGFnZSBvbiBpdGVtIGNsaWNrIGlmIHVzaW5nIGEgc3RpY2t5IG5hdiBiYXIuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgMjVcXG4gICAgICovXFxuICAgIGJhck9mZnNldDogMFxcbiAgfTtcXG5cXG4gIC8vIFdpbmRvdyBleHBvcnRzXFxuICBGb3VuZGF0aW9uLnBsdWdpbihNYWdlbGxhbiwgJ01hZ2VsbGFuJyk7XFxufShqUXVlcnkpO1xcbid1c2Ugc3RyaWN0JztcXG5cXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG4hZnVuY3Rpb24gKCQpIHtcXG5cXG4gIC8qKlxcbiAgICogT2ZmQ2FudmFzIG1vZHVsZS5cXG4gICAqIEBtb2R1bGUgZm91bmRhdGlvbi5vZmZjYW52YXNcXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cXG4gICAqL1xcblxcbiAgdmFyIE9mZkNhbnZhcyA9IGZ1bmN0aW9uICgpIHtcXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gb2ZmLWNhbnZhcyB3cmFwcGVyLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQGZpcmVzIE9mZkNhbnZhcyNpbml0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBpbml0aWFsaXplLlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE92ZXJyaWRlcyB0byB0aGUgZGVmYXVsdCBwbHVnaW4gc2V0dGluZ3MuXFxuICAgICAqL1xcblxcbiAgICBmdW5jdGlvbiBPZmZDYW52YXMoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBPZmZDYW52YXMpO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBPZmZDYW52YXMuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG4gICAgICB0aGlzLiRsYXN0VHJpZ2dlciA9ICQoKTtcXG4gICAgICB0aGlzLiR0cmlnZ2VycyA9ICQoKTtcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuXFxuICAgICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnT2ZmQ2FudmFzJyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSBvZmYtY2FudmFzIHdyYXBwZXIgYnkgYWRkaW5nIHRoZSBleGl0IG92ZXJsYXkgKGlmIG5lZWRlZCkuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG5cXG4gICAgX2NyZWF0ZUNsYXNzKE9mZkNhbnZhcywgW3tcXG4gICAgICBrZXk6ICdfaW5pdCcsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgICAgdmFyIGlkID0gdGhpcy4kZWxlbWVudC5hdHRyKCdpZCcpO1xcblxcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJyk7XFxuXFxuICAgICAgICAvLyBGaW5kIHRyaWdnZXJzIHRoYXQgYWZmZWN0IHRoaXMgZWxlbWVudCBhbmQgYWRkIGFyaWEtZXhwYW5kZWQgdG8gdGhlbVxcbiAgICAgICAgdGhpcy4kdHJpZ2dlcnMgPSAkKGRvY3VtZW50KS5maW5kKCdbZGF0YS1vcGVuPVxcXCInICsgaWQgKyAnXFxcIl0sIFtkYXRhLWNsb3NlPVxcXCInICsgaWQgKyAnXFxcIl0sIFtkYXRhLXRvZ2dsZT1cXFwiJyArIGlkICsgJ1xcXCJdJykuYXR0cignYXJpYS1leHBhbmRlZCcsICdmYWxzZScpLmF0dHIoJ2FyaWEtY29udHJvbHMnLCBpZCk7XFxuXFxuICAgICAgICAvLyBBZGQgYSBjbG9zZSB0cmlnZ2VyIG92ZXIgdGhlIGJvZHkgaWYgbmVjZXNzYXJ5XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljaykge1xcbiAgICAgICAgICBpZiAoJCgnLmpzLW9mZi1jYW52YXMtZXhpdCcpLmxlbmd0aCkge1xcbiAgICAgICAgICAgIHRoaXMuJGV4aXRlciA9ICQoJy5qcy1vZmYtY2FudmFzLWV4aXQnKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB2YXIgZXhpdGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuICAgICAgICAgICAgZXhpdGVyLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnanMtb2ZmLWNhbnZhcy1leGl0Jyk7XFxuICAgICAgICAgICAgJCgnW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XScpLmFwcGVuZChleGl0ZXIpO1xcblxcbiAgICAgICAgICAgIHRoaXMuJGV4aXRlciA9ICQoZXhpdGVyKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5vcHRpb25zLmlzUmV2ZWFsZWQgPSB0aGlzLm9wdGlvbnMuaXNSZXZlYWxlZCB8fCBuZXcgUmVnRXhwKHRoaXMub3B0aW9ucy5yZXZlYWxDbGFzcywgJ2cnKS50ZXN0KHRoaXMuJGVsZW1lbnRbMF0uY2xhc3NOYW1lKTtcXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaXNSZXZlYWxlZCkge1xcbiAgICAgICAgICB0aGlzLm9wdGlvbnMucmV2ZWFsT24gPSB0aGlzLm9wdGlvbnMucmV2ZWFsT24gfHwgdGhpcy4kZWxlbWVudFswXS5jbGFzc05hbWUubWF0Y2goLyhyZXZlYWwtZm9yLW1lZGl1bXxyZXZlYWwtZm9yLWxhcmdlKS9nKVswXS5zcGxpdCgnLScpWzJdO1xcbiAgICAgICAgICB0aGlzLl9zZXRNUUNoZWNrZXIoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnRyYW5zaXRpb25UaW1lKSB7XFxuICAgICAgICAgIHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZSA9IHBhcnNlRmxvYXQod2luZG93LmdldENvbXB1dGVkU3R5bGUoJCgnW2RhdGEtb2ZmLWNhbnZhcy13cmFwcGVyXScpWzBdKS50cmFuc2l0aW9uRHVyYXRpb24pICogMTAwMDtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogQWRkcyBldmVudCBoYW5kbGVycyB0byB0aGUgb2ZmLWNhbnZhcyB3cmFwcGVyIGFuZCB0aGUgZXhpdCBvdmVybGF5LlxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfZXZlbnRzJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYudHJpZ2dlciAuemYub2ZmY2FudmFzJykub24oe1xcbiAgICAgICAgICAnb3Blbi56Zi50cmlnZ2VyJzogdGhpcy5vcGVuLmJpbmQodGhpcyksXFxuICAgICAgICAgICdjbG9zZS56Zi50cmlnZ2VyJzogdGhpcy5jbG9zZS5iaW5kKHRoaXMpLFxcbiAgICAgICAgICAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLFxcbiAgICAgICAgICAna2V5ZG93bi56Zi5vZmZjYW52YXMnOiB0aGlzLl9oYW5kbGVLZXlib2FyZC5iaW5kKHRoaXMpXFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICYmIHRoaXMuJGV4aXRlci5sZW5ndGgpIHtcXG4gICAgICAgICAgdGhpcy4kZXhpdGVyLm9uKHsgJ2NsaWNrLnpmLm9mZmNhbnZhcyc6IHRoaXMuY2xvc2UuYmluZCh0aGlzKSB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogQXBwbGllcyBldmVudCBsaXN0ZW5lciBmb3IgZWxlbWVudHMgdGhhdCB3aWxsIHJldmVhbCBhdCBjZXJ0YWluIGJyZWFrcG9pbnRzLlxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfc2V0TVFDaGVja2VyJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldE1RQ2hlY2tlcigpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgICAkKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgaWYgKEZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KF90aGlzLm9wdGlvbnMucmV2ZWFsT24pKSB7XFxuICAgICAgICAgICAgX3RoaXMucmV2ZWFsKHRydWUpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIF90aGlzLnJldmVhbChmYWxzZSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pLm9uZSgnbG9hZC56Zi5vZmZjYW52YXMnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGlmIChGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdChfdGhpcy5vcHRpb25zLnJldmVhbE9uKSkge1xcbiAgICAgICAgICAgIF90aGlzLnJldmVhbCh0cnVlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEhhbmRsZXMgdGhlIHJldmVhbGluZy9oaWRpbmcgdGhlIG9mZi1jYW52YXMgYXQgYnJlYWtwb2ludHMsIG5vdCB0aGUgc2FtZSBhcyBvcGVuLlxcbiAgICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNSZXZlYWxlZCAtIHRydWUgaWYgZWxlbWVudCBzaG91bGQgYmUgcmV2ZWFsZWQuXFxuICAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdyZXZlYWwnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXZlYWwoaXNSZXZlYWxlZCkge1xcbiAgICAgICAgdmFyICRjbG9zZXIgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLWNsb3NlXScpO1xcbiAgICAgICAgaWYgKGlzUmV2ZWFsZWQpIHtcXG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xcbiAgICAgICAgICB0aGlzLmlzUmV2ZWFsZWQgPSB0cnVlO1xcbiAgICAgICAgICAvLyBpZiAoIXRoaXMub3B0aW9ucy5mb3JjZVRvcCkge1xcbiAgICAgICAgICAvLyAgIHZhciBzY3JvbGxQb3MgPSBwYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQpO1xcbiAgICAgICAgICAvLyAgIHRoaXMuJGVsZW1lbnRbMF0uc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwLCcgKyBzY3JvbGxQb3MgKyAncHgpJztcXG4gICAgICAgICAgLy8gfVxcbiAgICAgICAgICAvLyBpZiAodGhpcy5vcHRpb25zLmlzU3RpY2t5KSB7IHRoaXMuX3N0aWNrKCk7IH1cXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ29wZW4uemYudHJpZ2dlciB0b2dnbGUuemYudHJpZ2dlcicpO1xcbiAgICAgICAgICBpZiAoJGNsb3Nlci5sZW5ndGgpIHtcXG4gICAgICAgICAgICAkY2xvc2VyLmhpZGUoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy5pc1JldmVhbGVkID0gZmFsc2U7XFxuICAgICAgICAgIC8vIGlmICh0aGlzLm9wdGlvbnMuaXNTdGlja3kgfHwgIXRoaXMub3B0aW9ucy5mb3JjZVRvcCkge1xcbiAgICAgICAgICAvLyAgIHRoaXMuJGVsZW1lbnRbMF0uc3R5bGUudHJhbnNmb3JtID0gJyc7XFxuICAgICAgICAgIC8vICAgJCh3aW5kb3cpLm9mZignc2Nyb2xsLnpmLm9mZmNhbnZhcycpO1xcbiAgICAgICAgICAvLyB9XFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQub24oe1xcbiAgICAgICAgICAgICdvcGVuLnpmLnRyaWdnZXInOiB0aGlzLm9wZW4uYmluZCh0aGlzKSxcXG4gICAgICAgICAgICAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpXFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICBpZiAoJGNsb3Nlci5sZW5ndGgpIHtcXG4gICAgICAgICAgICAkY2xvc2VyLnNob3coKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBPcGVucyB0aGUgb2ZmLWNhbnZhcyBtZW51LlxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIEV2ZW50IG9iamVjdCBwYXNzZWQgZnJvbSBsaXN0ZW5lci5cXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gdHJpZ2dlciAtIGVsZW1lbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIG9mZi1jYW52YXMgdG8gb3Blbi5cXG4gICAgICAgKiBAZmlyZXMgT2ZmQ2FudmFzI29wZW5lZFxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnb3BlbicsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIG9wZW4oZXZlbnQsIHRyaWdnZXIpIHtcXG4gICAgICAgIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykgfHwgdGhpcy5pc1JldmVhbGVkKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXMsXFxuICAgICAgICAgICAgJGJvZHkgPSAkKGRvY3VtZW50LmJvZHkpO1xcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mb3JjZVRvcCkge1xcbiAgICAgICAgICAkKCdib2R5Jykuc2Nyb2xsVG9wKDApO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gd2luZG93LnBhZ2VZT2Zmc2V0ID0gMDtcXG5cXG4gICAgICAgIC8vIGlmICghdGhpcy5vcHRpb25zLmZvcmNlVG9wKSB7XFxuICAgICAgICAvLyAgIHZhciBzY3JvbGxQb3MgPSBwYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQpO1xcbiAgICAgICAgLy8gICB0aGlzLiRlbGVtZW50WzBdLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMCwnICsgc2Nyb2xsUG9zICsgJ3B4KSc7XFxuICAgICAgICAvLyAgIGlmICh0aGlzLiRleGl0ZXIubGVuZ3RoKSB7XFxuICAgICAgICAvLyAgICAgdGhpcy4kZXhpdGVyWzBdLnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoMCwnICsgc2Nyb2xsUG9zICsgJ3B4KSc7XFxuICAgICAgICAvLyAgIH1cXG4gICAgICAgIC8vIH1cXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgb2ZmLWNhbnZhcyBtZW51IG9wZW5zLlxcbiAgICAgICAgICogQGV2ZW50IE9mZkNhbnZhcyNvcGVuZWRcXG4gICAgICAgICAqL1xcbiAgICAgICAgRm91bmRhdGlvbi5Nb3ZlKHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZSwgdGhpcy4kZWxlbWVudCwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAkKCdbZGF0YS1vZmYtY2FudmFzLXdyYXBwZXJdJykuYWRkQ2xhc3MoJ2lzLW9mZi1jYW52YXMtb3BlbiBpcy1vcGVuLScgKyBfdGhpcy5vcHRpb25zLnBvc2l0aW9uKTtcXG5cXG4gICAgICAgICAgX3RoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ2lzLW9wZW4nKTtcXG5cXG4gICAgICAgICAgLy8gaWYgKF90aGlzLm9wdGlvbnMuaXNTdGlja3kpIHtcXG4gICAgICAgICAgLy8gICBfdGhpcy5fc3RpY2soKTtcXG4gICAgICAgICAgLy8gfVxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICB0aGlzLiR0cmlnZ2Vycy5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ3RydWUnKTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1oaWRkZW4nLCAnZmFsc2UnKS50cmlnZ2VyKCdvcGVuZWQuemYub2ZmY2FudmFzJyk7XFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsb3NlT25DbGljaykge1xcbiAgICAgICAgICB0aGlzLiRleGl0ZXIuYWRkQ2xhc3MoJ2lzLXZpc2libGUnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0cmlnZ2VyKSB7XFxuICAgICAgICAgIHRoaXMuJGxhc3RUcmlnZ2VyID0gdHJpZ2dlcjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b0ZvY3VzKSB7XFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZCh0aGlzLiRlbGVtZW50KSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIF90aGlzLiRlbGVtZW50LmZpbmQoJ2EsIGJ1dHRvbicpLmVxKDApLmZvY3VzKCk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50cmFwRm9jdXMpIHtcXG4gICAgICAgICAgJCgnW2RhdGEtb2ZmLWNhbnZhcy1jb250ZW50XScpLmF0dHIoJ3RhYmluZGV4JywgJy0xJyk7XFxuICAgICAgICAgIHRoaXMuX3RyYXBGb2N1cygpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBUcmFwcyBmb2N1cyB3aXRoaW4gdGhlIG9mZmNhbnZhcyBvbiBvcGVuLlxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfdHJhcEZvY3VzJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3RyYXBGb2N1cygpIHtcXG4gICAgICAgIHZhciBmb2N1c2FibGUgPSBGb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUodGhpcy4kZWxlbWVudCksXFxuICAgICAgICAgICAgZmlyc3QgPSBmb2N1c2FibGUuZXEoMCksXFxuICAgICAgICAgICAgbGFzdCA9IGZvY3VzYWJsZS5lcSgtMSk7XFxuXFxuICAgICAgICBmb2N1c2FibGUub2ZmKCcuemYub2ZmY2FudmFzJykub24oJ2tleWRvd24uemYub2ZmY2FudmFzJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgaWYgKGUud2hpY2ggPT09IDkgfHwgZS5rZXljb2RlID09PSA5KSB7XFxuICAgICAgICAgICAgaWYgKGUudGFyZ2V0ID09PSBsYXN0WzBdICYmICFlLnNoaWZ0S2V5KSB7XFxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgICBmaXJzdC5mb2N1cygpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IGZpcnN0WzBdICYmIGUuc2hpZnRLZXkpIHtcXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICAgIGxhc3QuZm9jdXMoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBBbGxvd3MgdGhlIG9mZmNhbnZhcyB0byBhcHBlYXIgc3RpY2t5IHV0aWxpemluZyB0cmFuc2xhdGUgcHJvcGVydGllcy5cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcbiAgICAgIC8vIE9mZkNhbnZhcy5wcm90b3R5cGUuX3N0aWNrID0gZnVuY3Rpb24oKSB7XFxuICAgICAgLy8gICB2YXIgZWxTdHlsZSA9IHRoaXMuJGVsZW1lbnRbMF0uc3R5bGU7XFxuICAgICAgLy9cXG4gICAgICAvLyAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7XFxuICAgICAgLy8gICAgIHZhciBleGl0U3R5bGUgPSB0aGlzLiRleGl0ZXJbMF0uc3R5bGU7XFxuICAgICAgLy8gICB9XFxuICAgICAgLy9cXG4gICAgICAvLyAgICQod2luZG93KS5vbignc2Nyb2xsLnpmLm9mZmNhbnZhcycsIGZ1bmN0aW9uKGUpIHtcXG4gICAgICAvLyAgICAgY29uc29sZS5sb2coZSk7XFxuICAgICAgLy8gICAgIHZhciBwYWdlWSA9IHdpbmRvdy5wYWdlWU9mZnNldDtcXG4gICAgICAvLyAgICAgZWxTdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlKDAsJyArIHBhZ2VZICsgJ3B4KSc7XFxuICAgICAgLy8gICAgIGlmIChleGl0U3R5bGUgIT09IHVuZGVmaW5lZCkgeyBleGl0U3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgwLCcgKyBwYWdlWSArICdweCknOyB9XFxuICAgICAgLy8gICB9KTtcXG4gICAgICAvLyAgIC8vIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignc3R1Y2suemYub2ZmY2FudmFzJyk7XFxuICAgICAgLy8gfTtcXG4gICAgICAvKipcXG4gICAgICAgKiBDbG9zZXMgdGhlIG9mZi1jYW52YXMgbWVudS5cXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIG9wdGlvbmFsIGNiIHRvIGZpcmUgYWZ0ZXIgY2xvc3VyZS5cXG4gICAgICAgKiBAZmlyZXMgT2ZmQ2FudmFzI2Nsb3NlZFxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnY2xvc2UnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBjbG9zZShjYikge1xcbiAgICAgICAgaWYgKCF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKCdpcy1vcGVuJykgfHwgdGhpcy5pc1JldmVhbGVkKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgICAvLyAgRm91bmRhdGlvbi5Nb3ZlKHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZSwgdGhpcy4kZWxlbWVudCwgZnVuY3Rpb24oKSB7XFxuICAgICAgICAkKCdbZGF0YS1vZmYtY2FudmFzLXdyYXBwZXJdJykucmVtb3ZlQ2xhc3MoJ2lzLW9mZi1jYW52YXMtb3BlbiBpcy1vcGVuLScgKyBfdGhpcy5vcHRpb25zLnBvc2l0aW9uKTtcXG4gICAgICAgIF90aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdpcy1vcGVuJyk7XFxuICAgICAgICAvLyBGb3VuZGF0aW9uLl9yZWZsb3coKTtcXG4gICAgICAgIC8vIH0pO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsICd0cnVlJylcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgb2ZmLWNhbnZhcyBtZW51IG9wZW5zLlxcbiAgICAgICAgICogQGV2ZW50IE9mZkNhbnZhcyNjbG9zZWRcXG4gICAgICAgICAqL1xcbiAgICAgICAgLnRyaWdnZXIoJ2Nsb3NlZC56Zi5vZmZjYW52YXMnKTtcXG4gICAgICAgIC8vIGlmIChfdGhpcy5vcHRpb25zLmlzU3RpY2t5IHx8ICFfdGhpcy5vcHRpb25zLmZvcmNlVG9wKSB7XFxuICAgICAgICAvLyAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XFxuICAgICAgICAvLyAgICAgX3RoaXMuJGVsZW1lbnRbMF0uc3R5bGUudHJhbnNmb3JtID0gJyc7XFxuICAgICAgICAvLyAgICAgJCh3aW5kb3cpLm9mZignc2Nyb2xsLnpmLm9mZmNhbnZhcycpO1xcbiAgICAgICAgLy8gICB9LCB0aGlzLm9wdGlvbnMudHJhbnNpdGlvblRpbWUpO1xcbiAgICAgICAgLy8gfVxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spIHtcXG4gICAgICAgICAgdGhpcy4kZXhpdGVyLnJlbW92ZUNsYXNzKCdpcy12aXNpYmxlJyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLiR0cmlnZ2Vycy5hdHRyKCdhcmlhLWV4cGFuZGVkJywgJ2ZhbHNlJyk7XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnRyYXBGb2N1cykge1xcbiAgICAgICAgICAkKCdbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdJykucmVtb3ZlQXR0cigndGFiaW5kZXgnKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogVG9nZ2xlcyB0aGUgb2ZmLWNhbnZhcyBtZW51IG9wZW4gb3IgY2xvc2VkLlxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIEV2ZW50IG9iamVjdCBwYXNzZWQgZnJvbSBsaXN0ZW5lci5cXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gdHJpZ2dlciAtIGVsZW1lbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIG9mZi1jYW52YXMgdG8gb3Blbi5cXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ3RvZ2dsZScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZShldmVudCwgdHJpZ2dlcikge1xcbiAgICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2lzLW9wZW4nKSkge1xcbiAgICAgICAgICB0aGlzLmNsb3NlKGV2ZW50LCB0cmlnZ2VyKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMub3BlbihldmVudCwgdHJpZ2dlcik7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEhhbmRsZXMga2V5Ym9hcmQgaW5wdXQgd2hlbiBkZXRlY3RlZC4gV2hlbiB0aGUgZXNjYXBlIGtleSBpcyBwcmVzc2VkLCB0aGUgb2ZmLWNhbnZhcyBtZW51IGNsb3NlcywgYW5kIGZvY3VzIGlzIHJlc3RvcmVkIHRvIHRoZSBlbGVtZW50IHRoYXQgb3BlbmVkIHRoZSBtZW51LlxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfaGFuZGxlS2V5Ym9hcmQnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlS2V5Ym9hcmQoZXZlbnQpIHtcXG4gICAgICAgIGlmIChldmVudC53aGljaCAhPT0gMjcpIHJldHVybjtcXG5cXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgIHRoaXMuY2xvc2UoKTtcXG4gICAgICAgIHRoaXMuJGxhc3RUcmlnZ2VyLmZvY3VzKCk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIERlc3Ryb3lzIHRoZSBvZmZjYW52YXMgcGx1Z2luLlxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnZGVzdHJveScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuICAgICAgICB0aGlzLmNsb3NlKCk7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnRyaWdnZXIgLnpmLm9mZmNhbnZhcycpO1xcbiAgICAgICAgdGhpcy4kZXhpdGVyLm9mZignLnpmLm9mZmNhbnZhcycpO1xcblxcbiAgICAgICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xcbiAgICAgIH1cXG4gICAgfV0pO1xcblxcbiAgICByZXR1cm4gT2ZmQ2FudmFzO1xcbiAgfSgpO1xcblxcbiAgT2ZmQ2FudmFzLmRlZmF1bHRzID0ge1xcbiAgICAvKipcXG4gICAgICogQWxsb3cgdGhlIHVzZXIgdG8gY2xpY2sgb3V0c2lkZSBvZiB0aGUgbWVudSB0byBjbG9zZSBpdC5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSB0cnVlXFxuICAgICAqL1xcbiAgICBjbG9zZU9uQ2xpY2s6IHRydWUsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBBbW91bnQgb2YgdGltZSBpbiBtcyB0aGUgb3BlbiBhbmQgY2xvc2UgdHJhbnNpdGlvbiByZXF1aXJlcy4gSWYgbm9uZSBzZWxlY3RlZCwgcHVsbHMgZnJvbSBib2R5IHN0eWxlLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIDUwMFxcbiAgICAgKi9cXG4gICAgdHJhbnNpdGlvblRpbWU6IDAsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBEaXJlY3Rpb24gdGhlIG9mZmNhbnZhcyBvcGVucyBmcm9tLiBEZXRlcm1pbmVzIGNsYXNzIGFwcGxpZWQgdG8gYm9keS5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSBsZWZ0XFxuICAgICAqL1xcbiAgICBwb3NpdGlvbjogJ2xlZnQnLFxcblxcbiAgICAvKipcXG4gICAgICogRm9yY2UgdGhlIHBhZ2UgdG8gc2Nyb2xsIHRvIHRvcCBvbiBvcGVuLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIHRydWVcXG4gICAgICovXFxuICAgIGZvcmNlVG9wOiB0cnVlLFxcblxcbiAgICAvKipcXG4gICAgICogQWxsb3cgdGhlIG9mZmNhbnZhcyB0byByZW1haW4gb3BlbiBmb3IgY2VydGFpbiBicmVha3BvaW50cy5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSBmYWxzZVxcbiAgICAgKi9cXG4gICAgaXNSZXZlYWxlZDogZmFsc2UsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBCcmVha3BvaW50IGF0IHdoaWNoIHRvIHJldmVhbC4gSlMgd2lsbCB1c2UgYSBSZWdFeHAgdG8gdGFyZ2V0IHN0YW5kYXJkIGNsYXNzZXMsIGlmIGNoYW5naW5nIGNsYXNzbmFtZXMsIHBhc3MgeW91ciBjbGFzcyB3aXRoIHRoZSBgcmV2ZWFsQ2xhc3NgIG9wdGlvbi5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSByZXZlYWwtZm9yLWxhcmdlXFxuICAgICAqL1xcbiAgICByZXZlYWxPbjogbnVsbCxcXG5cXG4gICAgLyoqXFxuICAgICAqIEZvcmNlIGZvY3VzIHRvIHRoZSBvZmZjYW52YXMgb24gb3Blbi4gSWYgdHJ1ZSwgd2lsbCBmb2N1cyB0aGUgb3BlbmluZyB0cmlnZ2VyIG9uIGNsb3NlLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIHRydWVcXG4gICAgICovXFxuICAgIGF1dG9Gb2N1czogdHJ1ZSxcXG5cXG4gICAgLyoqXFxuICAgICAqIENsYXNzIHVzZWQgdG8gZm9yY2UgYW4gb2ZmY2FudmFzIHRvIHJlbWFpbiBvcGVuLiBGb3VuZGF0aW9uIGRlZmF1bHRzIGZvciB0aGlzIGFyZSBgcmV2ZWFsLWZvci1sYXJnZWAgJiBgcmV2ZWFsLWZvci1tZWRpdW1gLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIFRPRE8gaW1wcm92ZSB0aGUgcmVnZXggdGVzdGluZyBmb3IgdGhpcy5cXG4gICAgICogQGV4YW1wbGUgcmV2ZWFsLWZvci1sYXJnZVxcbiAgICAgKi9cXG4gICAgcmV2ZWFsQ2xhc3M6ICdyZXZlYWwtZm9yLScsXFxuXFxuICAgIC8qKlxcbiAgICAgKiBUcmlnZ2VycyBvcHRpb25hbCBmb2N1cyB0cmFwcGluZyB3aGVuIG9wZW5pbmcgYW4gb2ZmY2FudmFzLiBTZXRzIHRhYmluZGV4IG9mIFtkYXRhLW9mZi1jYW52YXMtY29udGVudF0gdG8gLTEgZm9yIGFjY2Vzc2liaWxpdHkgcHVycG9zZXMuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxcbiAgICAgKi9cXG4gICAgdHJhcEZvY3VzOiBmYWxzZVxcbiAgfTtcXG5cXG4gIC8vIFdpbmRvdyBleHBvcnRzXFxuICBGb3VuZGF0aW9uLnBsdWdpbihPZmZDYW52YXMsICdPZmZDYW52YXMnKTtcXG59KGpRdWVyeSk7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbiFmdW5jdGlvbiAoJCkge1xcblxcbiAgLyoqXFxuICAgKiBPcmJpdCBtb2R1bGUuXFxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24ub3JiaXRcXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwua2V5Ym9hcmRcXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubW90aW9uXFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLnRpbWVyQW5kSW1hZ2VMb2FkZXJcXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudG91Y2hcXG4gICAqL1xcblxcbiAgdmFyIE9yYml0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAvKipcXG4gICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIG9yYml0IGNhcm91c2VsLlxcbiAgICAqIEBjbGFzc1xcbiAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gYW4gT3JiaXQgQ2Fyb3VzZWwuXFxuICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAqL1xcblxcbiAgICBmdW5jdGlvbiBPcmJpdChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIE9yYml0KTtcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgT3JiaXQuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuXFxuICAgICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnT3JiaXQnKTtcXG4gICAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdPcmJpdCcsIHtcXG4gICAgICAgICdsdHInOiB7XFxuICAgICAgICAgICdBUlJPV19SSUdIVCc6ICduZXh0JyxcXG4gICAgICAgICAgJ0FSUk9XX0xFRlQnOiAncHJldmlvdXMnXFxuICAgICAgICB9LFxcbiAgICAgICAgJ3J0bCc6IHtcXG4gICAgICAgICAgJ0FSUk9XX0xFRlQnOiAnbmV4dCcsXFxuICAgICAgICAgICdBUlJPV19SSUdIVCc6ICdwcmV2aW91cydcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgKiBJbml0aWFsaXplcyB0aGUgcGx1Z2luIGJ5IGNyZWF0aW5nIGpRdWVyeSBjb2xsZWN0aW9ucywgc2V0dGluZyBhdHRyaWJ1dGVzLCBhbmQgc3RhcnRpbmcgdGhlIGFuaW1hdGlvbi5cXG4gICAgKiBAZnVuY3Rpb25cXG4gICAgKiBAcHJpdmF0ZVxcbiAgICAqL1xcblxcblxcbiAgICBfY3JlYXRlQ2xhc3MoT3JiaXQsIFt7XFxuICAgICAga2V5OiAnX2luaXQnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICAgIHRoaXMuJHdyYXBwZXIgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy4nICsgdGhpcy5vcHRpb25zLmNvbnRhaW5lckNsYXNzKTtcXG4gICAgICAgIHRoaXMuJHNsaWRlcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLicgKyB0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcyk7XFxuICAgICAgICB2YXIgJGltYWdlcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW1nJyksXFxuICAgICAgICAgICAgaW5pdEFjdGl2ZSA9IHRoaXMuJHNsaWRlcy5maWx0ZXIoJy5pcy1hY3RpdmUnKTtcXG5cXG4gICAgICAgIGlmICghaW5pdEFjdGl2ZS5sZW5ndGgpIHtcXG4gICAgICAgICAgdGhpcy4kc2xpZGVzLmVxKDApLmFkZENsYXNzKCdpcy1hY3RpdmUnKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLnVzZU1VSSkge1xcbiAgICAgICAgICB0aGlzLiRzbGlkZXMuYWRkQ2xhc3MoJ25vLW1vdGlvbnVpJyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoJGltYWdlcy5sZW5ndGgpIHtcXG4gICAgICAgICAgRm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZCgkaW1hZ2VzLCB0aGlzLl9wcmVwYXJlRm9yT3JiaXQuYmluZCh0aGlzKSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aGlzLl9wcmVwYXJlRm9yT3JiaXQoKTsgLy9oZWhlXFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmJ1bGxldHMpIHtcXG4gICAgICAgICAgdGhpcy5fbG9hZEJ1bGxldHMoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX2V2ZW50cygpO1xcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUGxheSAmJiB0aGlzLiRzbGlkZXMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgICB0aGlzLmdlb1N5bmMoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYWNjZXNzaWJsZSkge1xcbiAgICAgICAgICAvLyBhbGxvdyB3cmFwcGVyIHRvIGJlIGZvY3VzYWJsZSB0byBlbmFibGUgYXJyb3cgbmF2aWdhdGlvblxcbiAgICAgICAgICB0aGlzLiR3cmFwcGVyLmF0dHIoJ3RhYmluZGV4JywgMCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICogQ3JlYXRlcyBhIGpRdWVyeSBjb2xsZWN0aW9uIG9mIGJ1bGxldHMsIGlmIHRoZXkgYXJlIGJlaW5nIHVzZWQuXFxuICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAqIEBwcml2YXRlXFxuICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ19sb2FkQnVsbGV0cycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9sb2FkQnVsbGV0cygpIHtcXG4gICAgICAgIHRoaXMuJGJ1bGxldHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy4nICsgdGhpcy5vcHRpb25zLmJveE9mQnVsbGV0cykuZmluZCgnYnV0dG9uJyk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICogU2V0cyBhIGB0aW1lcmAgb2JqZWN0IG9uIHRoZSBvcmJpdCwgYW5kIHN0YXJ0cyB0aGUgY291bnRlciBmb3IgdGhlIG5leHQgc2xpZGUuXFxuICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnZ2VvU3luYycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGdlb1N5bmMoKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgdGhpcy50aW1lciA9IG5ldyBGb3VuZGF0aW9uLlRpbWVyKHRoaXMuJGVsZW1lbnQsIHtcXG4gICAgICAgICAgZHVyYXRpb246IHRoaXMub3B0aW9ucy50aW1lckRlbGF5LFxcbiAgICAgICAgICBpbmZpbml0ZTogZmFsc2VcXG4gICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUodHJ1ZSk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIHRoaXMudGltZXIuc3RhcnQoKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgKiBTZXRzIHdyYXBwZXIgYW5kIHNsaWRlIGhlaWdodHMgZm9yIHRoZSBvcmJpdC5cXG4gICAgICAqIEBmdW5jdGlvblxcbiAgICAgICogQHByaXZhdGVcXG4gICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX3ByZXBhcmVGb3JPcmJpdCcsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9wcmVwYXJlRm9yT3JiaXQoKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgdGhpcy5fc2V0V3JhcHBlckhlaWdodChmdW5jdGlvbiAobWF4KSB7XFxuICAgICAgICAgIF90aGlzLl9zZXRTbGlkZUhlaWdodChtYXgpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICogQ2FsdWxhdGVzIHRoZSBoZWlnaHQgb2YgZWFjaCBzbGlkZSBpbiB0aGUgY29sbGVjdGlvbiwgYW5kIHVzZXMgdGhlIHRhbGxlc3Qgb25lIGZvciB0aGUgd3JhcHBlciBoZWlnaHQuXFxuICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAqIEBwcml2YXRlXFxuICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gZmlyZSB3aGVuIGNvbXBsZXRlLlxcbiAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfc2V0V3JhcHBlckhlaWdodCcsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRXcmFwcGVySGVpZ2h0KGNiKSB7XFxuICAgICAgICAvL3Jld3JpdGUgdGhpcyB0byBgZm9yYCBsb29wXFxuICAgICAgICB2YXIgbWF4ID0gMCxcXG4gICAgICAgICAgICB0ZW1wLFxcbiAgICAgICAgICAgIGNvdW50ZXIgPSAwO1xcblxcbiAgICAgICAgdGhpcy4kc2xpZGVzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB0ZW1wID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XFxuICAgICAgICAgICQodGhpcykuYXR0cignZGF0YS1zbGlkZScsIGNvdW50ZXIpO1xcblxcbiAgICAgICAgICBpZiAoY291bnRlcikge1xcbiAgICAgICAgICAgIC8vaWYgbm90IHRoZSBmaXJzdCBzbGlkZSwgc2V0IGNzcyBwb3NpdGlvbiBhbmQgZGlzcGxheSBwcm9wZXJ0eVxcbiAgICAgICAgICAgICQodGhpcykuY3NzKHsgJ3Bvc2l0aW9uJzogJ3JlbGF0aXZlJywgJ2Rpc3BsYXknOiAnbm9uZScgfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgbWF4ID0gdGVtcCA+IG1heCA/IHRlbXAgOiBtYXg7XFxuICAgICAgICAgIGNvdW50ZXIrKztcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgaWYgKGNvdW50ZXIgPT09IHRoaXMuJHNsaWRlcy5sZW5ndGgpIHtcXG4gICAgICAgICAgdGhpcy4kd3JhcHBlci5jc3MoeyAnaGVpZ2h0JzogbWF4IH0pOyAvL29ubHkgY2hhbmdlIHRoZSB3cmFwcGVyIGhlaWdodCBwcm9wZXJ0eSBvbmNlLlxcbiAgICAgICAgICBjYihtYXgpOyAvL2ZpcmUgY2FsbGJhY2sgd2l0aCBtYXggaGVpZ2h0IGRpbWVuc2lvbi5cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgKiBTZXRzIHRoZSBtYXgtaGVpZ2h0IG9mIGVhY2ggc2xpZGUuXFxuICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAqIEBwcml2YXRlXFxuICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ19zZXRTbGlkZUhlaWdodCcsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRTbGlkZUhlaWdodChoZWlnaHQpIHtcXG4gICAgICAgIHRoaXMuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgJCh0aGlzKS5jc3MoJ21heC1oZWlnaHQnLCBoZWlnaHQpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICogQWRkcyBldmVudCBsaXN0ZW5lcnMgdG8gYmFzaWNhbGx5IGV2ZXJ5dGhpbmcgd2l0aGluIHRoZSBlbGVtZW50LlxcbiAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfZXZlbnRzJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbiAgICAgICAgLy8qKk5vdyB1c2luZyBjdXN0b20gZXZlbnQgLSB0aGFua3MgdG86KipcXG4gICAgICAgIC8vKiogICAgICBZb2hhaSBBcmFyYXQgb2YgVG9yb250byAgICAgICoqXFxuICAgICAgICAvLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxcbiAgICAgICAgaWYgKHRoaXMuJHNsaWRlcy5sZW5ndGggPiAxKSB7XFxuXFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc3dpcGUpIHtcXG4gICAgICAgICAgICB0aGlzLiRzbGlkZXMub2ZmKCdzd2lwZWxlZnQuemYub3JiaXQgc3dpcGVyaWdodC56Zi5vcmJpdCcpLm9uKCdzd2lwZWxlZnQuemYub3JiaXQnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUodHJ1ZSk7XFxuICAgICAgICAgICAgfSkub24oJ3N3aXBlcmlnaHQuemYub3JiaXQnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUoZmFsc2UpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIC8vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXFxuXFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYXV0b1BsYXkpIHtcXG4gICAgICAgICAgICB0aGlzLiRzbGlkZXMub24oJ2NsaWNrLnpmLm9yYml0JywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgX3RoaXMuJGVsZW1lbnQuZGF0YSgnY2xpY2tlZE9uJywgX3RoaXMuJGVsZW1lbnQuZGF0YSgnY2xpY2tlZE9uJykgPyBmYWxzZSA6IHRydWUpO1xcbiAgICAgICAgICAgICAgX3RoaXMudGltZXJbX3RoaXMuJGVsZW1lbnQuZGF0YSgnY2xpY2tlZE9uJykgPyAncGF1c2UnIDogJ3N0YXJ0J10oKTtcXG4gICAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnBhdXNlT25Ib3Zlcikge1xcbiAgICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5vbignbW91c2VlbnRlci56Zi5vcmJpdCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgX3RoaXMudGltZXIucGF1c2UoKTtcXG4gICAgICAgICAgICAgIH0pLm9uKCdtb3VzZWxlYXZlLnpmLm9yYml0JywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLiRlbGVtZW50LmRhdGEoJ2NsaWNrZWRPbicpKSB7XFxuICAgICAgICAgICAgICAgICAgX3RoaXMudGltZXIuc3RhcnQoKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubmF2QnV0dG9ucykge1xcbiAgICAgICAgICAgIHZhciAkY29udHJvbHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy4nICsgdGhpcy5vcHRpb25zLm5leHRDbGFzcyArICcsIC4nICsgdGhpcy5vcHRpb25zLnByZXZDbGFzcyk7XFxuICAgICAgICAgICAgJGNvbnRyb2xzLmF0dHIoJ3RhYmluZGV4JywgMClcXG4gICAgICAgICAgICAvL2Fsc28gbmVlZCB0byBoYW5kbGUgZW50ZXIvcmV0dXJuIGFuZCBzcGFjZWJhciBrZXkgcHJlc3Nlc1xcbiAgICAgICAgICAgIC5vbignY2xpY2suemYub3JiaXQgdG91Y2hlbmQuemYub3JiaXQnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUoJCh0aGlzKS5oYXNDbGFzcyhfdGhpcy5vcHRpb25zLm5leHRDbGFzcykpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYnVsbGV0cykge1xcbiAgICAgICAgICAgIHRoaXMuJGJ1bGxldHMub24oJ2NsaWNrLnpmLm9yYml0IHRvdWNoZW5kLnpmLm9yYml0JywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgaWYgKC9pcy1hY3RpdmUvZy50ZXN0KHRoaXMuY2xhc3NOYW1lKSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgICAgICB9IC8vaWYgdGhpcyBpcyBhY3RpdmUsIGtpY2sgb3V0IG9mIGZ1bmN0aW9uLlxcbiAgICAgICAgICAgICAgdmFyIGlkeCA9ICQodGhpcykuZGF0YSgnc2xpZGUnKSxcXG4gICAgICAgICAgICAgICAgICBsdHIgPSBpZHggPiBfdGhpcy4kc2xpZGVzLmZpbHRlcignLmlzLWFjdGl2ZScpLmRhdGEoJ3NsaWRlJyksXFxuICAgICAgICAgICAgICAgICAgJHNsaWRlID0gX3RoaXMuJHNsaWRlcy5lcShpZHgpO1xcblxcbiAgICAgICAgICAgICAgX3RoaXMuY2hhbmdlU2xpZGUobHRyLCAkc2xpZGUsIGlkeCk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgdGhpcy4kd3JhcHBlci5hZGQodGhpcy4kYnVsbGV0cykub24oJ2tleWRvd24uemYub3JiaXQnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIC8vIGhhbmRsZSBrZXlib2FyZCBldmVudCB3aXRoIGtleWJvYXJkIHV0aWxcXG4gICAgICAgICAgICBGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLCAnT3JiaXQnLCB7XFxuICAgICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLmNoYW5nZVNsaWRlKHRydWUpO1xcbiAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgIHByZXZpb3VzOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLmNoYW5nZVNsaWRlKGZhbHNlKTtcXG4gICAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICBoYW5kbGVkOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIC8vIGlmIGJ1bGxldCBpcyBmb2N1c2VkLCBtYWtlIHN1cmUgZm9jdXMgbW92ZXNcXG4gICAgICAgICAgICAgICAgaWYgKCQoZS50YXJnZXQpLmlzKF90aGlzLiRidWxsZXRzKSkge1xcbiAgICAgICAgICAgICAgICAgIF90aGlzLiRidWxsZXRzLmZpbHRlcignLmlzLWFjdGl2ZScpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICogQ2hhbmdlcyB0aGUgY3VycmVudCBzbGlkZSB0byBhIG5ldyBvbmUuXFxuICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gaXNMVFIgLSBmbGFnIGlmIHRoZSBzbGlkZSBzaG91bGQgbW92ZSBsZWZ0IHRvIHJpZ2h0LlxcbiAgICAgICogQHBhcmFtIHtqUXVlcnl9IGNob3NlblNsaWRlIC0gdGhlIGpRdWVyeSBlbGVtZW50IG9mIHRoZSBzbGlkZSB0byBzaG93IG5leHQsIGlmIG9uZSBpcyBzZWxlY3RlZC5cXG4gICAgICAqIEBwYXJhbSB7TnVtYmVyfSBpZHggLSB0aGUgaW5kZXggb2YgdGhlIG5ldyBzbGlkZSBpbiBpdHMgY29sbGVjdGlvbiwgaWYgb25lIGNob3Nlbi5cXG4gICAgICAqIEBmaXJlcyBPcmJpdCNzbGlkZWNoYW5nZVxcbiAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdjaGFuZ2VTbGlkZScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNoYW5nZVNsaWRlKGlzTFRSLCBjaG9zZW5TbGlkZSwgaWR4KSB7XFxuICAgICAgICB2YXIgJGN1clNsaWRlID0gdGhpcy4kc2xpZGVzLmZpbHRlcignLmlzLWFjdGl2ZScpLmVxKDApO1xcblxcbiAgICAgICAgaWYgKC9tdWkvZy50ZXN0KCRjdXJTbGlkZVswXS5jbGFzc05hbWUpKSB7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH0gLy9pZiB0aGUgc2xpZGUgaXMgY3VycmVudGx5IGFuaW1hdGluZywga2ljayBvdXQgb2YgdGhlIGZ1bmN0aW9uXFxuXFxuICAgICAgICB2YXIgJGZpcnN0U2xpZGUgPSB0aGlzLiRzbGlkZXMuZmlyc3QoKSxcXG4gICAgICAgICAgICAkbGFzdFNsaWRlID0gdGhpcy4kc2xpZGVzLmxhc3QoKSxcXG4gICAgICAgICAgICBkaXJJbiA9IGlzTFRSID8gJ1JpZ2h0JyA6ICdMZWZ0JyxcXG4gICAgICAgICAgICBkaXJPdXQgPSBpc0xUUiA/ICdMZWZ0JyA6ICdSaWdodCcsXFxuICAgICAgICAgICAgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICAgICRuZXdTbGlkZTtcXG5cXG4gICAgICAgIGlmICghY2hvc2VuU2xpZGUpIHtcXG4gICAgICAgICAgLy9tb3N0IG9mIHRoZSB0aW1lLCB0aGlzIHdpbGwgYmUgYXV0byBwbGF5ZWQgb3IgY2xpY2tlZCBmcm9tIHRoZSBuYXZCdXR0b25zLlxcbiAgICAgICAgICAkbmV3U2xpZGUgPSBpc0xUUiA/IC8vaWYgd3JhcHBpbmcgZW5hYmxlZCwgY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGlzIGEgYG5leHRgIG9yIGBwcmV2YCBzaWJsaW5nLCBpZiBub3QsIHNlbGVjdCB0aGUgZmlyc3Qgb3IgbGFzdCBzbGlkZSB0byBmaWxsIGluLiBpZiB3cmFwcGluZyBub3QgZW5hYmxlZCwgYXR0ZW1wdCB0byBzZWxlY3QgYG5leHRgIG9yIGBwcmV2YCwgaWYgdGhlcmUncyBub3RoaW5nIHRoZXJlLCB0aGUgZnVuY3Rpb24gd2lsbCBraWNrIG91dCBvbiBuZXh0IHN0ZXAuIENSQVpZIE5FU1RFRCBURVJOQVJJRVMhISEhIVxcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuaW5maW5pdGVXcmFwID8gJGN1clNsaWRlLm5leHQoJy4nICsgdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpLmxlbmd0aCA/ICRjdXJTbGlkZS5uZXh0KCcuJyArIHRoaXMub3B0aW9ucy5zbGlkZUNsYXNzKSA6ICRmaXJzdFNsaWRlIDogJGN1clNsaWRlLm5leHQoJy4nICsgdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpIDogLy9waWNrIG5leHQgc2xpZGUgaWYgbW92aW5nIGxlZnQgdG8gcmlnaHRcXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmluZmluaXRlV3JhcCA/ICRjdXJTbGlkZS5wcmV2KCcuJyArIHRoaXMub3B0aW9ucy5zbGlkZUNsYXNzKS5sZW5ndGggPyAkY3VyU2xpZGUucHJldignLicgKyB0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykgOiAkbGFzdFNsaWRlIDogJGN1clNsaWRlLnByZXYoJy4nICsgdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpOyAvL3BpY2sgcHJldiBzbGlkZSBpZiBtb3ZpbmcgcmlnaHQgdG8gbGVmdFxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAkbmV3U2xpZGUgPSBjaG9zZW5TbGlkZTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCRuZXdTbGlkZS5sZW5ndGgpIHtcXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5idWxsZXRzKSB7XFxuICAgICAgICAgICAgaWR4ID0gaWR4IHx8IHRoaXMuJHNsaWRlcy5pbmRleCgkbmV3U2xpZGUpOyAvL2dyYWIgaW5kZXggdG8gdXBkYXRlIGJ1bGxldHNcXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVCdWxsZXRzKGlkeCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51c2VNVUkpIHtcXG4gICAgICAgICAgICBGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlSW4oJG5ld1NsaWRlLmFkZENsYXNzKCdpcy1hY3RpdmUnKS5jc3MoeyAncG9zaXRpb24nOiAnYWJzb2x1dGUnLCAndG9wJzogMCB9KSwgdGhpcy5vcHRpb25zWydhbmltSW5Gcm9tJyArIGRpckluXSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgJG5ld1NsaWRlLmNzcyh7ICdwb3NpdGlvbic6ICdyZWxhdGl2ZScsICdkaXNwbGF5JzogJ2Jsb2NrJyB9KS5hdHRyKCdhcmlhLWxpdmUnLCAncG9saXRlJyk7XFxuICAgICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICAgRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dCgkY3VyU2xpZGUucmVtb3ZlQ2xhc3MoJ2lzLWFjdGl2ZScpLCB0aGlzLm9wdGlvbnNbJ2FuaW1PdXRUbycgKyBkaXJPdXRdLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAkY3VyU2xpZGUucmVtb3ZlQXR0cignYXJpYS1saXZlJyk7XFxuICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5hdXRvUGxheSAmJiAhX3RoaXMudGltZXIuaXNQYXVzZWQpIHtcXG4gICAgICAgICAgICAgICAgX3RoaXMudGltZXIucmVzdGFydCgpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgLy9kbyBzdHVmZj9cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgICRjdXJTbGlkZS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlIGlzLWluJykucmVtb3ZlQXR0cignYXJpYS1saXZlJykuaGlkZSgpO1xcbiAgICAgICAgICAgICAgJG5ld1NsaWRlLmFkZENsYXNzKCdpcy1hY3RpdmUgaXMtaW4nKS5hdHRyKCdhcmlhLWxpdmUnLCAncG9saXRlJykuc2hvdygpO1xcbiAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5hdXRvUGxheSAmJiAhdGhpcy50aW1lci5pc1BhdXNlZCkge1xcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVyLnJlc3RhcnQoKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIC8qKlxcbiAgICAgICAgICAqIFRyaWdnZXJzIHdoZW4gdGhlIHNsaWRlIGhhcyBmaW5pc2hlZCBhbmltYXRpbmcgaW4uXFxuICAgICAgICAgICogQGV2ZW50IE9yYml0I3NsaWRlY2hhbmdlXFxuICAgICAgICAgICovXFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignc2xpZGVjaGFuZ2UuemYub3JiaXQnLCBbJG5ld1NsaWRlXSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICogVXBkYXRlcyB0aGUgYWN0aXZlIHN0YXRlIG9mIHRoZSBidWxsZXRzLCBpZiBkaXNwbGF5ZWQuXFxuICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAqIEBwcml2YXRlXFxuICAgICAgKiBAcGFyYW0ge051bWJlcn0gaWR4IC0gdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IHNsaWRlLlxcbiAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfdXBkYXRlQnVsbGV0cycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGVCdWxsZXRzKGlkeCkge1xcbiAgICAgICAgdmFyICRvbGRCdWxsZXQgPSB0aGlzLiRlbGVtZW50LmZpbmQoJy4nICsgdGhpcy5vcHRpb25zLmJveE9mQnVsbGV0cykuZmluZCgnLmlzLWFjdGl2ZScpLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKS5ibHVyKCksXFxuICAgICAgICAgICAgc3BhbiA9ICRvbGRCdWxsZXQuZmluZCgnc3BhbjpsYXN0JykuZGV0YWNoKCksXFxuICAgICAgICAgICAgJG5ld0J1bGxldCA9IHRoaXMuJGJ1bGxldHMuZXEoaWR4KS5hZGRDbGFzcygnaXMtYWN0aXZlJykuYXBwZW5kKHNwYW4pO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAqIERlc3Ryb3lzIHRoZSBjYXJvdXNlbCBhbmQgaGlkZXMgdGhlIGVsZW1lbnQuXFxuICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnZGVzdHJveScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLm9yYml0JykuZmluZCgnKicpLm9mZignLnpmLm9yYml0JykuZW5kKCkuaGlkZSgpO1xcbiAgICAgICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xcbiAgICAgIH1cXG4gICAgfV0pO1xcblxcbiAgICByZXR1cm4gT3JiaXQ7XFxuICB9KCk7XFxuXFxuICBPcmJpdC5kZWZhdWx0cyA9IHtcXG4gICAgLyoqXFxuICAgICogVGVsbHMgdGhlIEpTIHRvIGxvb2sgZm9yIGFuZCBsb2FkQnVsbGV0cy5cXG4gICAgKiBAb3B0aW9uXFxuICAgICogQGV4YW1wbGUgdHJ1ZVxcbiAgICAqL1xcbiAgICBidWxsZXRzOiB0cnVlLFxcbiAgICAvKipcXG4gICAgKiBUZWxscyB0aGUgSlMgdG8gYXBwbHkgZXZlbnQgbGlzdGVuZXJzIHRvIG5hdiBidXR0b25zXFxuICAgICogQG9wdGlvblxcbiAgICAqIEBleGFtcGxlIHRydWVcXG4gICAgKi9cXG4gICAgbmF2QnV0dG9uczogdHJ1ZSxcXG4gICAgLyoqXFxuICAgICogbW90aW9uLXVpIGFuaW1hdGlvbiBjbGFzcyB0byBhcHBseVxcbiAgICAqIEBvcHRpb25cXG4gICAgKiBAZXhhbXBsZSAnc2xpZGUtaW4tcmlnaHQnXFxuICAgICovXFxuICAgIGFuaW1JbkZyb21SaWdodDogJ3NsaWRlLWluLXJpZ2h0JyxcXG4gICAgLyoqXFxuICAgICogbW90aW9uLXVpIGFuaW1hdGlvbiBjbGFzcyB0byBhcHBseVxcbiAgICAqIEBvcHRpb25cXG4gICAgKiBAZXhhbXBsZSAnc2xpZGUtb3V0LXJpZ2h0J1xcbiAgICAqL1xcbiAgICBhbmltT3V0VG9SaWdodDogJ3NsaWRlLW91dC1yaWdodCcsXFxuICAgIC8qKlxcbiAgICAqIG1vdGlvbi11aSBhbmltYXRpb24gY2xhc3MgdG8gYXBwbHlcXG4gICAgKiBAb3B0aW9uXFxuICAgICogQGV4YW1wbGUgJ3NsaWRlLWluLWxlZnQnXFxuICAgICpcXG4gICAgKi9cXG4gICAgYW5pbUluRnJvbUxlZnQ6ICdzbGlkZS1pbi1sZWZ0JyxcXG4gICAgLyoqXFxuICAgICogbW90aW9uLXVpIGFuaW1hdGlvbiBjbGFzcyB0byBhcHBseVxcbiAgICAqIEBvcHRpb25cXG4gICAgKiBAZXhhbXBsZSAnc2xpZGUtb3V0LWxlZnQnXFxuICAgICovXFxuICAgIGFuaW1PdXRUb0xlZnQ6ICdzbGlkZS1vdXQtbGVmdCcsXFxuICAgIC8qKlxcbiAgICAqIEFsbG93cyBPcmJpdCB0byBhdXRvbWF0aWNhbGx5IGFuaW1hdGUgb24gcGFnZSBsb2FkLlxcbiAgICAqIEBvcHRpb25cXG4gICAgKiBAZXhhbXBsZSB0cnVlXFxuICAgICovXFxuICAgIGF1dG9QbGF5OiB0cnVlLFxcbiAgICAvKipcXG4gICAgKiBBbW91bnQgb2YgdGltZSwgaW4gbXMsIGJldHdlZW4gc2xpZGUgdHJhbnNpdGlvbnNcXG4gICAgKiBAb3B0aW9uXFxuICAgICogQGV4YW1wbGUgNTAwMFxcbiAgICAqL1xcbiAgICB0aW1lckRlbGF5OiA1MDAwLFxcbiAgICAvKipcXG4gICAgKiBBbGxvd3MgT3JiaXQgdG8gaW5maW5pdGVseSBsb29wIHRocm91Z2ggdGhlIHNsaWRlc1xcbiAgICAqIEBvcHRpb25cXG4gICAgKiBAZXhhbXBsZSB0cnVlXFxuICAgICovXFxuICAgIGluZmluaXRlV3JhcDogdHJ1ZSxcXG4gICAgLyoqXFxuICAgICogQWxsb3dzIHRoZSBPcmJpdCBzbGlkZXMgdG8gYmluZCB0byBzd2lwZSBldmVudHMgZm9yIG1vYmlsZSwgcmVxdWlyZXMgYW4gYWRkaXRpb25hbCB1dGlsIGxpYnJhcnlcXG4gICAgKiBAb3B0aW9uXFxuICAgICogQGV4YW1wbGUgdHJ1ZVxcbiAgICAqL1xcbiAgICBzd2lwZTogdHJ1ZSxcXG4gICAgLyoqXFxuICAgICogQWxsb3dzIHRoZSB0aW1pbmcgZnVuY3Rpb24gdG8gcGF1c2UgYW5pbWF0aW9uIG9uIGhvdmVyLlxcbiAgICAqIEBvcHRpb25cXG4gICAgKiBAZXhhbXBsZSB0cnVlXFxuICAgICovXFxuICAgIHBhdXNlT25Ib3ZlcjogdHJ1ZSxcXG4gICAgLyoqXFxuICAgICogQWxsb3dzIE9yYml0IHRvIGJpbmQga2V5Ym9hcmQgZXZlbnRzIHRvIHRoZSBzbGlkZXIsIHRvIGFuaW1hdGUgZnJhbWVzIHdpdGggYXJyb3cga2V5c1xcbiAgICAqIEBvcHRpb25cXG4gICAgKiBAZXhhbXBsZSB0cnVlXFxuICAgICovXFxuICAgIGFjY2Vzc2libGU6IHRydWUsXFxuICAgIC8qKlxcbiAgICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGNvbnRhaW5lciBvZiBPcmJpdFxcbiAgICAqIEBvcHRpb25cXG4gICAgKiBAZXhhbXBsZSAnb3JiaXQtY29udGFpbmVyJ1xcbiAgICAqL1xcbiAgICBjb250YWluZXJDbGFzczogJ29yYml0LWNvbnRhaW5lcicsXFxuICAgIC8qKlxcbiAgICAqIENsYXNzIGFwcGxpZWQgdG8gaW5kaXZpZHVhbCBzbGlkZXMuXFxuICAgICogQG9wdGlvblxcbiAgICAqIEBleGFtcGxlICdvcmJpdC1zbGlkZSdcXG4gICAgKi9cXG4gICAgc2xpZGVDbGFzczogJ29yYml0LXNsaWRlJyxcXG4gICAgLyoqXFxuICAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgYnVsbGV0IGNvbnRhaW5lci4gWW91J3JlIHdlbGNvbWUuXFxuICAgICogQG9wdGlvblxcbiAgICAqIEBleGFtcGxlICdvcmJpdC1idWxsZXRzJ1xcbiAgICAqL1xcbiAgICBib3hPZkJ1bGxldHM6ICdvcmJpdC1idWxsZXRzJyxcXG4gICAgLyoqXFxuICAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgYG5leHRgIG5hdmlnYXRpb24gYnV0dG9uLlxcbiAgICAqIEBvcHRpb25cXG4gICAgKiBAZXhhbXBsZSAnb3JiaXQtbmV4dCdcXG4gICAgKi9cXG4gICAgbmV4dENsYXNzOiAnb3JiaXQtbmV4dCcsXFxuICAgIC8qKlxcbiAgICAqIENsYXNzIGFwcGxpZWQgdG8gdGhlIGBwcmV2aW91c2AgbmF2aWdhdGlvbiBidXR0b24uXFxuICAgICogQG9wdGlvblxcbiAgICAqIEBleGFtcGxlICdvcmJpdC1wcmV2aW91cydcXG4gICAgKi9cXG4gICAgcHJldkNsYXNzOiAnb3JiaXQtcHJldmlvdXMnLFxcbiAgICAvKipcXG4gICAgKiBCb29sZWFuIHRvIGZsYWcgdGhlIGpzIHRvIHVzZSBtb3Rpb24gdWkgY2xhc3NlcyBvciBub3QuIERlZmF1bHQgdG8gdHJ1ZSBmb3IgYmFja3dhcmRzIGNvbXBhdGFiaWxpdHkuXFxuICAgICogQG9wdGlvblxcbiAgICAqIEBleGFtcGxlIHRydWVcXG4gICAgKi9cXG4gICAgdXNlTVVJOiB0cnVlXFxuICB9O1xcblxcbiAgLy8gV2luZG93IGV4cG9ydHNcXG4gIEZvdW5kYXRpb24ucGx1Z2luKE9yYml0LCAnT3JiaXQnKTtcXG59KGpRdWVyeSk7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbiFmdW5jdGlvbiAoJCkge1xcblxcbiAgLyoqXFxuICAgKiBSZXNwb25zaXZlTWVudSBtb2R1bGUuXFxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24ucmVzcG9uc2l2ZU1lbnVcXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwubWVkaWFRdWVyeVxcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5hY2NvcmRpb25NZW51XFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmRyaWxsZG93blxcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5kcm9wZG93bi1tZW51XFxuICAgKi9cXG5cXG4gIHZhciBSZXNwb25zaXZlTWVudSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgLyoqXFxuICAgICAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYSByZXNwb25zaXZlIG1lbnUuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAZmlyZXMgUmVzcG9uc2l2ZU1lbnUjaW5pdFxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gbWFrZSBpbnRvIGEgZHJvcGRvd24gbWVudS5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG5cXG4gICAgZnVuY3Rpb24gUmVzcG9uc2l2ZU1lbnUoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBSZXNwb25zaXZlTWVudSk7XFxuXFxuICAgICAgdGhpcy4kZWxlbWVudCA9ICQoZWxlbWVudCk7XFxuICAgICAgdGhpcy5ydWxlcyA9IHRoaXMuJGVsZW1lbnQuZGF0YSgncmVzcG9uc2l2ZS1tZW51Jyk7XFxuICAgICAgdGhpcy5jdXJyZW50TXEgPSBudWxsO1xcbiAgICAgIHRoaXMuY3VycmVudFBsdWdpbiA9IG51bGw7XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xcblxcbiAgICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ1Jlc3BvbnNpdmVNZW51Jyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSBNZW51IGJ5IHBhcnNpbmcgdGhlIGNsYXNzZXMgZnJvbSB0aGUgJ2RhdGEtUmVzcG9uc2l2ZU1lbnUnIGF0dHJpYnV0ZSBvbiB0aGUgZWxlbWVudC5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcblxcbiAgICBfY3JlYXRlQ2xhc3MoUmVzcG9uc2l2ZU1lbnUsIFt7XFxuICAgICAga2V5OiAnX2luaXQnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICAgIC8vIFRoZSBmaXJzdCB0aW1lIGFuIEludGVyY2hhbmdlIHBsdWdpbiBpcyBpbml0aWFsaXplZCwgdGhpcy5ydWxlcyBpcyBjb252ZXJ0ZWQgZnJvbSBhIHN0cmluZyBvZiBcXFwiY2xhc3Nlc1xcXCIgdG8gYW4gb2JqZWN0IG9mIHJ1bGVzXFxuICAgICAgICBpZiAodHlwZW9mIHRoaXMucnVsZXMgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgICAgIHZhciBydWxlc1RyZWUgPSB7fTtcXG5cXG4gICAgICAgICAgLy8gUGFyc2UgcnVsZXMgZnJvbSBcXFwiY2xhc3Nlc1xcXCIgcHVsbGVkIGZyb20gZGF0YSBhdHRyaWJ1dGVcXG4gICAgICAgICAgdmFyIHJ1bGVzID0gdGhpcy5ydWxlcy5zcGxpdCgnICcpO1xcblxcbiAgICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggZXZlcnkgcnVsZSBmb3VuZFxcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgdmFyIHJ1bGUgPSBydWxlc1tpXS5zcGxpdCgnLScpO1xcbiAgICAgICAgICAgIHZhciBydWxlU2l6ZSA9IHJ1bGUubGVuZ3RoID4gMSA/IHJ1bGVbMF0gOiAnc21hbGwnO1xcbiAgICAgICAgICAgIHZhciBydWxlUGx1Z2luID0gcnVsZS5sZW5ndGggPiAxID8gcnVsZVsxXSA6IHJ1bGVbMF07XFxuXFxuICAgICAgICAgICAgaWYgKE1lbnVQbHVnaW5zW3J1bGVQbHVnaW5dICE9PSBudWxsKSB7XFxuICAgICAgICAgICAgICBydWxlc1RyZWVbcnVsZVNpemVdID0gTWVudVBsdWdpbnNbcnVsZVBsdWdpbl07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHRoaXMucnVsZXMgPSBydWxlc1RyZWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoISQuaXNFbXB0eU9iamVjdCh0aGlzLnJ1bGVzKSkge1xcbiAgICAgICAgICB0aGlzLl9jaGVja01lZGlhUXVlcmllcygpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIHRoZSBNZW51LlxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfZXZlbnRzJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgICAkKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgX3RoaXMuX2NoZWNrTWVkaWFRdWVyaWVzKCk7XFxuICAgICAgICB9KTtcXG4gICAgICAgIC8vICQod2luZG93KS5vbigncmVzaXplLnpmLlJlc3BvbnNpdmVNZW51JywgZnVuY3Rpb24oKSB7XFxuICAgICAgICAvLyAgIF90aGlzLl9jaGVja01lZGlhUXVlcmllcygpO1xcbiAgICAgICAgLy8gfSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIENoZWNrcyB0aGUgY3VycmVudCBzY3JlZW4gd2lkdGggYWdhaW5zdCBhdmFpbGFibGUgbWVkaWEgcXVlcmllcy4gSWYgdGhlIG1lZGlhIHF1ZXJ5IGhhcyBjaGFuZ2VkLCBhbmQgdGhlIHBsdWdpbiBuZWVkZWQgaGFzIGNoYW5nZWQsIHRoZSBwbHVnaW5zIHdpbGwgc3dhcCBvdXQuXFxuICAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ19jaGVja01lZGlhUXVlcmllcycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9jaGVja01lZGlhUXVlcmllcygpIHtcXG4gICAgICAgIHZhciBtYXRjaGVkTXEsXFxuICAgICAgICAgICAgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgLy8gSXRlcmF0ZSB0aHJvdWdoIGVhY2ggcnVsZSBhbmQgZmluZCB0aGUgbGFzdCBtYXRjaGluZyBydWxlXFxuICAgICAgICAkLmVhY2godGhpcy5ydWxlcywgZnVuY3Rpb24gKGtleSkge1xcbiAgICAgICAgICBpZiAoRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3Qoa2V5KSkge1xcbiAgICAgICAgICAgIG1hdGNoZWRNcSA9IGtleTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICAvLyBObyBtYXRjaD8gTm8gZGljZVxcbiAgICAgICAgaWYgKCFtYXRjaGVkTXEpIHJldHVybjtcXG5cXG4gICAgICAgIC8vIFBsdWdpbiBhbHJlYWR5IGluaXRpYWxpemVkPyBXZSBnb29kXFxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGx1Z2luIGluc3RhbmNlb2YgdGhpcy5ydWxlc1ttYXRjaGVkTXFdLnBsdWdpbikgcmV0dXJuO1xcblxcbiAgICAgICAgLy8gUmVtb3ZlIGV4aXN0aW5nIHBsdWdpbi1zcGVjaWZpYyBDU1MgY2xhc3Nlc1xcbiAgICAgICAgJC5lYWNoKE1lbnVQbHVnaW5zLCBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xcbiAgICAgICAgICBfdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh2YWx1ZS5jc3NDbGFzcyk7XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIC8vIEFkZCB0aGUgQ1NTIGNsYXNzIGZvciB0aGUgbmV3IHBsdWdpblxcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLnJ1bGVzW21hdGNoZWRNcV0uY3NzQ2xhc3MpO1xcblxcbiAgICAgICAgLy8gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIHRoZSBuZXcgcGx1Z2luXFxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGx1Z2luKSB0aGlzLmN1cnJlbnRQbHVnaW4uZGVzdHJveSgpO1xcbiAgICAgICAgdGhpcy5jdXJyZW50UGx1Z2luID0gbmV3IHRoaXMucnVsZXNbbWF0Y2hlZE1xXS5wbHVnaW4odGhpcy4kZWxlbWVudCwge30pO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBEZXN0cm95cyB0aGUgaW5zdGFuY2Ugb2YgdGhlIGN1cnJlbnQgcGx1Z2luIG9uIHRoaXMgZWxlbWVudCwgYXMgd2VsbCBhcyB0aGUgd2luZG93IHJlc2l6ZSBoYW5kbGVyIHRoYXQgc3dpdGNoZXMgdGhlIHBsdWdpbnMgb3V0LlxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnZGVzdHJveScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuICAgICAgICB0aGlzLmN1cnJlbnRQbHVnaW4uZGVzdHJveSgpO1xcbiAgICAgICAgJCh3aW5kb3cpLm9mZignLnpmLlJlc3BvbnNpdmVNZW51Jyk7XFxuICAgICAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XFxuICAgICAgfVxcbiAgICB9XSk7XFxuXFxuICAgIHJldHVybiBSZXNwb25zaXZlTWVudTtcXG4gIH0oKTtcXG5cXG4gIFJlc3BvbnNpdmVNZW51LmRlZmF1bHRzID0ge307XFxuXFxuICAvLyBUaGUgcGx1Z2luIG1hdGNoZXMgdGhlIHBsdWdpbiBjbGFzc2VzIHdpdGggdGhlc2UgcGx1Z2luIGluc3RhbmNlcy5cXG4gIHZhciBNZW51UGx1Z2lucyA9IHtcXG4gICAgZHJvcGRvd246IHtcXG4gICAgICBjc3NDbGFzczogJ2Ryb3Bkb3duJyxcXG4gICAgICBwbHVnaW46IEZvdW5kYXRpb24uX3BsdWdpbnNbJ2Ryb3Bkb3duLW1lbnUnXSB8fCBudWxsXFxuICAgIH0sXFxuICAgIGRyaWxsZG93bjoge1xcbiAgICAgIGNzc0NsYXNzOiAnZHJpbGxkb3duJyxcXG4gICAgICBwbHVnaW46IEZvdW5kYXRpb24uX3BsdWdpbnNbJ2RyaWxsZG93biddIHx8IG51bGxcXG4gICAgfSxcXG4gICAgYWNjb3JkaW9uOiB7XFxuICAgICAgY3NzQ2xhc3M6ICdhY2NvcmRpb24tbWVudScsXFxuICAgICAgcGx1Z2luOiBGb3VuZGF0aW9uLl9wbHVnaW5zWydhY2NvcmRpb24tbWVudSddIHx8IG51bGxcXG4gICAgfVxcbiAgfTtcXG5cXG4gIC8vIFdpbmRvdyBleHBvcnRzXFxuICBGb3VuZGF0aW9uLnBsdWdpbihSZXNwb25zaXZlTWVudSwgJ1Jlc3BvbnNpdmVNZW51Jyk7XFxufShqUXVlcnkpO1xcbid1c2Ugc3RyaWN0JztcXG5cXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG4hZnVuY3Rpb24gKCQpIHtcXG5cXG4gIC8qKlxcbiAgICogUmVzcG9uc2l2ZVRvZ2dsZSBtb2R1bGUuXFxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24ucmVzcG9uc2l2ZVRvZ2dsZVxcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XFxuICAgKi9cXG5cXG4gIHZhciBSZXNwb25zaXZlVG9nZ2xlID0gZnVuY3Rpb24gKCkge1xcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBUYWIgQmFyLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQGZpcmVzIFJlc3BvbnNpdmVUb2dnbGUjaW5pdFxcbiAgICAgKiBAcGFyYW0ge2pRdWVyeX0gZWxlbWVudCAtIGpRdWVyeSBvYmplY3QgdG8gYXR0YWNoIHRhYiBiYXIgZnVuY3Rpb25hbGl0eSB0by5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG5cXG4gICAgZnVuY3Rpb24gUmVzcG9uc2l2ZVRvZ2dsZShlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFJlc3BvbnNpdmVUb2dnbGUpO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSAkKGVsZW1lbnQpO1xcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBSZXNwb25zaXZlVG9nZ2xlLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xcblxcbiAgICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ1Jlc3BvbnNpdmVUb2dnbGUnKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHRhYiBiYXIgYnkgZmluZGluZyB0aGUgdGFyZ2V0IGVsZW1lbnQsIHRvZ2dsaW5nIGVsZW1lbnQsIGFuZCBydW5uaW5nIHVwZGF0ZSgpLlxcbiAgICAgKiBAZnVuY3Rpb25cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuXFxuICAgIF9jcmVhdGVDbGFzcyhSZXNwb25zaXZlVG9nZ2xlLCBbe1xcbiAgICAgIGtleTogJ19pbml0JyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgICB2YXIgdGFyZ2V0SUQgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ3Jlc3BvbnNpdmUtdG9nZ2xlJyk7XFxuICAgICAgICBpZiAoIXRhcmdldElEKSB7XFxuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ1lvdXIgdGFiIGJhciBuZWVkcyBhbiBJRCBvZiBhIE1lbnUgYXMgdGhlIHZhbHVlIG9mIGRhdGEtdGFiLWJhci4nKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuJHRhcmdldE1lbnUgPSAkKCcjJyArIHRhcmdldElEKTtcXG4gICAgICAgIHRoaXMuJHRvZ2dsZXIgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLXRvZ2dsZV0nKTtcXG5cXG4gICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBBZGRzIG5lY2Vzc2FyeSBldmVudCBoYW5kbGVycyBmb3IgdGhlIHRhYiBiYXIgdG8gd29yay5cXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX2V2ZW50cycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgICAgdGhpcy5fdXBkYXRlTXFIYW5kbGVyID0gdGhpcy5fdXBkYXRlLmJpbmQodGhpcyk7XFxuXFxuICAgICAgICAkKHdpbmRvdykub24oJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIHRoaXMuX3VwZGF0ZU1xSGFuZGxlcik7XFxuXFxuICAgICAgICB0aGlzLiR0b2dnbGVyLm9uKCdjbGljay56Zi5yZXNwb25zaXZlVG9nZ2xlJywgdGhpcy50b2dnbGVNZW51LmJpbmQodGhpcykpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBDaGVja3MgdGhlIGN1cnJlbnQgbWVkaWEgcXVlcnkgdG8gZGV0ZXJtaW5lIGlmIHRoZSB0YWIgYmFyIHNob3VsZCBiZSB2aXNpYmxlIG9yIGhpZGRlbi5cXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX3VwZGF0ZScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF91cGRhdGUoKSB7XFxuICAgICAgICAvLyBNb2JpbGVcXG4gICAgICAgIGlmICghRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodGhpcy5vcHRpb25zLmhpZGVGb3IpKSB7XFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQuc2hvdygpO1xcbiAgICAgICAgICB0aGlzLiR0YXJnZXRNZW51LmhpZGUoKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIERlc2t0b3BcXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIHRoaXMuJGVsZW1lbnQuaGlkZSgpO1xcbiAgICAgICAgICAgIHRoaXMuJHRhcmdldE1lbnUuc2hvdygpO1xcbiAgICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIFRvZ2dsZXMgdGhlIGVsZW1lbnQgYXR0YWNoZWQgdG8gdGhlIHRhYiBiYXIuIFRoZSB0b2dnbGUgb25seSBoYXBwZW5zIGlmIHRoZSBzY3JlZW4gaXMgc21hbGwgZW5vdWdoIHRvIGFsbG93IGl0LlxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqIEBmaXJlcyBSZXNwb25zaXZlVG9nZ2xlI3RvZ2dsZWRcXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ3RvZ2dsZU1lbnUnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiB0b2dnbGVNZW51KCkge1xcbiAgICAgICAgaWYgKCFGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuaGlkZUZvcikpIHtcXG4gICAgICAgICAgdGhpcy4kdGFyZ2V0TWVudS50b2dnbGUoMCk7XFxuXFxuICAgICAgICAgIC8qKlxcbiAgICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBlbGVtZW50IGF0dGFjaGVkIHRvIHRoZSB0YWIgYmFyIHRvZ2dsZXMuXFxuICAgICAgICAgICAqIEBldmVudCBSZXNwb25zaXZlVG9nZ2xlI3RvZ2dsZWRcXG4gICAgICAgICAgICovXFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcigndG9nZ2xlZC56Zi5yZXNwb25zaXZlVG9nZ2xlJyk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnZGVzdHJveScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZignLnpmLnJlc3BvbnNpdmVUb2dnbGUnKTtcXG4gICAgICAgIHRoaXMuJHRvZ2dsZXIub2ZmKCcuemYucmVzcG9uc2l2ZVRvZ2dsZScpO1xcblxcbiAgICAgICAgJCh3aW5kb3cpLm9mZignY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5JywgdGhpcy5fdXBkYXRlTXFIYW5kbGVyKTtcXG5cXG4gICAgICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcXG4gICAgICB9XFxuICAgIH1dKTtcXG5cXG4gICAgcmV0dXJuIFJlc3BvbnNpdmVUb2dnbGU7XFxuICB9KCk7XFxuXFxuICBSZXNwb25zaXZlVG9nZ2xlLmRlZmF1bHRzID0ge1xcbiAgICAvKipcXG4gICAgICogVGhlIGJyZWFrcG9pbnQgYWZ0ZXIgd2hpY2ggdGhlIG1lbnUgaXMgYWx3YXlzIHNob3duLCBhbmQgdGhlIHRhYiBiYXIgaXMgaGlkZGVuLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlICdtZWRpdW0nXFxuICAgICAqL1xcbiAgICBoaWRlRm9yOiAnbWVkaXVtJ1xcbiAgfTtcXG5cXG4gIC8vIFdpbmRvdyBleHBvcnRzXFxuICBGb3VuZGF0aW9uLnBsdWdpbihSZXNwb25zaXZlVG9nZ2xlLCAnUmVzcG9uc2l2ZVRvZ2dsZScpO1xcbn0oalF1ZXJ5KTtcXG4ndXNlIHN0cmljdCc7XFxuXFxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuIWZ1bmN0aW9uICgkKSB7XFxuXFxuICAvKipcXG4gICAqIFJldmVhbCBtb2R1bGUuXFxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24ucmV2ZWFsXFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmtleWJvYXJkXFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLmJveFxcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvbiBpZiB1c2luZyBhbmltYXRpb25zXFxuICAgKi9cXG5cXG4gIHZhciBSZXZlYWwgPSBmdW5jdGlvbiAoKSB7XFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFJldmVhbC5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byB1c2UgZm9yIHRoZSBtb2RhbC5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBvcHRpb25hbCBwYXJhbWV0ZXJzLlxcbiAgICAgKi9cXG5cXG4gICAgZnVuY3Rpb24gUmV2ZWFsKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgUmV2ZWFsKTtcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgUmV2ZWFsLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XFxuICAgICAgdGhpcy5faW5pdCgpO1xcblxcbiAgICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ1JldmVhbCcpO1xcbiAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoJ1JldmVhbCcsIHtcXG4gICAgICAgICdFTlRFUic6ICdvcGVuJyxcXG4gICAgICAgICdTUEFDRSc6ICdvcGVuJyxcXG4gICAgICAgICdFU0NBUEUnOiAnY2xvc2UnLFxcbiAgICAgICAgJ1RBQic6ICd0YWJfZm9yd2FyZCcsXFxuICAgICAgICAnU0hJRlRfVEFCJzogJ3RhYl9iYWNrd2FyZCdcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIG1vZGFsIGJ5IGFkZGluZyB0aGUgb3ZlcmxheSBhbmQgY2xvc2UgYnV0dG9ucywgKGlmIHNlbGVjdGVkKS5cXG4gICAgICogQHByaXZhdGVcXG4gICAgICovXFxuXFxuXFxuICAgIF9jcmVhdGVDbGFzcyhSZXZlYWwsIFt7XFxuICAgICAga2V5OiAnX2luaXQnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLiRlbGVtZW50LmF0dHIoJ2lkJyk7XFxuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XFxuICAgICAgICB0aGlzLmNhY2hlZCA9IHsgbXE6IEZvdW5kYXRpb24uTWVkaWFRdWVyeS5jdXJyZW50IH07XFxuICAgICAgICB0aGlzLmlzTW9iaWxlID0gbW9iaWxlU25pZmYoKTtcXG5cXG4gICAgICAgIHRoaXMuJGFuY2hvciA9ICQoJ1tkYXRhLW9wZW49XFxcIicgKyB0aGlzLmlkICsgJ1xcXCJdJykubGVuZ3RoID8gJCgnW2RhdGEtb3Blbj1cXFwiJyArIHRoaXMuaWQgKyAnXFxcIl0nKSA6ICQoJ1tkYXRhLXRvZ2dsZT1cXFwiJyArIHRoaXMuaWQgKyAnXFxcIl0nKTtcXG4gICAgICAgIHRoaXMuJGFuY2hvci5hdHRyKHtcXG4gICAgICAgICAgJ2FyaWEtY29udHJvbHMnOiB0aGlzLmlkLFxcbiAgICAgICAgICAnYXJpYS1oYXNwb3B1cCc6IHRydWUsXFxuICAgICAgICAgICd0YWJpbmRleCc6IDBcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5mdWxsU2NyZWVuIHx8IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ2Z1bGwnKSkge1xcbiAgICAgICAgICB0aGlzLm9wdGlvbnMuZnVsbFNjcmVlbiA9IHRydWU7XFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5vdmVybGF5ID0gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkgJiYgIXRoaXMuJG92ZXJsYXkpIHtcXG4gICAgICAgICAgdGhpcy4kb3ZlcmxheSA9IHRoaXMuX21ha2VPdmVybGF5KHRoaXMuaWQpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcXG4gICAgICAgICAgJ3JvbGUnOiAnZGlhbG9nJyxcXG4gICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcXG4gICAgICAgICAgJ2RhdGEteWV0aS1ib3gnOiB0aGlzLmlkLFxcbiAgICAgICAgICAnZGF0YS1yZXNpemUnOiB0aGlzLmlkXFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGlmICh0aGlzLiRvdmVybGF5KSB7XFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQuZGV0YWNoKCkuYXBwZW5kVG8odGhpcy4kb3ZlcmxheSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LmRldGFjaCgpLmFwcGVuZFRvKCQoJ2JvZHknKSk7XFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoJ3dpdGhvdXQtb3ZlcmxheScpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoID09PSAnIycgKyB0aGlzLmlkKSB7XFxuICAgICAgICAgICQod2luZG93KS5vbmUoJ2xvYWQuemYucmV2ZWFsJywgdGhpcy5vcGVuLmJpbmQodGhpcykpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBDcmVhdGVzIGFuIG92ZXJsYXkgZGl2IHRvIGRpc3BsYXkgYmVoaW5kIHRoZSBtb2RhbC5cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX21ha2VPdmVybGF5JyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX21ha2VPdmVybGF5KGlkKSB7XFxuICAgICAgICB2YXIgJG92ZXJsYXkgPSAkKCc8ZGl2PjwvZGl2PicpLmFkZENsYXNzKCdyZXZlYWwtb3ZlcmxheScpLmFwcGVuZFRvKCdib2R5Jyk7XFxuICAgICAgICByZXR1cm4gJG92ZXJsYXk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIFVwZGF0ZXMgcG9zaXRpb24gb2YgbW9kYWxcXG4gICAgICAgKiBUT0RPOiAgRmlndXJlIG91dCBpZiB3ZSBhY3R1YWxseSBuZWVkIHRvIGNhY2hlIHRoZXNlIHZhbHVlcyBvciBpZiBpdCBkb2Vzbid0IG1hdHRlclxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfdXBkYXRlUG9zaXRpb24nLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlUG9zaXRpb24oKSB7XFxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLiRlbGVtZW50Lm91dGVyV2lkdGgoKTtcXG4gICAgICAgIHZhciBvdXRlcldpZHRoID0gJCh3aW5kb3cpLndpZHRoKCk7XFxuICAgICAgICB2YXIgaGVpZ2h0ID0gdGhpcy4kZWxlbWVudC5vdXRlckhlaWdodCgpO1xcbiAgICAgICAgdmFyIG91dGVySGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpO1xcbiAgICAgICAgdmFyIGxlZnQsIHRvcDtcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaE9mZnNldCA9PT0gJ2F1dG8nKSB7XFxuICAgICAgICAgIGxlZnQgPSBwYXJzZUludCgob3V0ZXJXaWR0aCAtIHdpZHRoKSAvIDIsIDEwKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGxlZnQgPSBwYXJzZUludCh0aGlzLm9wdGlvbnMuaE9mZnNldCwgMTApO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy52T2Zmc2V0ID09PSAnYXV0bycpIHtcXG4gICAgICAgICAgaWYgKGhlaWdodCA+IG91dGVySGVpZ2h0KSB7XFxuICAgICAgICAgICAgdG9wID0gcGFyc2VJbnQoTWF0aC5taW4oMTAwLCBvdXRlckhlaWdodCAvIDEwKSwgMTApO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHRvcCA9IHBhcnNlSW50KChvdXRlckhlaWdodCAtIGhlaWdodCkgLyA0LCAxMCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRvcCA9IHBhcnNlSW50KHRoaXMub3B0aW9ucy52T2Zmc2V0LCAxMCk7XFxuICAgICAgICB9XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmNzcyh7IHRvcDogdG9wICsgJ3B4JyB9KTtcXG4gICAgICAgIC8vIG9ubHkgd29ycnkgYWJvdXQgbGVmdCBpZiB3ZSBkb24ndCBoYXZlIGFuIG92ZXJsYXkgb3Igd2UgaGF2ZWEgIGhvcml6b250YWwgb2Zmc2V0LFxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHdlJ3JlIHBlcmZlY3RseSBpbiB0aGUgbWlkZGxlXFxuICAgICAgICBpZiAoIXRoaXMuJG92ZXJsYXkgfHwgdGhpcy5vcHRpb25zLmhPZmZzZXQgIT09ICdhdXRvJykge1xcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LmNzcyh7IGxlZnQ6IGxlZnQgKyAncHgnIH0pO1xcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LmNzcyh7IG1hcmdpbjogJzBweCcgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBtb2RhbC5cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX2V2ZW50cycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgICB2YXIgX3RoaXMyID0gdGhpcztcXG5cXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKHtcXG4gICAgICAgICAgJ29wZW4uemYudHJpZ2dlcic6IHRoaXMub3Blbi5iaW5kKHRoaXMpLFxcbiAgICAgICAgICAnY2xvc2UuemYudHJpZ2dlcic6IGZ1bmN0aW9uIChldmVudCwgJGVsZW1lbnQpIHtcXG4gICAgICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBfdGhpcy4kZWxlbWVudFswXSB8fCAkKGV2ZW50LnRhcmdldCkucGFyZW50cygnW2RhdGEtY2xvc2FibGVdJylbMF0gPT09ICRlbGVtZW50KSB7XFxuICAgICAgICAgICAgICAvLyBvbmx5IGNsb3NlIHJldmVhbCB3aGVuIGl0J3MgZXhwbGljaXRseSBjYWxsZWRcXG4gICAgICAgICAgICAgIHJldHVybiBfdGhpczIuY2xvc2UuYXBwbHkoX3RoaXMyKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgICd0b2dnbGUuemYudHJpZ2dlcic6IHRoaXMudG9nZ2xlLmJpbmQodGhpcyksXFxuICAgICAgICAgICdyZXNpemVtZS56Zi50cmlnZ2VyJzogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVQb3NpdGlvbigpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIGlmICh0aGlzLiRhbmNob3IubGVuZ3RoKSB7XFxuICAgICAgICAgIHRoaXMuJGFuY2hvci5vbigna2V5ZG93bi56Zi5yZXZlYWwnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIGlmIChlLndoaWNoID09PSAxMyB8fCBlLndoaWNoID09PSAzMikge1xcbiAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICAgIF90aGlzLm9wZW4oKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgJiYgdGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcXG4gICAgICAgICAgdGhpcy4kb3ZlcmxheS5vZmYoJy56Zi5yZXZlYWwnKS5vbignY2xpY2suemYucmV2ZWFsJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBpZiAoZS50YXJnZXQgPT09IF90aGlzLiRlbGVtZW50WzBdIHx8ICQuY29udGFpbnMoX3RoaXMuJGVsZW1lbnRbMF0sIGUudGFyZ2V0KSkge1xcbiAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBfdGhpcy5jbG9zZSgpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVlcExpbmspIHtcXG4gICAgICAgICAgJCh3aW5kb3cpLm9uKCdwb3BzdGF0ZS56Zi5yZXZlYWw6JyArIHRoaXMuaWQsIHRoaXMuX2hhbmRsZVN0YXRlLmJpbmQodGhpcykpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBIYW5kbGVzIG1vZGFsIG1ldGhvZHMgb24gYmFjay9mb3J3YXJkIGJ1dHRvbiBjbGlja3Mgb3IgYW55IG90aGVyIGV2ZW50IHRoYXQgdHJpZ2dlcnMgcG9wc3RhdGUuXFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ19oYW5kbGVTdGF0ZScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9oYW5kbGVTdGF0ZShlKSB7XFxuICAgICAgICBpZiAod2luZG93LmxvY2F0aW9uLmhhc2ggPT09ICcjJyArIHRoaXMuaWQgJiYgIXRoaXMuaXNBY3RpdmUpIHtcXG4gICAgICAgICAgdGhpcy5vcGVuKCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIE9wZW5zIHRoZSBtb2RhbCBjb250cm9sbGVkIGJ5IGB0aGlzLiRhbmNob3JgLCBhbmQgY2xvc2VzIGFsbCBvdGhlcnMgYnkgZGVmYXVsdC5cXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKiBAZmlyZXMgUmV2ZWFsI2Nsb3NlbWVcXG4gICAgICAgKiBAZmlyZXMgUmV2ZWFsI29wZW5cXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ29wZW4nLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBvcGVuKCkge1xcbiAgICAgICAgdmFyIF90aGlzMyA9IHRoaXM7XFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rKSB7XFxuICAgICAgICAgIHZhciBoYXNoID0gJyMnICsgdGhpcy5pZDtcXG5cXG4gICAgICAgICAgaWYgKHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZSkge1xcbiAgICAgICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShudWxsLCBudWxsLCBoYXNoKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IGhhc2g7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xcblxcbiAgICAgICAgLy8gTWFrZSBlbGVtZW50cyBpbnZpc2libGUsIGJ1dCByZW1vdmUgZGlzcGxheTogbm9uZSBzbyB3ZSBjYW4gZ2V0IHNpemUgYW5kIHBvc2l0aW9uaW5nXFxuICAgICAgICB0aGlzLiRlbGVtZW50LmNzcyh7ICd2aXNpYmlsaXR5JzogJ2hpZGRlbicgfSkuc2hvdygpLnNjcm9sbFRvcCgwKTtcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMub3ZlcmxheSkge1xcbiAgICAgICAgICB0aGlzLiRvdmVybGF5LmNzcyh7ICd2aXNpYmlsaXR5JzogJ2hpZGRlbicgfSkuc2hvdygpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcXG5cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuaGlkZSgpLmNzcyh7ICd2aXNpYmlsaXR5JzogJycgfSk7XFxuXFxuICAgICAgICBpZiAodGhpcy4kb3ZlcmxheSkge1xcbiAgICAgICAgICB0aGlzLiRvdmVybGF5LmNzcyh7ICd2aXNpYmlsaXR5JzogJycgfSkuaGlkZSgpO1xcbiAgICAgICAgICBpZiAodGhpcy4kZWxlbWVudC5oYXNDbGFzcygnZmFzdCcpKSB7XFxuICAgICAgICAgICAgdGhpcy4kb3ZlcmxheS5hZGRDbGFzcygnZmFzdCcpO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoJ3Nsb3cnKSkge1xcbiAgICAgICAgICAgIHRoaXMuJG92ZXJsYXkuYWRkQ2xhc3MoJ3Nsb3cnKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubXVsdGlwbGVPcGVuZWQpIHtcXG4gICAgICAgICAgLyoqXFxuICAgICAgICAgICAqIEZpcmVzIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgbW9kYWwgb3BlbnMuXFxuICAgICAgICAgICAqIENsb3NlcyBhbnkgb3RoZXIgbW9kYWxzIHRoYXQgYXJlIGN1cnJlbnRseSBvcGVuXFxuICAgICAgICAgICAqIEBldmVudCBSZXZlYWwjY2xvc2VtZVxcbiAgICAgICAgICAgKi9cXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdjbG9zZW1lLnpmLnJldmVhbCcsIHRoaXMuaWQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gTW90aW9uIFVJIG1ldGhvZCBvZiByZXZlYWxcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uSW4pIHtcXG4gICAgICAgICAgdmFyIF90aGlzO1xcblxcbiAgICAgICAgICAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIHZhciBhZnRlckFuaW1hdGlvbkZvY3VzID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgX3RoaXMuJGVsZW1lbnQuYXR0cih7XFxuICAgICAgICAgICAgICAgICdhcmlhLWhpZGRlbic6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICAndGFiaW5kZXgnOiAtMVxcbiAgICAgICAgICAgICAgfSkuZm9jdXMoKTtcXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmb2N1cycpO1xcbiAgICAgICAgICAgIH07XFxuXFxuICAgICAgICAgICAgX3RoaXMgPSBfdGhpczM7XFxuXFxuICAgICAgICAgICAgaWYgKF90aGlzMy5vcHRpb25zLm92ZXJsYXkpIHtcXG4gICAgICAgICAgICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbihfdGhpczMuJG92ZXJsYXksICdmYWRlLWluJyk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbihfdGhpczMuJGVsZW1lbnQsIF90aGlzMy5vcHRpb25zLmFuaW1hdGlvbkluLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBfdGhpczMuZm9jdXNhYmxlRWxlbWVudHMgPSBGb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUoX3RoaXMzLiRlbGVtZW50KTtcXG4gICAgICAgICAgICAgIGFmdGVyQW5pbWF0aW9uRm9jdXMoKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSkoKTtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIGpRdWVyeSBtZXRob2Qgb2YgcmV2ZWFsXFxuICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcXG4gICAgICAgICAgICAgIHRoaXMuJG92ZXJsYXkuc2hvdygwKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgdGhpcy4kZWxlbWVudC5zaG93KHRoaXMub3B0aW9ucy5zaG93RGVsYXkpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAvLyBoYW5kbGUgYWNjZXNzaWJpbGl0eVxcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcXG4gICAgICAgICAgJ2FyaWEtaGlkZGVuJzogZmFsc2UsXFxuICAgICAgICAgICd0YWJpbmRleCc6IC0xXFxuICAgICAgICB9KS5mb2N1cygpO1xcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBtb2RhbCBoYXMgc3VjY2Vzc2Z1bGx5IG9wZW5lZC5cXG4gICAgICAgICAqIEBldmVudCBSZXZlYWwjb3BlblxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ29wZW4uemYucmV2ZWFsJyk7XFxuXFxuICAgICAgICBpZiAodGhpcy5pc01vYmlsZSkge1xcbiAgICAgICAgICB0aGlzLm9yaWdpbmFsU2Nyb2xsUG9zID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xcbiAgICAgICAgICAkKCdodG1sLCBib2R5JykuYWRkQ2xhc3MoJ2lzLXJldmVhbC1vcGVuJyk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAkKCdib2R5JykuYWRkQ2xhc3MoJ2lzLXJldmVhbC1vcGVuJyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgX3RoaXMzLl9leHRyYUhhbmRsZXJzKCk7XFxuICAgICAgICB9LCAwKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogQWRkcyBleHRyYSBldmVudCBoYW5kbGVycyBmb3IgdGhlIGJvZHkgYW5kIHdpbmRvdyBpZiBuZWNlc3NhcnkuXFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ19leHRyYUhhbmRsZXJzJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V4dHJhSGFuZGxlcnMoKSB7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgdGhpcy5mb2N1c2FibGVFbGVtZW50cyA9IEZvdW5kYXRpb24uS2V5Ym9hcmQuZmluZEZvY3VzYWJsZSh0aGlzLiRlbGVtZW50KTtcXG5cXG4gICAgICAgIGlmICghdGhpcy5vcHRpb25zLm92ZXJsYXkgJiYgdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAmJiAhdGhpcy5vcHRpb25zLmZ1bGxTY3JlZW4pIHtcXG4gICAgICAgICAgJCgnYm9keScpLm9uKCdjbGljay56Zi5yZXZlYWwnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIGlmIChlLnRhcmdldCA9PT0gX3RoaXMuJGVsZW1lbnRbMF0gfHwgJC5jb250YWlucyhfdGhpcy4kZWxlbWVudFswXSwgZS50YXJnZXQpKSB7XFxuICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jbG9zZU9uRXNjKSB7XFxuICAgICAgICAgICQod2luZG93KS5vbigna2V5ZG93bi56Zi5yZXZlYWwnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGUsICdSZXZlYWwnLCB7XFxuICAgICAgICAgICAgICBjbG9zZTogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5jbG9zZU9uRXNjKSB7XFxuICAgICAgICAgICAgICAgICAgX3RoaXMuY2xvc2UoKTtcXG4gICAgICAgICAgICAgICAgICBfdGhpcy4kYW5jaG9yLmZvY3VzKCk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBsb2NrIGZvY3VzIHdpdGhpbiBtb2RhbCB3aGlsZSB0YWJiaW5nXFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uKCdrZXlkb3duLnpmLnJldmVhbCcsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIHZhciAkdGFyZ2V0ID0gJCh0aGlzKTtcXG4gICAgICAgICAgLy8gaGFuZGxlIGtleWJvYXJkIGV2ZW50IHdpdGgga2V5Ym9hcmQgdXRpbFxcbiAgICAgICAgICBGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLCAnUmV2ZWFsJywge1xcbiAgICAgICAgICAgIHRhYl9mb3J3YXJkOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBpZiAoX3RoaXMuJGVsZW1lbnQuZmluZCgnOmZvY3VzJykuaXMoX3RoaXMuZm9jdXNhYmxlRWxlbWVudHMuZXEoLTEpKSkge1xcbiAgICAgICAgICAgICAgICAvLyBsZWZ0IG1vZGFsIGRvd253YXJkcywgc2V0dGluZyBmb2N1cyB0byBmaXJzdCBlbGVtZW50XFxuICAgICAgICAgICAgICAgIF90aGlzLmZvY3VzYWJsZUVsZW1lbnRzLmVxKDApLmZvY3VzKCk7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgaWYgKF90aGlzLmZvY3VzYWJsZUVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgICAgICAgICAvLyBubyBmb2N1c2FibGUgZWxlbWVudHMgaW5zaWRlIHRoZSBtb2RhbCBhdCBhbGwsIHByZXZlbnQgdGFiYmluZyBpbiBnZW5lcmFsXFxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgdGFiX2JhY2t3YXJkOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBpZiAoX3RoaXMuJGVsZW1lbnQuZmluZCgnOmZvY3VzJykuaXMoX3RoaXMuZm9jdXNhYmxlRWxlbWVudHMuZXEoMCkpIHx8IF90aGlzLiRlbGVtZW50LmlzKCc6Zm9jdXMnKSkge1xcbiAgICAgICAgICAgICAgICAvLyBsZWZ0IG1vZGFsIHVwd2FyZHMsIHNldHRpbmcgZm9jdXMgdG8gbGFzdCBlbGVtZW50XFxuICAgICAgICAgICAgICAgIF90aGlzLmZvY3VzYWJsZUVsZW1lbnRzLmVxKC0xKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIGlmIChfdGhpcy5mb2N1c2FibGVFbGVtZW50cy5sZW5ndGggPT09IDApIHtcXG4gICAgICAgICAgICAgICAgLy8gbm8gZm9jdXNhYmxlIGVsZW1lbnRzIGluc2lkZSB0aGUgbW9kYWwgYXQgYWxsLCBwcmV2ZW50IHRhYmJpbmcgaW4gZ2VuZXJhbFxcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIG9wZW46IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIGlmIChfdGhpcy4kZWxlbWVudC5maW5kKCc6Zm9jdXMnKS5pcyhfdGhpcy4kZWxlbWVudC5maW5kKCdbZGF0YS1jbG9zZV0nKSkpIHtcXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgLy8gc2V0IGZvY3VzIGJhY2sgdG8gYW5jaG9yIGlmIGNsb3NlIGJ1dHRvbiBoYXMgYmVlbiBhY3RpdmF0ZWRcXG4gICAgICAgICAgICAgICAgICBfdGhpcy4kYW5jaG9yLmZvY3VzKCk7XFxuICAgICAgICAgICAgICAgIH0sIDEpO1xcbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgkdGFyZ2V0LmlzKF90aGlzLmZvY3VzYWJsZUVsZW1lbnRzKSkge1xcbiAgICAgICAgICAgICAgICAvLyBkb250J3QgdHJpZ2dlciBpZiBhY3VhbCBlbGVtZW50IGhhcyBmb2N1cyAoaS5lLiBpbnB1dHMsIGxpbmtzLCAuLi4pXFxuICAgICAgICAgICAgICAgIF90aGlzLm9wZW4oKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGNsb3NlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5jbG9zZU9uRXNjKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLmNsb3NlKCk7XFxuICAgICAgICAgICAgICAgIF90aGlzLiRhbmNob3IuZm9jdXMoKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uIChwcmV2ZW50RGVmYXVsdCkge1xcbiAgICAgICAgICAgICAgaWYgKHByZXZlbnREZWZhdWx0KSB7XFxuICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIENsb3NlcyB0aGUgbW9kYWwuXFxuICAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgICogQGZpcmVzIFJldmVhbCNjbG9zZWRcXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ2Nsb3NlJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gY2xvc2UoKSB7XFxuICAgICAgICBpZiAoIXRoaXMuaXNBY3RpdmUgfHwgIXRoaXMuJGVsZW1lbnQuaXMoJzp2aXNpYmxlJykpIHtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICAgIC8vIE1vdGlvbiBVSSBtZXRob2Qgb2YgaGlkaW5nXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmFuaW1hdGlvbk91dCkge1xcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcXG4gICAgICAgICAgICBGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KHRoaXMuJG92ZXJsYXksICdmYWRlLW91dCcsIGZpbmlzaFVwKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBmaW5pc2hVcCgpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQodGhpcy4kZWxlbWVudCwgdGhpcy5vcHRpb25zLmFuaW1hdGlvbk91dCk7XFxuICAgICAgICB9XFxuICAgICAgICAvLyBqUXVlcnkgbWV0aG9kIG9mIGhpZGluZ1xcbiAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5vdmVybGF5KSB7XFxuICAgICAgICAgICAgICB0aGlzLiRvdmVybGF5LmhpZGUoMCwgZmluaXNoVXApO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICBmaW5pc2hVcCgpO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LmhpZGUodGhpcy5vcHRpb25zLmhpZGVEZWxheSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgIC8vIENvbmRpdGlvbmFscyB0byByZW1vdmUgZXh0cmEgZXZlbnQgbGlzdGVuZXJzIGFkZGVkIG9uIG9wZW5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xvc2VPbkVzYykge1xcbiAgICAgICAgICAkKHdpbmRvdykub2ZmKCdrZXlkb3duLnpmLnJldmVhbCcpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMub3ZlcmxheSAmJiB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7XFxuICAgICAgICAgICQoJ2JvZHknKS5vZmYoJ2NsaWNrLnpmLnJldmVhbCcpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ2tleWRvd24uemYucmV2ZWFsJyk7XFxuXFxuICAgICAgICBmdW5jdGlvbiBmaW5pc2hVcCgpIHtcXG4gICAgICAgICAgaWYgKF90aGlzLmlzTW9iaWxlKSB7XFxuICAgICAgICAgICAgJCgnaHRtbCwgYm9keScpLnJlbW92ZUNsYXNzKCdpcy1yZXZlYWwtb3BlbicpO1xcbiAgICAgICAgICAgIGlmIChfdGhpcy5vcmlnaW5hbFNjcm9sbFBvcykge1xcbiAgICAgICAgICAgICAgJCgnYm9keScpLnNjcm9sbFRvcChfdGhpcy5vcmlnaW5hbFNjcm9sbFBvcyk7XFxuICAgICAgICAgICAgICBfdGhpcy5vcmlnaW5hbFNjcm9sbFBvcyA9IG51bGw7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICQoJ2JvZHknKS5yZW1vdmVDbGFzcygnaXMtcmV2ZWFsLW9wZW4nKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBfdGhpcy4kZWxlbWVudC5hdHRyKCdhcmlhLWhpZGRlbicsIHRydWUpO1xcblxcbiAgICAgICAgICAvKipcXG4gICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBtb2RhbCBpcyBkb25lIGNsb3NpbmcuXFxuICAgICAgICAgICogQGV2ZW50IFJldmVhbCNjbG9zZWRcXG4gICAgICAgICAgKi9cXG4gICAgICAgICAgX3RoaXMuJGVsZW1lbnQudHJpZ2dlcignY2xvc2VkLnpmLnJldmVhbCcpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAqIFJlc2V0cyB0aGUgbW9kYWwgY29udGVudFxcbiAgICAgICAgKiBUaGlzIHByZXZlbnRzIGEgcnVubmluZyB2aWRlbyB0byBrZWVwIGdvaW5nIGluIHRoZSBiYWNrZ3JvdW5kXFxuICAgICAgICAqL1xcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZXNldE9uQ2xvc2UpIHtcXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5odG1sKHRoaXMuJGVsZW1lbnQuaHRtbCgpKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcXG4gICAgICAgIGlmIChfdGhpcy5vcHRpb25zLmRlZXBMaW5rKSB7XFxuICAgICAgICAgIGlmICh3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUpIHtcXG4gICAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5yZXBsYWNlU3RhdGUoXFxcIlxcXCIsIGRvY3VtZW50LnRpdGxlLCB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyc7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogVG9nZ2xlcyB0aGUgb3Blbi9jbG9zZWQgc3RhdGUgb2YgYSBtb2RhbC5cXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ3RvZ2dsZScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcXG4gICAgICAgIGlmICh0aGlzLmlzQWN0aXZlKSB7XFxuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMub3BlbigpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ2Rlc3Ryb3knLFxcblxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIERlc3Ryb3lzIGFuIGluc3RhbmNlIG9mIGEgbW9kYWwuXFxuICAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgICovXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm92ZXJsYXkpIHtcXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5hcHBlbmRUbygkKCdib2R5JykpOyAvLyBtb3ZlICRlbGVtZW50IG91dHNpZGUgb2YgJG92ZXJsYXkgdG8gcHJldmVudCBlcnJvciB1bnJlZ2lzdGVyUGx1Z2luKClcXG4gICAgICAgICAgdGhpcy4kb3ZlcmxheS5oaWRlKCkub2ZmKCkucmVtb3ZlKCk7XFxuICAgICAgICB9XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmhpZGUoKS5vZmYoKTtcXG4gICAgICAgIHRoaXMuJGFuY2hvci5vZmYoJy56ZicpO1xcbiAgICAgICAgJCh3aW5kb3cpLm9mZignLnpmLnJldmVhbDonICsgdGhpcy5pZCk7XFxuXFxuICAgICAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XFxuICAgICAgfVxcbiAgICB9XSk7XFxuXFxuICAgIHJldHVybiBSZXZlYWw7XFxuICB9KCk7XFxuXFxuICBSZXZlYWwuZGVmYXVsdHMgPSB7XFxuICAgIC8qKlxcbiAgICAgKiBNb3Rpb24tVUkgY2xhc3MgdG8gdXNlIGZvciBhbmltYXRlZCBlbGVtZW50cy4gSWYgbm9uZSB1c2VkLCBkZWZhdWx0cyB0byBzaW1wbGUgc2hvdy9oaWRlLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlICdzbGlkZS1pbi1sZWZ0J1xcbiAgICAgKi9cXG4gICAgYW5pbWF0aW9uSW46ICcnLFxcbiAgICAvKipcXG4gICAgICogTW90aW9uLVVJIGNsYXNzIHRvIHVzZSBmb3IgYW5pbWF0ZWQgZWxlbWVudHMuIElmIG5vbmUgdXNlZCwgZGVmYXVsdHMgdG8gc2ltcGxlIHNob3cvaGlkZS5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAnc2xpZGUtb3V0LXJpZ2h0J1xcbiAgICAgKi9cXG4gICAgYW5pbWF0aW9uT3V0OiAnJyxcXG4gICAgLyoqXFxuICAgICAqIFRpbWUsIGluIG1zLCB0byBkZWxheSB0aGUgb3BlbmluZyBvZiBhIG1vZGFsIGFmdGVyIGEgY2xpY2sgaWYgbm8gYW5pbWF0aW9uIHVzZWQuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgMTBcXG4gICAgICovXFxuICAgIHNob3dEZWxheTogMCxcXG4gICAgLyoqXFxuICAgICAqIFRpbWUsIGluIG1zLCB0byBkZWxheSB0aGUgY2xvc2luZyBvZiBhIG1vZGFsIGFmdGVyIGEgY2xpY2sgaWYgbm8gYW5pbWF0aW9uIHVzZWQuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgMTBcXG4gICAgICovXFxuICAgIGhpZGVEZWxheTogMCxcXG4gICAgLyoqXFxuICAgICAqIEFsbG93cyBhIGNsaWNrIG9uIHRoZSBib2R5L292ZXJsYXkgdG8gY2xvc2UgdGhlIG1vZGFsLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIHRydWVcXG4gICAgICovXFxuICAgIGNsb3NlT25DbGljazogdHJ1ZSxcXG4gICAgLyoqXFxuICAgICAqIEFsbG93cyB0aGUgbW9kYWwgdG8gY2xvc2UgaWYgdGhlIHVzZXIgcHJlc3NlcyB0aGUgYEVTQ0FQRWAga2V5LlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIHRydWVcXG4gICAgICovXFxuICAgIGNsb3NlT25Fc2M6IHRydWUsXFxuICAgIC8qKlxcbiAgICAgKiBJZiB0cnVlLCBhbGxvd3MgbXVsdGlwbGUgbW9kYWxzIHRvIGJlIGRpc3BsYXllZCBhdCBvbmNlLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIGZhbHNlXFxuICAgICAqL1xcbiAgICBtdWx0aXBsZU9wZW5lZDogZmFsc2UsXFxuICAgIC8qKlxcbiAgICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgbW9kYWwgc2hvdWxkIHB1c2ggZG93biBmcm9tIHRoZSB0b3Agb2YgdGhlIHNjcmVlbi5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSBhdXRvXFxuICAgICAqL1xcbiAgICB2T2Zmc2V0OiAnYXV0bycsXFxuICAgIC8qKlxcbiAgICAgKiBEaXN0YW5jZSwgaW4gcGl4ZWxzLCB0aGUgbW9kYWwgc2hvdWxkIHB1c2ggaW4gZnJvbSB0aGUgc2lkZSBvZiB0aGUgc2NyZWVuLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIGF1dG9cXG4gICAgICovXFxuICAgIGhPZmZzZXQ6ICdhdXRvJyxcXG4gICAgLyoqXFxuICAgICAqIEFsbG93cyB0aGUgbW9kYWwgdG8gYmUgZnVsbHNjcmVlbiwgY29tcGxldGVseSBibG9ja2luZyBvdXQgdGhlIHJlc3Qgb2YgdGhlIHZpZXcuIEpTIGNoZWNrcyBmb3IgdGhpcyBhcyB3ZWxsLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIGZhbHNlXFxuICAgICAqL1xcbiAgICBmdWxsU2NyZWVuOiBmYWxzZSxcXG4gICAgLyoqXFxuICAgICAqIFBlcmNlbnRhZ2Ugb2Ygc2NyZWVuIGhlaWdodCB0aGUgbW9kYWwgc2hvdWxkIHB1c2ggdXAgZnJvbSB0aGUgYm90dG9tIG9mIHRoZSB2aWV3LlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIDEwXFxuICAgICAqL1xcbiAgICBidG1PZmZzZXRQY3Q6IDEwLFxcbiAgICAvKipcXG4gICAgICogQWxsb3dzIHRoZSBtb2RhbCB0byBnZW5lcmF0ZSBhbiBvdmVybGF5IGRpdiwgd2hpY2ggd2lsbCBjb3ZlciB0aGUgdmlldyB3aGVuIG1vZGFsIG9wZW5zLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIHRydWVcXG4gICAgICovXFxuICAgIG92ZXJsYXk6IHRydWUsXFxuICAgIC8qKlxcbiAgICAgKiBBbGxvd3MgdGhlIG1vZGFsIHRvIHJlbW92ZSBhbmQgcmVpbmplY3QgbWFya3VwIG9uIGNsb3NlLiBTaG91bGQgYmUgdHJ1ZSBpZiB1c2luZyB2aWRlbyBlbGVtZW50cyB3L28gdXNpbmcgcHJvdmlkZXIncyBhcGksIG90aGVyd2lzZSwgdmlkZW9zIHdpbGwgY29udGludWUgdG8gcGxheSBpbiB0aGUgYmFja2dyb3VuZC5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSBmYWxzZVxcbiAgICAgKi9cXG4gICAgcmVzZXRPbkNsb3NlOiBmYWxzZSxcXG4gICAgLyoqXFxuICAgICAqIEFsbG93cyB0aGUgbW9kYWwgdG8gYWx0ZXIgdGhlIHVybCBvbiBvcGVuL2Nsb3NlLCBhbmQgYWxsb3dzIHRoZSB1c2Ugb2YgdGhlIGBiYWNrYCBidXR0b24gdG8gY2xvc2UgbW9kYWxzLiBBTFNPLCBhbGxvd3MgYSBtb2RhbCB0byBhdXRvLW1hbmlhY2FsbHkgb3BlbiBvbiBwYWdlIGxvYWQgSUYgdGhlIGhhc2ggPT09IHRoZSBtb2RhbCdzIHVzZXItc2V0IGlkLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIGZhbHNlXFxuICAgICAqL1xcbiAgICBkZWVwTGluazogZmFsc2VcXG4gIH07XFxuXFxuICAvLyBXaW5kb3cgZXhwb3J0c1xcbiAgRm91bmRhdGlvbi5wbHVnaW4oUmV2ZWFsLCAnUmV2ZWFsJyk7XFxuXFxuICBmdW5jdGlvbiBpUGhvbmVTbmlmZigpIHtcXG4gICAgcmV0dXJuICgvaVAoYWR8aG9uZXxvZCkuKk9TLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KVxcbiAgICApO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gYW5kcm9pZFNuaWZmKCkge1xcbiAgICByZXR1cm4gKC9BbmRyb2lkLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KVxcbiAgICApO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gbW9iaWxlU25pZmYoKSB7XFxuICAgIHJldHVybiBpUGhvbmVTbmlmZigpIHx8IGFuZHJvaWRTbmlmZigpO1xcbiAgfVxcbn0oalF1ZXJ5KTtcXG4ndXNlIHN0cmljdCc7XFxuXFxudmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHsgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcXFwidmFsdWVcXFwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfSByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykgeyBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9OyB9KCk7XFxuXFxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTsgfSB9XFxuXFxuIWZ1bmN0aW9uICgkKSB7XFxuXFxuICAvKipcXG4gICAqIFNsaWRlciBtb2R1bGUuXFxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24uc2xpZGVyXFxuICAgKiBAcmVxdWlyZXMgZm91bmRhdGlvbi51dGlsLm1vdGlvblxcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50b3VjaFxcbiAgICovXFxuXFxuICB2YXIgU2xpZGVyID0gZnVuY3Rpb24gKCkge1xcbiAgICAvKipcXG4gICAgICogQ3JlYXRlcyBhIG5ldyBpbnN0YW5jZSBvZiBhIGRyaWxsZG93biBtZW51LlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2UgaW50byBhbiBhY2NvcmRpb24gbWVudS5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG5cXG4gICAgZnVuY3Rpb24gU2xpZGVyKGVsZW1lbnQsIG9wdGlvbnMpIHtcXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgU2xpZGVyKTtcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgU2xpZGVyLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcblxcbiAgICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ1NsaWRlcicpO1xcbiAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoJ1NsaWRlcicsIHtcXG4gICAgICAgICdsdHInOiB7XFxuICAgICAgICAgICdBUlJPV19SSUdIVCc6ICdpbmNyZWFzZScsXFxuICAgICAgICAgICdBUlJPV19VUCc6ICdpbmNyZWFzZScsXFxuICAgICAgICAgICdBUlJPV19ET1dOJzogJ2RlY3JlYXNlJyxcXG4gICAgICAgICAgJ0FSUk9XX0xFRlQnOiAnZGVjcmVhc2UnLFxcbiAgICAgICAgICAnU0hJRlRfQVJST1dfUklHSFQnOiAnaW5jcmVhc2VfZmFzdCcsXFxuICAgICAgICAgICdTSElGVF9BUlJPV19VUCc6ICdpbmNyZWFzZV9mYXN0JyxcXG4gICAgICAgICAgJ1NISUZUX0FSUk9XX0RPV04nOiAnZGVjcmVhc2VfZmFzdCcsXFxuICAgICAgICAgICdTSElGVF9BUlJPV19MRUZUJzogJ2RlY3JlYXNlX2Zhc3QnXFxuICAgICAgICB9LFxcbiAgICAgICAgJ3J0bCc6IHtcXG4gICAgICAgICAgJ0FSUk9XX0xFRlQnOiAnaW5jcmVhc2UnLFxcbiAgICAgICAgICAnQVJST1dfUklHSFQnOiAnZGVjcmVhc2UnLFxcbiAgICAgICAgICAnU0hJRlRfQVJST1dfTEVGVCc6ICdpbmNyZWFzZV9mYXN0JyxcXG4gICAgICAgICAgJ1NISUZUX0FSUk9XX1JJR0hUJzogJ2RlY3JlYXNlX2Zhc3QnXFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEluaXRpbGl6ZXMgdGhlIHBsdWdpbiBieSByZWFkaW5nL3NldHRpbmcgYXR0cmlidXRlcywgY3JlYXRpbmcgY29sbGVjdGlvbnMgYW5kIHNldHRpbmcgdGhlIGluaXRpYWwgcG9zaXRpb24gb2YgdGhlIGhhbmRsZShzKS5cXG4gICAgICogQGZ1bmN0aW9uXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcblxcbiAgICBfY3JlYXRlQ2xhc3MoU2xpZGVyLCBbe1xcbiAgICAgIGtleTogJ19pbml0JyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2luaXQoKSB7XFxuICAgICAgICB0aGlzLmlucHV0cyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnaW5wdXQnKTtcXG4gICAgICAgIHRoaXMuaGFuZGxlcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtc2xpZGVyLWhhbmRsZV0nKTtcXG5cXG4gICAgICAgIHRoaXMuJGhhbmRsZSA9IHRoaXMuaGFuZGxlcy5lcSgwKTtcXG4gICAgICAgIHRoaXMuJGlucHV0ID0gdGhpcy5pbnB1dHMubGVuZ3RoID8gdGhpcy5pbnB1dHMuZXEoMCkgOiAkKCcjJyArIHRoaXMuJGhhbmRsZS5hdHRyKCdhcmlhLWNvbnRyb2xzJykpO1xcbiAgICAgICAgdGhpcy4kZmlsbCA9IHRoaXMuJGVsZW1lbnQuZmluZCgnW2RhdGEtc2xpZGVyLWZpbGxdJykuY3NzKHRoaXMub3B0aW9ucy52ZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJywgMCk7XFxuXFxuICAgICAgICB2YXIgaXNEYmwgPSBmYWxzZSxcXG4gICAgICAgICAgICBfdGhpcyA9IHRoaXM7XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmRpc2FibGVkIHx8IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpKSB7XFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5kaXNhYmxlZCA9IHRydWU7XFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0cy5sZW5ndGgpIHtcXG4gICAgICAgICAgdGhpcy5pbnB1dHMgPSAkKCkuYWRkKHRoaXMuJGlucHV0KTtcXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmJpbmRpbmcgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy5fc2V0SW5pdEF0dHIoMCk7XFxuICAgICAgICB0aGlzLl9ldmVudHModGhpcy4kaGFuZGxlKTtcXG5cXG4gICAgICAgIGlmICh0aGlzLmhhbmRsZXNbMV0pIHtcXG4gICAgICAgICAgdGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkID0gdHJ1ZTtcXG4gICAgICAgICAgdGhpcy4kaGFuZGxlMiA9IHRoaXMuaGFuZGxlcy5lcSgxKTtcXG4gICAgICAgICAgdGhpcy4kaW5wdXQyID0gdGhpcy5pbnB1dHMubGVuZ3RoID4gMSA/IHRoaXMuaW5wdXRzLmVxKDEpIDogJCgnIycgKyB0aGlzLiRoYW5kbGUyLmF0dHIoJ2FyaWEtY29udHJvbHMnKSk7XFxuXFxuICAgICAgICAgIGlmICghdGhpcy5pbnB1dHNbMV0pIHtcXG4gICAgICAgICAgICB0aGlzLmlucHV0cyA9IHRoaXMuaW5wdXRzLmFkZCh0aGlzLiRpbnB1dDIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIGlzRGJsID0gdHJ1ZTtcXG5cXG4gICAgICAgICAgdGhpcy5fc2V0SGFuZGxlUG9zKHRoaXMuJGhhbmRsZSwgdGhpcy5vcHRpb25zLmluaXRpYWxTdGFydCwgdHJ1ZSwgZnVuY3Rpb24gKCkge1xcblxcbiAgICAgICAgICAgIF90aGlzLl9zZXRIYW5kbGVQb3MoX3RoaXMuJGhhbmRsZTIsIF90aGlzLm9wdGlvbnMuaW5pdGlhbEVuZCwgdHJ1ZSk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgICAvLyB0aGlzLiRoYW5kbGUudHJpZ2dlckhhbmRsZXIoJ2NsaWNrLnpmLnNsaWRlcicpO1xcbiAgICAgICAgICB0aGlzLl9zZXRJbml0QXR0cigxKTtcXG4gICAgICAgICAgdGhpcy5fZXZlbnRzKHRoaXMuJGhhbmRsZTIpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCFpc0RibCkge1xcbiAgICAgICAgICB0aGlzLl9zZXRIYW5kbGVQb3ModGhpcy4kaGFuZGxlLCB0aGlzLm9wdGlvbnMuaW5pdGlhbFN0YXJ0LCB0cnVlKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogU2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIHNlbGVjdGVkIGhhbmRsZSBhbmQgZmlsbCBiYXIuXFxuICAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGhuZGwgLSB0aGUgc2VsZWN0ZWQgaGFuZGxlIHRvIG1vdmUuXFxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IGxvY2F0aW9uIC0gZmxvYXRpbmcgcG9pbnQgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCB2YWx1ZXMgb2YgdGhlIHNsaWRlciBiYXIuXFxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBjYWxsYmFjayBmdW5jdGlvbiB0byBmaXJlIG9uIGNvbXBsZXRpb24uXFxuICAgICAgICogQGZpcmVzIFNsaWRlciNtb3ZlZFxcbiAgICAgICAqIEBmaXJlcyBTbGlkZXIjY2hhbmdlZFxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX3NldEhhbmRsZVBvcycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRIYW5kbGVQb3MoJGhuZGwsIGxvY2F0aW9uLCBub0ludmVydCwgY2IpIHtcXG4gICAgICAgIC8vIGRvbid0IG1vdmUgaWYgdGhlIHNsaWRlciBoYXMgYmVlbiBkaXNhYmxlZCBzaW5jZSBpdHMgaW5pdGlhbGl6YXRpb25cXG4gICAgICAgIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5kaXNhYmxlZENsYXNzKSkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuICAgICAgICAvL21pZ2h0IG5lZWQgdG8gYWx0ZXIgdGhhdCBzbGlnaHRseSBmb3IgYmFycyB0aGF0IHdpbGwgaGF2ZSBvZGQgbnVtYmVyIHNlbGVjdGlvbnMuXFxuICAgICAgICBsb2NhdGlvbiA9IHBhcnNlRmxvYXQobG9jYXRpb24pOyAvL29uIGlucHV0IGNoYW5nZSBldmVudHMsIGNvbnZlcnQgc3RyaW5nIHRvIG51bWJlci4uLmdydW1ibGUuXFxuXFxuICAgICAgICAvLyBwcmV2ZW50IHNsaWRlciBmcm9tIHJ1bm5pbmcgb3V0IG9mIGJvdW5kcywgaWYgdmFsdWUgZXhjZWVkcyB0aGUgbGltaXRzIHNldCB0aHJvdWdoIG9wdGlvbnMsIG92ZXJyaWRlIHRoZSB2YWx1ZSB0byBtaW4vbWF4XFxuICAgICAgICBpZiAobG9jYXRpb24gPCB0aGlzLm9wdGlvbnMuc3RhcnQpIHtcXG4gICAgICAgICAgbG9jYXRpb24gPSB0aGlzLm9wdGlvbnMuc3RhcnQ7XFxuICAgICAgICB9IGVsc2UgaWYgKGxvY2F0aW9uID4gdGhpcy5vcHRpb25zLmVuZCkge1xcbiAgICAgICAgICBsb2NhdGlvbiA9IHRoaXMub3B0aW9ucy5lbmQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgaXNEYmwgPSB0aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQ7XFxuXFxuICAgICAgICBpZiAoaXNEYmwpIHtcXG4gICAgICAgICAgLy90aGlzIGJsb2NrIGlzIHRvIHByZXZlbnQgMiBoYW5kbGVzIGZyb20gY3Jvc3NpbmcgZWFjaG90aGVyLiBDb3VsZC9zaG91bGQgYmUgaW1wcm92ZWQuXFxuICAgICAgICAgIGlmICh0aGlzLmhhbmRsZXMuaW5kZXgoJGhuZGwpID09PSAwKSB7XFxuICAgICAgICAgICAgdmFyIGgyVmFsID0gcGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUyLmF0dHIoJ2FyaWEtdmFsdWVub3cnKSk7XFxuICAgICAgICAgICAgbG9jYXRpb24gPSBsb2NhdGlvbiA+PSBoMlZhbCA/IGgyVmFsIC0gdGhpcy5vcHRpb25zLnN0ZXAgOiBsb2NhdGlvbjtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB2YXIgaDFWYWwgPSBwYXJzZUZsb2F0KHRoaXMuJGhhbmRsZS5hdHRyKCdhcmlhLXZhbHVlbm93JykpO1xcbiAgICAgICAgICAgIGxvY2F0aW9uID0gbG9jYXRpb24gPD0gaDFWYWwgPyBoMVZhbCArIHRoaXMub3B0aW9ucy5zdGVwIDogbG9jYXRpb247XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vdGhpcyBpcyBmb3Igc2luZ2xlLWhhbmRsZWQgdmVydGljYWwgc2xpZGVycywgaXQgYWRqdXN0cyB0aGUgdmFsdWUgdG8gYWNjb3VudCBmb3IgdGhlIHNsaWRlciBiZWluZyBcXFwidXBzaWRlLWRvd25cXFwiXFxuICAgICAgICAvL2ZvciBjbGljayBhbmQgZHJhZyBldmVudHMsIGl0J3Mgd2VpcmQgZHVlIHRvIHRoZSBzY2FsZSgtMSwgMSkgY3NzIHByb3BlcnR5XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnZlcnRpY2FsICYmICFub0ludmVydCkge1xcbiAgICAgICAgICBsb2NhdGlvbiA9IHRoaXMub3B0aW9ucy5lbmQgLSBsb2NhdGlvbjtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXMsXFxuICAgICAgICAgICAgdmVydCA9IHRoaXMub3B0aW9ucy52ZXJ0aWNhbCxcXG4gICAgICAgICAgICBoT3JXID0gdmVydCA/ICdoZWlnaHQnIDogJ3dpZHRoJyxcXG4gICAgICAgICAgICBsT3JUID0gdmVydCA/ICd0b3AnIDogJ2xlZnQnLFxcbiAgICAgICAgICAgIGhhbmRsZURpbSA9ICRobmRsWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2hPclddLFxcbiAgICAgICAgICAgIGVsZW1EaW0gPSB0aGlzLiRlbGVtZW50WzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2hPclddLFxcblxcbiAgICAgICAgLy9wZXJjZW50YWdlIG9mIGJhciBtaW4vbWF4IHZhbHVlIGJhc2VkIG9uIGNsaWNrIG9yIGRyYWcgcG9pbnRcXG4gICAgICAgIHBjdE9mQmFyID0gcGVyY2VudChsb2NhdGlvbiAtIHRoaXMub3B0aW9ucy5zdGFydCwgdGhpcy5vcHRpb25zLmVuZCAtIHRoaXMub3B0aW9ucy5zdGFydCkudG9GaXhlZCgyKSxcXG5cXG4gICAgICAgIC8vbnVtYmVyIG9mIGFjdHVhbCBwaXhlbHMgdG8gc2hpZnQgdGhlIGhhbmRsZSwgYmFzZWQgb24gdGhlIHBlcmNlbnRhZ2Ugb2J0YWluZWQgYWJvdmVcXG4gICAgICAgIHB4VG9Nb3ZlID0gKGVsZW1EaW0gLSBoYW5kbGVEaW0pICogcGN0T2ZCYXIsXFxuXFxuICAgICAgICAvL3BlcmNlbnRhZ2Ugb2YgYmFyIHRvIHNoaWZ0IHRoZSBoYW5kbGVcXG4gICAgICAgIG1vdmVtZW50ID0gKHBlcmNlbnQocHhUb01vdmUsIGVsZW1EaW0pICogMTAwKS50b0ZpeGVkKHRoaXMub3B0aW9ucy5kZWNpbWFsKTtcXG4gICAgICAgIC8vZml4aW5nIHRoZSBkZWNpbWFsIHZhbHVlIGZvciB0aGUgbG9jYXRpb24gbnVtYmVyLCBpcyBwYXNzZWQgdG8gb3RoZXIgbWV0aG9kcyBhcyBhIGZpeGVkIGZsb2F0aW5nLXBvaW50IHZhbHVlXFxuICAgICAgICBsb2NhdGlvbiA9IHBhcnNlRmxvYXQobG9jYXRpb24udG9GaXhlZCh0aGlzLm9wdGlvbnMuZGVjaW1hbCkpO1xcbiAgICAgICAgLy8gZGVjbGFyZSBlbXB0eSBvYmplY3QgZm9yIGNzcyBhZGp1c3RtZW50cywgb25seSB1c2VkIHdpdGggMiBoYW5kbGVkLXNsaWRlcnNcXG4gICAgICAgIHZhciBjc3MgPSB7fTtcXG5cXG4gICAgICAgIHRoaXMuX3NldFZhbHVlcygkaG5kbCwgbG9jYXRpb24pO1xcblxcbiAgICAgICAgLy8gVE9ETyB1cGRhdGUgdG8gY2FsY3VsYXRlIGJhc2VkIG9uIHZhbHVlcyBzZXQgdG8gcmVzcGVjdGl2ZSBpbnB1dHM/P1xcbiAgICAgICAgaWYgKGlzRGJsKSB7XFxuICAgICAgICAgIHZhciBpc0xlZnRIbmRsID0gdGhpcy5oYW5kbGVzLmluZGV4KCRobmRsKSA9PT0gMCxcXG5cXG4gICAgICAgICAgLy9lbXB0eSB2YXJpYWJsZSwgd2lsbCBiZSB1c2VkIGZvciBtaW4taGVpZ2h0L3dpZHRoIGZvciBmaWxsIGJhclxcbiAgICAgICAgICBkaW0sXFxuXFxuICAgICAgICAgIC8vcGVyY2VudGFnZSB3L2ggb2YgdGhlIGhhbmRsZSBjb21wYXJlZCB0byB0aGUgc2xpZGVyIGJhclxcbiAgICAgICAgICBoYW5kbGVQY3QgPSB+IH4ocGVyY2VudChoYW5kbGVEaW0sIGVsZW1EaW0pICogMTAwKTtcXG4gICAgICAgICAgLy9pZiBsZWZ0IGhhbmRsZSwgdGhlIG1hdGggaXMgc2xpZ2h0bHkgZGlmZmVyZW50IHRoYW4gaWYgaXQncyB0aGUgcmlnaHQgaGFuZGxlLCBhbmQgdGhlIGxlZnQvdG9wIHByb3BlcnR5IG5lZWRzIHRvIGJlIGNoYW5nZWQgZm9yIHRoZSBmaWxsIGJhclxcbiAgICAgICAgICBpZiAoaXNMZWZ0SG5kbCkge1xcbiAgICAgICAgICAgIC8vbGVmdCBvciB0b3AgcGVyY2VudGFnZSB2YWx1ZSB0byBhcHBseSB0byB0aGUgZmlsbCBiYXIuXFxuICAgICAgICAgICAgY3NzW2xPclRdID0gbW92ZW1lbnQgKyAnJSc7XFxuICAgICAgICAgICAgLy9jYWxjdWxhdGUgdGhlIG5ldyBtaW4taGVpZ2h0L3dpZHRoIGZvciB0aGUgZmlsbCBiYXIuXFxuICAgICAgICAgICAgZGltID0gcGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUyWzBdLnN0eWxlW2xPclRdKSAtIG1vdmVtZW50ICsgaGFuZGxlUGN0O1xcbiAgICAgICAgICAgIC8vdGhpcyBjYWxsYmFjayBpcyBuZWNlc3NhcnkgdG8gcHJldmVudCBlcnJvcnMgYW5kIGFsbG93IHRoZSBwcm9wZXIgcGxhY2VtZW50IGFuZCBpbml0aWFsaXphdGlvbiBvZiBhIDItaGFuZGxlZCBzbGlkZXJcXG4gICAgICAgICAgICAvL3BsdXMsIGl0IG1lYW5zIHdlIGRvbid0IGNhcmUgaWYgJ2RpbScgaXNOYU4gb24gaW5pdCwgaXQgd29uJ3QgYmUgaW4gdGhlIGZ1dHVyZS5cXG4gICAgICAgICAgICBpZiAoY2IgJiYgdHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICAgICAgICBjYigpO1xcbiAgICAgICAgICAgIH0gLy90aGlzIGlzIG9ubHkgbmVlZGVkIGZvciB0aGUgaW5pdGlhbGl6YXRpb24gb2YgMiBoYW5kbGVkIHNsaWRlcnNcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIC8vanVzdCBjYWNoaW5nIHRoZSB2YWx1ZSBvZiB0aGUgbGVmdC9ib3R0b20gaGFuZGxlJ3MgbGVmdC90b3AgcHJvcGVydHlcXG4gICAgICAgICAgICAgIHZhciBoYW5kbGVQb3MgPSBwYXJzZUZsb2F0KHRoaXMuJGhhbmRsZVswXS5zdHlsZVtsT3JUXSk7XFxuICAgICAgICAgICAgICAvL2NhbGN1bGF0ZSB0aGUgbmV3IG1pbi1oZWlnaHQvd2lkdGggZm9yIHRoZSBmaWxsIGJhci4gVXNlIGlzTmFOIHRvIHByZXZlbnQgZmFsc2UgcG9zaXRpdmVzIGZvciBudW1iZXJzIDw9IDBcXG4gICAgICAgICAgICAgIC8vYmFzZWQgb24gdGhlIHBlcmNlbnRhZ2Ugb2YgbW92ZW1lbnQgb2YgdGhlIGhhbmRsZSBiZWluZyBtYW5pcHVsYXRlZCwgbGVzcyB0aGUgb3Bwb3NpbmcgaGFuZGxlJ3MgbGVmdC90b3AgcG9zaXRpb24sIHBsdXMgdGhlIHBlcmNlbnRhZ2Ugdy9oIG9mIHRoZSBoYW5kbGUgaXRzZWxmXFxuICAgICAgICAgICAgICBkaW0gPSBtb3ZlbWVudCAtIChpc05hTihoYW5kbGVQb3MpID8gdGhpcy5vcHRpb25zLmluaXRpYWxTdGFydCAvICgodGhpcy5vcHRpb25zLmVuZCAtIHRoaXMub3B0aW9ucy5zdGFydCkgLyAxMDApIDogaGFuZGxlUG9zKSArIGhhbmRsZVBjdDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIC8vIGFzc2lnbiB0aGUgbWluLWhlaWdodC93aWR0aCB0byBvdXIgY3NzIG9iamVjdFxcbiAgICAgICAgICBjc3NbJ21pbi0nICsgaE9yV10gPSBkaW0gKyAnJSc7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9uZSgnZmluaXNoZWQuemYuYW5pbWF0ZScsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgLyoqXFxuICAgICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGhhbmRsZSBpcyBkb25lIG1vdmluZy5cXG4gICAgICAgICAgICogQGV2ZW50IFNsaWRlciNtb3ZlZFxcbiAgICAgICAgICAgKi9cXG4gICAgICAgICAgX3RoaXMuJGVsZW1lbnQudHJpZ2dlcignbW92ZWQuemYuc2xpZGVyJywgWyRobmRsXSk7XFxuICAgICAgICB9KTtcXG5cXG4gICAgICAgIC8vYmVjYXVzZSB3ZSBkb24ndCBrbm93IGV4YWN0bHkgaG93IHRoZSBoYW5kbGUgd2lsbCBiZSBtb3ZlZCwgY2hlY2sgdGhlIGFtb3VudCBvZiB0aW1lIGl0IHNob3VsZCB0YWtlIHRvIG1vdmUuXFxuICAgICAgICB2YXIgbW92ZVRpbWUgPSB0aGlzLiRlbGVtZW50LmRhdGEoJ2RyYWdnaW5nJykgPyAxMDAwIC8gNjAgOiB0aGlzLm9wdGlvbnMubW92ZVRpbWU7XFxuXFxuICAgICAgICBGb3VuZGF0aW9uLk1vdmUobW92ZVRpbWUsICRobmRsLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIC8vYWRqdXN0aW5nIHRoZSBsZWZ0L3RvcCBwcm9wZXJ0eSBvZiB0aGUgaGFuZGxlLCBiYXNlZCBvbiB0aGUgcGVyY2VudGFnZSBjYWxjdWxhdGVkIGFib3ZlXFxuICAgICAgICAgICRobmRsLmNzcyhsT3JULCBtb3ZlbWVudCArICclJyk7XFxuXFxuICAgICAgICAgIGlmICghX3RoaXMub3B0aW9ucy5kb3VibGVTaWRlZCkge1xcbiAgICAgICAgICAgIC8vaWYgc2luZ2xlLWhhbmRsZWQsIGEgc2ltcGxlIG1ldGhvZCB0byBleHBhbmQgdGhlIGZpbGwgYmFyXFxuICAgICAgICAgICAgX3RoaXMuJGZpbGwuY3NzKGhPclcsIHBjdE9mQmFyICogMTAwICsgJyUnKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAvL290aGVyd2lzZSwgdXNlIHRoZSBjc3Mgb2JqZWN0IHdlIGNyZWF0ZWQgYWJvdmVcXG4gICAgICAgICAgICBfdGhpcy4kZmlsbC5jc3MoY3NzKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHZhbHVlIGhhcyBub3QgYmVlbiBjaGFuZ2UgZm9yIGEgZ2l2ZW4gdGltZS5cXG4gICAgICAgICAqIEBldmVudCBTbGlkZXIjY2hhbmdlZFxcbiAgICAgICAgICovXFxuICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XFxuICAgICAgICBfdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIF90aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2NoYW5nZWQuemYuc2xpZGVyJywgWyRobmRsXSk7XFxuICAgICAgICB9LCBfdGhpcy5vcHRpb25zLmNoYW5nZWREZWxheSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIFNldHMgdGhlIGluaXRpYWwgYXR0cmlidXRlIGZvciB0aGUgc2xpZGVyIGVsZW1lbnQuXFxuICAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKiBAcGFyYW0ge051bWJlcn0gaWR4IC0gaW5kZXggb2YgdGhlIGN1cnJlbnQgaGFuZGxlL2lucHV0IHRvIHVzZS5cXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ19zZXRJbml0QXR0cicsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRJbml0QXR0cihpZHgpIHtcXG4gICAgICAgIHZhciBpZCA9IHRoaXMuaW5wdXRzLmVxKGlkeCkuYXR0cignaWQnKSB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsICdzbGlkZXInKTtcXG4gICAgICAgIHRoaXMuaW5wdXRzLmVxKGlkeCkuYXR0cih7XFxuICAgICAgICAgICdpZCc6IGlkLFxcbiAgICAgICAgICAnbWF4JzogdGhpcy5vcHRpb25zLmVuZCxcXG4gICAgICAgICAgJ21pbic6IHRoaXMub3B0aW9ucy5zdGFydCxcXG4gICAgICAgICAgJ3N0ZXAnOiB0aGlzLm9wdGlvbnMuc3RlcFxcbiAgICAgICAgfSk7XFxuICAgICAgICB0aGlzLmhhbmRsZXMuZXEoaWR4KS5hdHRyKHtcXG4gICAgICAgICAgJ3JvbGUnOiAnc2xpZGVyJyxcXG4gICAgICAgICAgJ2FyaWEtY29udHJvbHMnOiBpZCxcXG4gICAgICAgICAgJ2FyaWEtdmFsdWVtYXgnOiB0aGlzLm9wdGlvbnMuZW5kLFxcbiAgICAgICAgICAnYXJpYS12YWx1ZW1pbic6IHRoaXMub3B0aW9ucy5zdGFydCxcXG4gICAgICAgICAgJ2FyaWEtdmFsdWVub3cnOiBpZHggPT09IDAgPyB0aGlzLm9wdGlvbnMuaW5pdGlhbFN0YXJ0IDogdGhpcy5vcHRpb25zLmluaXRpYWxFbmQsXFxuICAgICAgICAgICdhcmlhLW9yaWVudGF0aW9uJzogdGhpcy5vcHRpb25zLnZlcnRpY2FsID8gJ3ZlcnRpY2FsJyA6ICdob3Jpem9udGFsJyxcXG4gICAgICAgICAgJ3RhYmluZGV4JzogMFxcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIFNldHMgdGhlIGlucHV0IGFuZCBgYXJpYS12YWx1ZW5vd2AgdmFsdWVzIGZvciB0aGUgc2xpZGVyIGVsZW1lbnQuXFxuICAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKiBAcGFyYW0ge2pRdWVyeX0gJGhhbmRsZSAtIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgaGFuZGxlLlxcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWwgLSBmbG9hdGluZyBwb2ludCBvZiB0aGUgbmV3IHZhbHVlLlxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX3NldFZhbHVlcycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRWYWx1ZXMoJGhhbmRsZSwgdmFsKSB7XFxuICAgICAgICB2YXIgaWR4ID0gdGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkID8gdGhpcy5oYW5kbGVzLmluZGV4KCRoYW5kbGUpIDogMDtcXG4gICAgICAgIHRoaXMuaW5wdXRzLmVxKGlkeCkudmFsKHZhbCk7XFxuICAgICAgICAkaGFuZGxlLmF0dHIoJ2FyaWEtdmFsdWVub3cnLCB2YWwpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBIYW5kbGVzIGV2ZW50cyBvbiB0aGUgc2xpZGVyIGVsZW1lbnQuXFxuICAgICAgICogQ2FsY3VsYXRlcyB0aGUgbmV3IGxvY2F0aW9uIG9mIHRoZSBjdXJyZW50IGhhbmRsZS5cXG4gICAgICAgKiBJZiB0aGVyZSBhcmUgdHdvIGhhbmRsZXMgYW5kIHRoZSBiYXIgd2FzIGNsaWNrZWQsIGl0IGRldGVybWluZXMgd2hpY2ggaGFuZGxlIHRvIG1vdmUuXFxuICAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKiBAcGFyYW0ge09iamVjdH0gZSAtIHRoZSBgZXZlbnRgIG9iamVjdCBwYXNzZWQgZnJvbSB0aGUgbGlzdGVuZXIuXFxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9ICRoYW5kbGUgLSB0aGUgY3VycmVudCBoYW5kbGUgdG8gY2FsY3VsYXRlIGZvciwgaWYgc2VsZWN0ZWQuXFxuICAgICAgICogQHBhcmFtIHtOdW1iZXJ9IHZhbCAtIGZsb2F0aW5nIHBvaW50IG51bWJlciBmb3IgdGhlIG5ldyB2YWx1ZSBvZiB0aGUgc2xpZGVyLlxcbiAgICAgICAqIFRPRE8gY2xlYW4gdGhpcyB1cCwgdGhlcmUncyBhIGxvdCBvZiByZXBlYXRlZCBjb2RlIGJldHdlZW4gdGhpcyBhbmQgdGhlIF9zZXRIYW5kbGVQb3MgZm4uXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfaGFuZGxlRXZlbnQnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlRXZlbnQoZSwgJGhhbmRsZSwgdmFsKSB7XFxuICAgICAgICB2YXIgdmFsdWUsIGhhc1ZhbDtcXG4gICAgICAgIGlmICghdmFsKSB7XFxuICAgICAgICAgIC8vY2xpY2sgb3IgZHJhZyBldmVudHNcXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzLFxcbiAgICAgICAgICAgICAgdmVydGljYWwgPSB0aGlzLm9wdGlvbnMudmVydGljYWwsXFxuICAgICAgICAgICAgICBwYXJhbSA9IHZlcnRpY2FsID8gJ2hlaWdodCcgOiAnd2lkdGgnLFxcbiAgICAgICAgICAgICAgZGlyZWN0aW9uID0gdmVydGljYWwgPyAndG9wJyA6ICdsZWZ0JyxcXG4gICAgICAgICAgICAgIGV2ZW50T2Zmc2V0ID0gdmVydGljYWwgPyBlLnBhZ2VZIDogZS5wYWdlWCxcXG4gICAgICAgICAgICAgIGhhbGZPZkhhbmRsZSA9IHRoaXMuJGhhbmRsZVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtwYXJhbV0gLyAyLFxcbiAgICAgICAgICAgICAgYmFyRGltID0gdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtwYXJhbV0sXFxuICAgICAgICAgICAgICB3aW5kb3dTY3JvbGwgPSB2ZXJ0aWNhbCA/ICQod2luZG93KS5zY3JvbGxUb3AoKSA6ICQod2luZG93KS5zY3JvbGxMZWZ0KCk7XFxuXFxuICAgICAgICAgIHZhciBlbGVtT2Zmc2V0ID0gdGhpcy4kZWxlbWVudC5vZmZzZXQoKVtkaXJlY3Rpb25dO1xcblxcbiAgICAgICAgICAvLyB0b3VjaCBldmVudHMgZW11bGF0ZWQgYnkgdGhlIHRvdWNoIHV0aWwgZ2l2ZSBwb3NpdGlvbiByZWxhdGl2ZSB0byBzY3JlZW4sIGFkZCB3aW5kb3cuc2Nyb2xsIHRvIGV2ZW50IGNvb3JkaW5hdGVzLi4uXFxuICAgICAgICAgIC8vIGJlc3Qgd2F5IHRvIGd1ZXNzIHRoaXMgaXMgc2ltdWxhdGVkIGlzIGlmIGNsaWVudFkgPT0gcGFnZVlcXG4gICAgICAgICAgaWYgKGUuY2xpZW50WSA9PT0gZS5wYWdlWSkge1xcbiAgICAgICAgICAgIGV2ZW50T2Zmc2V0ID0gZXZlbnRPZmZzZXQgKyB3aW5kb3dTY3JvbGw7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgdmFyIGV2ZW50RnJvbUJhciA9IGV2ZW50T2Zmc2V0IC0gZWxlbU9mZnNldDtcXG4gICAgICAgICAgdmFyIGJhclhZO1xcbiAgICAgICAgICBpZiAoZXZlbnRGcm9tQmFyIDwgMCkge1xcbiAgICAgICAgICAgIGJhclhZID0gMDtcXG4gICAgICAgICAgfSBlbHNlIGlmIChldmVudEZyb21CYXIgPiBiYXJEaW0pIHtcXG4gICAgICAgICAgICBiYXJYWSA9IGJhckRpbTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBiYXJYWSA9IGV2ZW50RnJvbUJhcjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBvZmZzZXRQY3QgPSBwZXJjZW50KGJhclhZLCBiYXJEaW0pO1xcblxcbiAgICAgICAgICB2YWx1ZSA9ICh0aGlzLm9wdGlvbnMuZW5kIC0gdGhpcy5vcHRpb25zLnN0YXJ0KSAqIG9mZnNldFBjdCArIHRoaXMub3B0aW9ucy5zdGFydDtcXG5cXG4gICAgICAgICAgLy8gdHVybiBldmVyeXRoaW5nIGFyb3VuZCBmb3IgUlRMLCB5YXkgbWF0aCFcXG4gICAgICAgICAgaWYgKEZvdW5kYXRpb24ucnRsKCkgJiYgIXRoaXMub3B0aW9ucy52ZXJ0aWNhbCkge1xcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5vcHRpb25zLmVuZCAtIHZhbHVlO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHZhbHVlID0gX3RoaXMuX2FkanVzdFZhbHVlKG51bGwsIHZhbHVlKTtcXG4gICAgICAgICAgLy9ib29sZWFuIGZsYWcgZm9yIHRoZSBzZXRIYW5kbGVQb3MgZm4sIHNwZWNpZmljYWxseSBmb3IgdmVydGljYWwgc2xpZGVyc1xcbiAgICAgICAgICBoYXNWYWwgPSBmYWxzZTtcXG5cXG4gICAgICAgICAgaWYgKCEkaGFuZGxlKSB7XFxuICAgICAgICAgICAgLy9maWd1cmUgb3V0IHdoaWNoIGhhbmRsZSBpdCBpcywgcGFzcyBpdCB0byB0aGUgbmV4dCBmdW5jdGlvbi5cXG4gICAgICAgICAgICB2YXIgZmlyc3RIbmRsUG9zID0gYWJzUG9zaXRpb24odGhpcy4kaGFuZGxlLCBkaXJlY3Rpb24sIGJhclhZLCBwYXJhbSksXFxuICAgICAgICAgICAgICAgIHNlY25kSG5kbFBvcyA9IGFic1Bvc2l0aW9uKHRoaXMuJGhhbmRsZTIsIGRpcmVjdGlvbiwgYmFyWFksIHBhcmFtKTtcXG4gICAgICAgICAgICAkaGFuZGxlID0gZmlyc3RIbmRsUG9zIDw9IHNlY25kSG5kbFBvcyA/IHRoaXMuJGhhbmRsZSA6IHRoaXMuJGhhbmRsZTI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vY2hhbmdlIGV2ZW50IG9uIGlucHV0XFxuICAgICAgICAgIHZhbHVlID0gdGhpcy5fYWRqdXN0VmFsdWUobnVsbCwgdmFsKTtcXG4gICAgICAgICAgaGFzVmFsID0gdHJ1ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX3NldEhhbmRsZVBvcygkaGFuZGxlLCB2YWx1ZSwgaGFzVmFsKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogQWRqdXN0ZXMgdmFsdWUgZm9yIGhhbmRsZSBpbiByZWdhcmQgdG8gc3RlcCB2YWx1ZS4gcmV0dXJucyBhZGp1c3RlZCB2YWx1ZVxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9ICRoYW5kbGUgLSB0aGUgc2VsZWN0ZWQgaGFuZGxlLlxcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSB2YWx1ZSAtIHZhbHVlIHRvIGFkanVzdC4gdXNlZCBpZiAkaGFuZGxlIGlzIGZhbHN5XFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfYWRqdXN0VmFsdWUnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRqdXN0VmFsdWUoJGhhbmRsZSwgdmFsdWUpIHtcXG4gICAgICAgIHZhciB2YWwsXFxuICAgICAgICAgICAgc3RlcCA9IHRoaXMub3B0aW9ucy5zdGVwLFxcbiAgICAgICAgICAgIGRpdiA9IHBhcnNlRmxvYXQoc3RlcCAvIDIpLFxcbiAgICAgICAgICAgIGxlZnQsXFxuICAgICAgICAgICAgcHJldl92YWwsXFxuICAgICAgICAgICAgbmV4dF92YWw7XFxuICAgICAgICBpZiAoISEkaGFuZGxlKSB7XFxuICAgICAgICAgIHZhbCA9IHBhcnNlRmxvYXQoJGhhbmRsZS5hdHRyKCdhcmlhLXZhbHVlbm93JykpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdmFsID0gdmFsdWU7XFxuICAgICAgICB9XFxuICAgICAgICBsZWZ0ID0gdmFsICUgc3RlcDtcXG4gICAgICAgIHByZXZfdmFsID0gdmFsIC0gbGVmdDtcXG4gICAgICAgIG5leHRfdmFsID0gcHJldl92YWwgKyBzdGVwO1xcbiAgICAgICAgaWYgKGxlZnQgPT09IDApIHtcXG4gICAgICAgICAgcmV0dXJuIHZhbDtcXG4gICAgICAgIH1cXG4gICAgICAgIHZhbCA9IHZhbCA+PSBwcmV2X3ZhbCArIGRpdiA/IG5leHRfdmFsIDogcHJldl92YWw7XFxuICAgICAgICByZXR1cm4gdmFsO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBBZGRzIGV2ZW50IGxpc3RlbmVycyB0byB0aGUgc2xpZGVyIGVsZW1lbnRzLlxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9ICRoYW5kbGUgLSB0aGUgY3VycmVudCBoYW5kbGUgdG8gYXBwbHkgbGlzdGVuZXJzIHRvLlxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX2V2ZW50cycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoJGhhbmRsZSkge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcyxcXG4gICAgICAgICAgICBjdXJIYW5kbGUsXFxuICAgICAgICAgICAgdGltZXI7XFxuXFxuICAgICAgICB0aGlzLmlucHV0cy5vZmYoJ2NoYW5nZS56Zi5zbGlkZXInKS5vbignY2hhbmdlLnpmLnNsaWRlcicsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIHZhciBpZHggPSBfdGhpcy5pbnB1dHMuaW5kZXgoJCh0aGlzKSk7XFxuICAgICAgICAgIF90aGlzLl9oYW5kbGVFdmVudChlLCBfdGhpcy5oYW5kbGVzLmVxKGlkeCksICQodGhpcykudmFsKCkpO1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmNsaWNrU2VsZWN0KSB7XFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdjbGljay56Zi5zbGlkZXInKS5vbignY2xpY2suemYuc2xpZGVyJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBpZiAoX3RoaXMuJGVsZW1lbnQuZGF0YSgnZHJhZ2dpbmcnKSkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAoISQoZS50YXJnZXQpLmlzKCdbZGF0YS1zbGlkZXItaGFuZGxlXScpKSB7XFxuICAgICAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5kb3VibGVTaWRlZCkge1xcbiAgICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlRXZlbnQoZSk7XFxuICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlRXZlbnQoZSwgX3RoaXMuJGhhbmRsZSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZHJhZ2dhYmxlKSB7XFxuICAgICAgICAgIHRoaXMuaGFuZGxlcy5hZGRUb3VjaCgpO1xcblxcbiAgICAgICAgICB2YXIgJGJvZHkgPSAkKCdib2R5Jyk7XFxuICAgICAgICAgICRoYW5kbGUub2ZmKCdtb3VzZWRvd24uemYuc2xpZGVyJykub24oJ21vdXNlZG93bi56Zi5zbGlkZXInLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgICRoYW5kbGUuYWRkQ2xhc3MoJ2lzLWRyYWdnaW5nJyk7XFxuICAgICAgICAgICAgX3RoaXMuJGZpbGwuYWRkQ2xhc3MoJ2lzLWRyYWdnaW5nJyk7IC8vXFxuICAgICAgICAgICAgX3RoaXMuJGVsZW1lbnQuZGF0YSgnZHJhZ2dpbmcnLCB0cnVlKTtcXG5cXG4gICAgICAgICAgICBjdXJIYW5kbGUgPSAkKGUuY3VycmVudFRhcmdldCk7XFxuXFxuICAgICAgICAgICAgJGJvZHkub24oJ21vdXNlbW92ZS56Zi5zbGlkZXInLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICAgICAgX3RoaXMuX2hhbmRsZUV2ZW50KGUsIGN1ckhhbmRsZSk7XFxuICAgICAgICAgICAgfSkub24oJ21vdXNldXAuemYuc2xpZGVyJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVFdmVudChlLCBjdXJIYW5kbGUpO1xcblxcbiAgICAgICAgICAgICAgJGhhbmRsZS5yZW1vdmVDbGFzcygnaXMtZHJhZ2dpbmcnKTtcXG4gICAgICAgICAgICAgIF90aGlzLiRmaWxsLnJlbW92ZUNsYXNzKCdpcy1kcmFnZ2luZycpO1xcbiAgICAgICAgICAgICAgX3RoaXMuJGVsZW1lbnQuZGF0YSgnZHJhZ2dpbmcnLCBmYWxzZSk7XFxuXFxuICAgICAgICAgICAgICAkYm9keS5vZmYoJ21vdXNlbW92ZS56Zi5zbGlkZXIgbW91c2V1cC56Zi5zbGlkZXInKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSlcXG4gICAgICAgICAgLy8gcHJldmVudCBldmVudHMgdHJpZ2dlcmVkIGJ5IHRvdWNoXFxuICAgICAgICAgIC5vbignc2VsZWN0c3RhcnQuemYuc2xpZGVyIHRvdWNobW92ZS56Zi5zbGlkZXInLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAkaGFuZGxlLm9mZigna2V5ZG93bi56Zi5zbGlkZXInKS5vbigna2V5ZG93bi56Zi5zbGlkZXInLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICB2YXIgXyRoYW5kbGUgPSAkKHRoaXMpLFxcbiAgICAgICAgICAgICAgaWR4ID0gX3RoaXMub3B0aW9ucy5kb3VibGVTaWRlZCA/IF90aGlzLmhhbmRsZXMuaW5kZXgoXyRoYW5kbGUpIDogMCxcXG4gICAgICAgICAgICAgIG9sZFZhbHVlID0gcGFyc2VGbG9hdChfdGhpcy5pbnB1dHMuZXEoaWR4KS52YWwoKSksXFxuICAgICAgICAgICAgICBuZXdWYWx1ZTtcXG5cXG4gICAgICAgICAgLy8gaGFuZGxlIGtleWJvYXJkIGV2ZW50IHdpdGgga2V5Ym9hcmQgdXRpbFxcbiAgICAgICAgICBGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLCAnU2xpZGVyJywge1xcbiAgICAgICAgICAgIGRlY3JlYXNlOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG9sZFZhbHVlIC0gX3RoaXMub3B0aW9ucy5zdGVwO1xcbiAgICAgICAgICAgIH0sXFxuICAgICAgICAgICAgaW5jcmVhc2U6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIG5ld1ZhbHVlID0gb2xkVmFsdWUgKyBfdGhpcy5vcHRpb25zLnN0ZXA7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBkZWNyZWFzZV9mYXN0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG9sZFZhbHVlIC0gX3RoaXMub3B0aW9ucy5zdGVwICogMTA7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBpbmNyZWFzZV9mYXN0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBuZXdWYWx1ZSA9IG9sZFZhbHVlICsgX3RoaXMub3B0aW9ucy5zdGVwICogMTA7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBoYW5kbGVkOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAvLyBvbmx5IHNldCBoYW5kbGUgcG9zIHdoZW4gZXZlbnQgd2FzIGhhbmRsZWQgc3BlY2lhbGx5XFxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgICBfdGhpcy5fc2V0SGFuZGxlUG9zKF8kaGFuZGxlLCBuZXdWYWx1ZSwgdHJ1ZSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgLyppZiAobmV3VmFsdWUpIHsgLy8gaWYgcHJlc3NlZCBrZXkgaGFzIHNwZWNpYWwgZnVuY3Rpb24sIHVwZGF0ZSB2YWx1ZVxcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICBfdGhpcy5fc2V0SGFuZGxlUG9zKF8kaGFuZGxlLCBuZXdWYWx1ZSk7XFxuICAgICAgICAgIH0qL1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIERlc3Ryb3lzIHRoZSBzbGlkZXIgcGx1Z2luLlxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnZGVzdHJveScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuICAgICAgICB0aGlzLmhhbmRsZXMub2ZmKCcuemYuc2xpZGVyJyk7XFxuICAgICAgICB0aGlzLmlucHV0cy5vZmYoJy56Zi5zbGlkZXInKTtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYuc2xpZGVyJyk7XFxuXFxuICAgICAgICBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XFxuICAgICAgfVxcbiAgICB9XSk7XFxuXFxuICAgIHJldHVybiBTbGlkZXI7XFxuICB9KCk7XFxuXFxuICBTbGlkZXIuZGVmYXVsdHMgPSB7XFxuICAgIC8qKlxcbiAgICAgKiBNaW5pbXVtIHZhbHVlIGZvciB0aGUgc2xpZGVyIHNjYWxlLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIDBcXG4gICAgICovXFxuICAgIHN0YXJ0OiAwLFxcbiAgICAvKipcXG4gICAgICogTWF4aW11bSB2YWx1ZSBmb3IgdGhlIHNsaWRlciBzY2FsZS5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAxMDBcXG4gICAgICovXFxuICAgIGVuZDogMTAwLFxcbiAgICAvKipcXG4gICAgICogTWluaW11bSB2YWx1ZSBjaGFuZ2UgcGVyIGNoYW5nZSBldmVudC5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAxXFxuICAgICAqL1xcbiAgICBzdGVwOiAxLFxcbiAgICAvKipcXG4gICAgICogVmFsdWUgYXQgd2hpY2ggdGhlIGhhbmRsZS9pbnB1dCAqKGxlZnQgaGFuZGxlL2ZpcnN0IGlucHV0KSogc2hvdWxkIGJlIHNldCB0byBvbiBpbml0aWFsaXphdGlvbi5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAwXFxuICAgICAqL1xcbiAgICBpbml0aWFsU3RhcnQ6IDAsXFxuICAgIC8qKlxcbiAgICAgKiBWYWx1ZSBhdCB3aGljaCB0aGUgcmlnaHQgaGFuZGxlL3NlY29uZCBpbnB1dCBzaG91bGQgYmUgc2V0IHRvIG9uIGluaXRpYWxpemF0aW9uLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIDEwMFxcbiAgICAgKi9cXG4gICAgaW5pdGlhbEVuZDogMTAwLFxcbiAgICAvKipcXG4gICAgICogQWxsb3dzIHRoZSBpbnB1dCB0byBiZSBsb2NhdGVkIG91dHNpZGUgdGhlIGNvbnRhaW5lciBhbmQgdmlzaWJsZS4gU2V0IHRvIGJ5IHRoZSBKU1xcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIGZhbHNlXFxuICAgICAqL1xcbiAgICBiaW5kaW5nOiBmYWxzZSxcXG4gICAgLyoqXFxuICAgICAqIEFsbG93cyB0aGUgdXNlciB0byBjbGljay90YXAgb24gdGhlIHNsaWRlciBiYXIgdG8gc2VsZWN0IGEgdmFsdWUuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxcbiAgICAgKi9cXG4gICAgY2xpY2tTZWxlY3Q6IHRydWUsXFxuICAgIC8qKlxcbiAgICAgKiBTZXQgdG8gdHJ1ZSBhbmQgdXNlIHRoZSBgdmVydGljYWxgIGNsYXNzIHRvIGNoYW5nZSBhbGlnbm1lbnQgdG8gdmVydGljYWwuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgZmFsc2VcXG4gICAgICovXFxuICAgIHZlcnRpY2FsOiBmYWxzZSxcXG4gICAgLyoqXFxuICAgICAqIEFsbG93cyB0aGUgdXNlciB0byBkcmFnIHRoZSBzbGlkZXIgaGFuZGxlKHMpIHRvIHNlbGVjdCBhIHZhbHVlLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIHRydWVcXG4gICAgICovXFxuICAgIGRyYWdnYWJsZTogdHJ1ZSxcXG4gICAgLyoqXFxuICAgICAqIERpc2FibGVzIHRoZSBzbGlkZXIgYW5kIHByZXZlbnRzIGV2ZW50IGxpc3RlbmVycyBmcm9tIGJlaW5nIGFwcGxpZWQuIERvdWJsZSBjaGVja2VkIGJ5IEpTIHdpdGggYGRpc2FibGVkQ2xhc3NgLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIGZhbHNlXFxuICAgICAqL1xcbiAgICBkaXNhYmxlZDogZmFsc2UsXFxuICAgIC8qKlxcbiAgICAgKiBBbGxvd3MgdGhlIHVzZSBvZiB0d28gaGFuZGxlcy4gRG91YmxlIGNoZWNrZWQgYnkgdGhlIEpTLiBDaGFuZ2VzIHNvbWUgbG9naWMgaGFuZGxpbmcuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgZmFsc2VcXG4gICAgICovXFxuICAgIGRvdWJsZVNpZGVkOiBmYWxzZSxcXG4gICAgLyoqXFxuICAgICAqIFBvdGVudGlhbCBmdXR1cmUgZmVhdHVyZS5cXG4gICAgICovXFxuICAgIC8vIHN0ZXBzOiAxMDAsXFxuICAgIC8qKlxcbiAgICAgKiBOdW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgdGhlIHBsdWdpbiBzaG91bGQgZ28gdG8gZm9yIGZsb2F0aW5nIHBvaW50IHByZWNpc2lvbi5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAyXFxuICAgICAqL1xcbiAgICBkZWNpbWFsOiAyLFxcbiAgICAvKipcXG4gICAgICogVGltZSBkZWxheSBmb3IgZHJhZ2dlZCBlbGVtZW50cy5cXG4gICAgICovXFxuICAgIC8vIGRyYWdEZWxheTogMCxcXG4gICAgLyoqXFxuICAgICAqIFRpbWUsIGluIG1zLCB0byBhbmltYXRlIHRoZSBtb3ZlbWVudCBvZiBhIHNsaWRlciBoYW5kbGUgaWYgdXNlciBjbGlja3MvdGFwcyBvbiB0aGUgYmFyLiBOZWVkcyB0byBiZSBtYW51YWxseSBzZXQgaWYgdXBkYXRpbmcgdGhlIHRyYW5zaXRpb24gdGltZSBpbiB0aGUgU2FzcyBzZXR0aW5ncy5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAyMDBcXG4gICAgICovXFxuICAgIG1vdmVUaW1lOiAyMDAsIC8vdXBkYXRlIHRoaXMgaWYgY2hhbmdpbmcgdGhlIHRyYW5zaXRpb24gdGltZSBpbiB0aGUgc2Fzc1xcbiAgICAvKipcXG4gICAgICogQ2xhc3MgYXBwbGllZCB0byBkaXNhYmxlZCBzbGlkZXJzLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlICdkaXNhYmxlZCdcXG4gICAgICovXFxuICAgIGRpc2FibGVkQ2xhc3M6ICdkaXNhYmxlZCcsXFxuICAgIC8qKlxcbiAgICAgKiBXaWxsIGludmVydCB0aGUgZGVmYXVsdCBsYXlvdXQgZm9yIGEgdmVydGljYWw8c3BhbiBkYXRhLXRvb2x0aXAgdGl0bGU9XFxcIndobyB3b3VsZCBkbyB0aGlzPz8/XFxcIj4gPC9zcGFuPnNsaWRlci5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSBmYWxzZVxcbiAgICAgKi9cXG4gICAgaW52ZXJ0VmVydGljYWw6IGZhbHNlLFxcbiAgICAvKipcXG4gICAgICogTWlsbGlzZWNvbmRzIGJlZm9yZSB0aGUgYGNoYW5nZWQuemYtc2xpZGVyYCBldmVudCBpcyB0cmlnZ2VyZWQgYWZ0ZXIgdmFsdWUgY2hhbmdlLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIDUwMFxcbiAgICAgKi9cXG4gICAgY2hhbmdlZERlbGF5OiA1MDBcXG4gIH07XFxuXFxuICBmdW5jdGlvbiBwZXJjZW50KGZyYWMsIG51bSkge1xcbiAgICByZXR1cm4gZnJhYyAvIG51bTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGFic1Bvc2l0aW9uKCRoYW5kbGUsIGRpciwgY2xpY2tQb3MsIHBhcmFtKSB7XFxuICAgIHJldHVybiBNYXRoLmFicygkaGFuZGxlLnBvc2l0aW9uKClbZGlyXSArICRoYW5kbGVbcGFyYW1dKCkgLyAyIC0gY2xpY2tQb3MpO1xcbiAgfVxcblxcbiAgLy8gV2luZG93IGV4cG9ydHNcXG4gIEZvdW5kYXRpb24ucGx1Z2luKFNsaWRlciwgJ1NsaWRlcicpO1xcbn0oalF1ZXJ5KTtcXG5cXG4vLyoqKioqKioqKnRoaXMgaXMgaW4gY2FzZSB3ZSBnbyB0byBzdGF0aWMsIGFic29sdXRlIHBvc2l0aW9ucyBpbnN0ZWFkIG9mIGR5bmFtaWMgcG9zaXRpb25pbmcqKioqKioqKlxcbi8vIHRoaXMuc2V0U3RlcHMoZnVuY3Rpb24oKSB7XFxuLy8gICBfdGhpcy5fZXZlbnRzKCk7XFxuLy8gICB2YXIgaW5pdFN0YXJ0ID0gX3RoaXMub3B0aW9ucy5wb3NpdGlvbnNbX3RoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQgLSAxXSB8fCBudWxsO1xcbi8vICAgdmFyIGluaXRFbmQgPSBfdGhpcy5vcHRpb25zLmluaXRpYWxFbmQgPyBfdGhpcy5vcHRpb25zLnBvc2l0aW9uW190aGlzLm9wdGlvbnMuaW5pdGlhbEVuZCAtIDFdIDogbnVsbDtcXG4vLyAgIGlmIChpbml0U3RhcnQgfHwgaW5pdEVuZCkge1xcbi8vICAgICBfdGhpcy5faGFuZGxlRXZlbnQoaW5pdFN0YXJ0LCBpbml0RW5kKTtcXG4vLyAgIH1cXG4vLyB9KTtcXG5cXG4vLyoqKioqKioqKioqdGhlIG90aGVyIHBhcnQgb2YgYWJzb2x1dGUgcG9zaXRpb25zKioqKioqKioqKioqKlxcbi8vIFNsaWRlci5wcm90b3R5cGUuc2V0U3RlcHMgPSBmdW5jdGlvbihjYikge1xcbi8vICAgdmFyIHBvc0NoYW5nZSA9IHRoaXMuJGVsZW1lbnQub3V0ZXJXaWR0aCgpIC8gdGhpcy5vcHRpb25zLnN0ZXBzO1xcbi8vICAgdmFyIGNvdW50ZXIgPSAwXFxuLy8gICB3aGlsZShjb3VudGVyIDwgdGhpcy5vcHRpb25zLnN0ZXBzKSB7XFxuLy8gICAgIGlmIChjb3VudGVyKSB7XFxuLy8gICAgICAgdGhpcy5vcHRpb25zLnBvc2l0aW9ucy5wdXNoKHRoaXMub3B0aW9ucy5wb3NpdGlvbnNbY291bnRlciAtIDFdICsgcG9zQ2hhbmdlKTtcXG4vLyAgICAgfSBlbHNlIHtcXG4vLyAgICAgICB0aGlzLm9wdGlvbnMucG9zaXRpb25zLnB1c2gocG9zQ2hhbmdlKTtcXG4vLyAgICAgfVxcbi8vICAgICBjb3VudGVyKys7XFxuLy8gICB9XFxuLy8gICBjYigpO1xcbi8vIH07XFxuJ3VzZSBzdHJpY3QnO1xcblxcbnZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXFxcInZhbHVlXFxcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpOyB9IH0gcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTsgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfTsgfSgpO1xcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbiFmdW5jdGlvbiAoJCkge1xcblxcbiAgLyoqXFxuICAgKiBTdGlja3kgbW9kdWxlLlxcbiAgICogQG1vZHVsZSBmb3VuZGF0aW9uLnN0aWNreVxcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50cmlnZ2Vyc1xcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tZWRpYVF1ZXJ5XFxuICAgKi9cXG5cXG4gIHZhciBTdGlja3kgPSBmdW5jdGlvbiAoKSB7XFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgc3RpY2t5IHRoaW5nLlxcbiAgICAgKiBAY2xhc3NcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIG1ha2Ugc3RpY2t5LlxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIG9wdGlvbnMgb2JqZWN0IHBhc3NlZCB3aGVuIGNyZWF0aW5nIHRoZSBlbGVtZW50IHByb2dyYW1tYXRpY2FsbHkuXFxuICAgICAqL1xcblxcbiAgICBmdW5jdGlvbiBTdGlja3koZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBTdGlja3kpO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBTdGlja3kuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBvcHRpb25zKTtcXG5cXG4gICAgICB0aGlzLl9pbml0KCk7XFxuXFxuICAgICAgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCAnU3RpY2t5Jyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSBzdGlja3kgZWxlbWVudCBieSBhZGRpbmcgY2xhc3NlcywgZ2V0dGluZy9zZXR0aW5nIGRpbWVuc2lvbnMsIGJyZWFrcG9pbnRzIGFuZCBhdHRyaWJ1dGVzXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG5cXG4gICAgX2NyZWF0ZUNsYXNzKFN0aWNreSwgW3tcXG4gICAgICBrZXk6ICdfaW5pdCcsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgICAgdmFyICRwYXJlbnQgPSB0aGlzLiRlbGVtZW50LnBhcmVudCgnW2RhdGEtc3RpY2t5LWNvbnRhaW5lcl0nKSxcXG4gICAgICAgICAgICBpZCA9IHRoaXMuJGVsZW1lbnRbMF0uaWQgfHwgRm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LCAnc3RpY2t5JyksXFxuICAgICAgICAgICAgX3RoaXMgPSB0aGlzO1xcblxcbiAgICAgICAgaWYgKCEkcGFyZW50Lmxlbmd0aCkge1xcbiAgICAgICAgICB0aGlzLndhc1dyYXBwZWQgPSB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgdGhpcy4kY29udGFpbmVyID0gJHBhcmVudC5sZW5ndGggPyAkcGFyZW50IDogJCh0aGlzLm9wdGlvbnMuY29udGFpbmVyKS53cmFwSW5uZXIodGhpcy4kZWxlbWVudCk7XFxuICAgICAgICB0aGlzLiRjb250YWluZXIuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmNvbnRhaW5lckNsYXNzKTtcXG5cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnN0aWNreUNsYXNzKS5hdHRyKHsgJ2RhdGEtcmVzaXplJzogaWQgfSk7XFxuXFxuICAgICAgICB0aGlzLnNjcm9sbENvdW50ID0gdGhpcy5vcHRpb25zLmNoZWNrRXZlcnk7XFxuICAgICAgICB0aGlzLmlzU3R1Y2sgPSBmYWxzZTtcXG4gICAgICAgICQod2luZG93KS5vbmUoJ2xvYWQuemYuc3RpY2t5JywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBpZiAoX3RoaXMub3B0aW9ucy5hbmNob3IgIT09ICcnKSB7XFxuICAgICAgICAgICAgX3RoaXMuJGFuY2hvciA9ICQoJyMnICsgX3RoaXMub3B0aW9ucy5hbmNob3IpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIF90aGlzLl9wYXJzZVBvaW50cygpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIF90aGlzLl9zZXRTaXplcyhmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgX3RoaXMuX2NhbGMoZmFsc2UpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgICAgX3RoaXMuX2V2ZW50cyhpZC5zcGxpdCgnLScpLnJldmVyc2UoKS5qb2luKCctJykpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIElmIHVzaW5nIG11bHRpcGxlIGVsZW1lbnRzIGFzIGFuY2hvcnMsIGNhbGN1bGF0ZXMgdGhlIHRvcCBhbmQgYm90dG9tIHBpeGVsIHZhbHVlcyB0aGUgc3RpY2t5IHRoaW5nIHNob3VsZCBzdGljayBhbmQgdW5zdGljayBvbi5cXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX3BhcnNlUG9pbnRzJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3BhcnNlUG9pbnRzKCkge1xcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMub3B0aW9ucy50b3BBbmNob3IgPT0gXFxcIlxcXCIgPyAxIDogdGhpcy5vcHRpb25zLnRvcEFuY2hvcixcXG4gICAgICAgICAgICBidG0gPSB0aGlzLm9wdGlvbnMuYnRtQW5jaG9yID09IFxcXCJcXFwiID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCA6IHRoaXMub3B0aW9ucy5idG1BbmNob3IsXFxuICAgICAgICAgICAgcHRzID0gW3RvcCwgYnRtXSxcXG4gICAgICAgICAgICBicmVha3MgPSB7fTtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBwdHMubGVuZ3RoOyBpIDwgbGVuICYmIHB0c1tpXTsgaSsrKSB7XFxuICAgICAgICAgIHZhciBwdDtcXG4gICAgICAgICAgaWYgKHR5cGVvZiBwdHNbaV0gPT09ICdudW1iZXInKSB7XFxuICAgICAgICAgICAgcHQgPSBwdHNbaV07XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdmFyIHBsYWNlID0gcHRzW2ldLnNwbGl0KCc6JyksXFxuICAgICAgICAgICAgICAgIGFuY2hvciA9ICQoJyMnICsgcGxhY2VbMF0pO1xcblxcbiAgICAgICAgICAgIHB0ID0gYW5jaG9yLm9mZnNldCgpLnRvcDtcXG4gICAgICAgICAgICBpZiAocGxhY2VbMV0gJiYgcGxhY2VbMV0udG9Mb3dlckNhc2UoKSA9PT0gJ2JvdHRvbScpIHtcXG4gICAgICAgICAgICAgIHB0ICs9IGFuY2hvclswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJyZWFrc1tpXSA9IHB0O1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5wb2ludHMgPSBicmVha3M7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEFkZHMgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBzY3JvbGxpbmcgZWxlbWVudC5cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqIEBwYXJhbSB7U3RyaW5nfSBpZCAtIHBzdWVkby1yYW5kb20gaWQgZm9yIHVuaXF1ZSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIuXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfZXZlbnRzJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cyhpZCkge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcyxcXG4gICAgICAgICAgICBzY3JvbGxMaXN0ZW5lciA9IHRoaXMuc2Nyb2xsTGlzdGVuZXIgPSAnc2Nyb2xsLnpmLicgKyBpZDtcXG4gICAgICAgIGlmICh0aGlzLmlzT24pIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHRoaXMuY2FuU3RpY2spIHtcXG4gICAgICAgICAgdGhpcy5pc09uID0gdHJ1ZTtcXG4gICAgICAgICAgJCh3aW5kb3cpLm9mZihzY3JvbGxMaXN0ZW5lcikub24oc2Nyb2xsTGlzdGVuZXIsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgICAgaWYgKF90aGlzLnNjcm9sbENvdW50ID09PSAwKSB7XFxuICAgICAgICAgICAgICBfdGhpcy5zY3JvbGxDb3VudCA9IF90aGlzLm9wdGlvbnMuY2hlY2tFdmVyeTtcXG4gICAgICAgICAgICAgIF90aGlzLl9zZXRTaXplcyhmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLl9jYWxjKGZhbHNlLCB3aW5kb3cucGFnZVlPZmZzZXQpO1xcbiAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAgIF90aGlzLnNjcm9sbENvdW50LS07XFxuICAgICAgICAgICAgICBfdGhpcy5fY2FsYyhmYWxzZSwgd2luZG93LnBhZ2VZT2Zmc2V0KTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInKS5vbigncmVzaXplbWUuemYudHJpZ2dlcicsIGZ1bmN0aW9uIChlLCBlbCkge1xcbiAgICAgICAgICBfdGhpcy5fc2V0U2l6ZXMoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIF90aGlzLl9jYWxjKGZhbHNlKTtcXG4gICAgICAgICAgICBpZiAoX3RoaXMuY2FuU3RpY2spIHtcXG4gICAgICAgICAgICAgIGlmICghX3RoaXMuaXNPbikge1xcbiAgICAgICAgICAgICAgICBfdGhpcy5fZXZlbnRzKGlkKTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9IGVsc2UgaWYgKF90aGlzLmlzT24pIHtcXG4gICAgICAgICAgICAgIF90aGlzLl9wYXVzZUxpc3RlbmVycyhzY3JvbGxMaXN0ZW5lcik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBSZW1vdmVzIGV2ZW50IGhhbmRsZXJzIGZvciBzY3JvbGwgYW5kIGNoYW5nZSBldmVudHMgb24gYW5jaG9yLlxcbiAgICAgICAqIEBmaXJlcyBTdGlja3kjcGF1c2VcXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2Nyb2xsTGlzdGVuZXIgLSB1bmlxdWUsIG5hbWVzcGFjZWQgc2Nyb2xsIGxpc3RlbmVyIGF0dGFjaGVkIHRvIGB3aW5kb3dgXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfcGF1c2VMaXN0ZW5lcnMnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfcGF1c2VMaXN0ZW5lcnMoc2Nyb2xsTGlzdGVuZXIpIHtcXG4gICAgICAgIHRoaXMuaXNPbiA9IGZhbHNlO1xcbiAgICAgICAgJCh3aW5kb3cpLm9mZihzY3JvbGxMaXN0ZW5lcik7XFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBpcyBwYXVzZWQgZHVlIHRvIHJlc2l6ZSBldmVudCBzaHJpbmtpbmcgdGhlIHZpZXcuXFxuICAgICAgICAgKiBAZXZlbnQgU3RpY2t5I3BhdXNlXFxuICAgICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ3BhdXNlLnpmLnN0aWNreScpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBDYWxsZWQgb24gZXZlcnkgYHNjcm9sbGAgZXZlbnQgYW5kIG9uIGBfaW5pdGBcXG4gICAgICAgKiBmaXJlcyBmdW5jdGlvbnMgYmFzZWQgb24gYm9vbGVhbnMgYW5kIGNhY2hlZCB2YWx1ZXNcXG4gICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNoZWNrU2l6ZXMgLSB0cnVlIGlmIHBsdWdpbiBzaG91bGQgcmVjYWxjdWxhdGUgc2l6ZXMgYW5kIGJyZWFrcG9pbnRzLlxcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBzY3JvbGwgLSBjdXJyZW50IHNjcm9sbCBwb3NpdGlvbiBwYXNzZWQgZnJvbSBzY3JvbGwgZXZlbnQgY2IgZnVuY3Rpb24uIElmIG5vdCBwYXNzZWQsIGRlZmF1bHRzIHRvIGB3aW5kb3cucGFnZVlPZmZzZXRgLlxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX2NhbGMnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfY2FsYyhjaGVja1NpemVzLCBzY3JvbGwpIHtcXG4gICAgICAgIGlmIChjaGVja1NpemVzKSB7XFxuICAgICAgICAgIHRoaXMuX3NldFNpemVzKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIXRoaXMuY2FuU3RpY2spIHtcXG4gICAgICAgICAgaWYgKHRoaXMuaXNTdHVjaykge1xcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVN0aWNreSh0cnVlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoIXNjcm9sbCkge1xcbiAgICAgICAgICBzY3JvbGwgPSB3aW5kb3cucGFnZVlPZmZzZXQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoc2Nyb2xsID49IHRoaXMudG9wUG9pbnQpIHtcXG4gICAgICAgICAgaWYgKHNjcm9sbCA8PSB0aGlzLmJvdHRvbVBvaW50KSB7XFxuICAgICAgICAgICAgaWYgKCF0aGlzLmlzU3R1Y2spIHtcXG4gICAgICAgICAgICAgIHRoaXMuX3NldFN0aWNreSgpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5pc1N0dWNrKSB7XFxuICAgICAgICAgICAgICB0aGlzLl9yZW1vdmVTdGlja3koZmFsc2UpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaWYgKHRoaXMuaXNTdHVjaykge1xcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVN0aWNreSh0cnVlKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBDYXVzZXMgdGhlICRlbGVtZW50IHRvIGJlY29tZSBzdHVjay5cXG4gICAgICAgKiBBZGRzIGBwb3NpdGlvbjogZml4ZWQ7YCwgYW5kIGhlbHBlciBjbGFzc2VzLlxcbiAgICAgICAqIEBmaXJlcyBTdGlja3kjc3R1Y2t0b1xcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfc2V0U3RpY2t5JyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFN0aWNreSgpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXMsXFxuICAgICAgICAgICAgc3RpY2tUbyA9IHRoaXMub3B0aW9ucy5zdGlja1RvLFxcbiAgICAgICAgICAgIG1yZ24gPSBzdGlja1RvID09PSAndG9wJyA/ICdtYXJnaW5Ub3AnIDogJ21hcmdpbkJvdHRvbScsXFxuICAgICAgICAgICAgbm90U3R1Y2tUbyA9IHN0aWNrVG8gPT09ICd0b3AnID8gJ2JvdHRvbScgOiAndG9wJyxcXG4gICAgICAgICAgICBjc3MgPSB7fTtcXG5cXG4gICAgICAgIGNzc1ttcmduXSA9IHRoaXMub3B0aW9uc1ttcmduXSArICdlbSc7XFxuICAgICAgICBjc3Nbc3RpY2tUb10gPSAwO1xcbiAgICAgICAgY3NzW25vdFN0dWNrVG9dID0gJ2F1dG8nO1xcbiAgICAgICAgY3NzWydsZWZ0J10gPSB0aGlzLiRjb250YWluZXIub2Zmc2V0KCkubGVmdCArIHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJGNvbnRhaW5lclswXSlbXFxcInBhZGRpbmctbGVmdFxcXCJdLCAxMCk7XFxuICAgICAgICB0aGlzLmlzU3R1Y2sgPSB0cnVlO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcygnaXMtYW5jaG9yZWQgaXMtYXQtJyArIG5vdFN0dWNrVG8pLmFkZENsYXNzKCdpcy1zdHVjayBpcy1hdC0nICsgc3RpY2tUbykuY3NzKGNzcylcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgJGVsZW1lbnQgaGFzIGJlY29tZSBgcG9zaXRpb246IGZpeGVkO2BcXG4gICAgICAgICAqIE5hbWVzcGFjZWQgdG8gYHRvcGAgb3IgYGJvdHRvbWAsIGUuZy4gYHN0aWNreS56Zi5zdHVja3RvOnRvcGBcXG4gICAgICAgICAqIEBldmVudCBTdGlja3kjc3R1Y2t0b1xcbiAgICAgICAgICovXFxuICAgICAgICAudHJpZ2dlcignc3RpY2t5LnpmLnN0dWNrdG86JyArIHN0aWNrVG8pO1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbihcXFwidHJhbnNpdGlvbmVuZCB3ZWJraXRUcmFuc2l0aW9uRW5kIG9UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kIE1TVHJhbnNpdGlvbkVuZFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgX3RoaXMuX3NldFNpemVzKCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogQ2F1c2VzIHRoZSAkZWxlbWVudCB0byBiZWNvbWUgdW5zdHVjay5cXG4gICAgICAgKiBSZW1vdmVzIGBwb3NpdGlvbjogZml4ZWQ7YCwgYW5kIGhlbHBlciBjbGFzc2VzLlxcbiAgICAgICAqIEFkZHMgb3RoZXIgaGVscGVyIGNsYXNzZXMuXFxuICAgICAgICogQHBhcmFtIHtCb29sZWFufSBpc1RvcCAtIHRlbGxzIHRoZSBmdW5jdGlvbiBpZiB0aGUgJGVsZW1lbnQgc2hvdWxkIGFuY2hvciB0byB0aGUgdG9wIG9yIGJvdHRvbSBvZiBpdHMgJGFuY2hvciBlbGVtZW50LlxcbiAgICAgICAqIEBmaXJlcyBTdGlja3kjdW5zdHVja2Zyb21cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX3JlbW92ZVN0aWNreScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9yZW1vdmVTdGlja3koaXNUb3ApIHtcXG4gICAgICAgIHZhciBzdGlja1RvID0gdGhpcy5vcHRpb25zLnN0aWNrVG8sXFxuICAgICAgICAgICAgc3RpY2tUb1RvcCA9IHN0aWNrVG8gPT09ICd0b3AnLFxcbiAgICAgICAgICAgIGNzcyA9IHt9LFxcbiAgICAgICAgICAgIGFuY2hvclB0ID0gKHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMV0gLSB0aGlzLnBvaW50c1swXSA6IHRoaXMuYW5jaG9ySGVpZ2h0KSAtIHRoaXMuZWxlbUhlaWdodCxcXG4gICAgICAgICAgICBtcmduID0gc3RpY2tUb1RvcCA/ICdtYXJnaW5Ub3AnIDogJ21hcmdpbkJvdHRvbScsXFxuICAgICAgICAgICAgbm90U3R1Y2tUbyA9IHN0aWNrVG9Ub3AgPyAnYm90dG9tJyA6ICd0b3AnLFxcbiAgICAgICAgICAgIHRvcE9yQm90dG9tID0gaXNUb3AgPyAndG9wJyA6ICdib3R0b20nO1xcblxcbiAgICAgICAgY3NzW21yZ25dID0gMDtcXG5cXG4gICAgICAgIGNzc1snYm90dG9tJ10gPSAnYXV0byc7XFxuICAgICAgICBpZiAoaXNUb3ApIHtcXG4gICAgICAgICAgY3NzWyd0b3AnXSA9IDA7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBjc3NbJ3RvcCddID0gYW5jaG9yUHQ7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBjc3NbJ2xlZnQnXSA9ICcnO1xcbiAgICAgICAgdGhpcy5pc1N0dWNrID0gZmFsc2U7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKCdpcy1zdHVjayBpcy1hdC0nICsgc3RpY2tUbykuYWRkQ2xhc3MoJ2lzLWFuY2hvcmVkIGlzLWF0LScgKyB0b3BPckJvdHRvbSkuY3NzKGNzcylcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgJGVsZW1lbnQgaGFzIGJlY29tZSBhbmNob3JlZC5cXG4gICAgICAgICAqIE5hbWVzcGFjZWQgdG8gYHRvcGAgb3IgYGJvdHRvbWAsIGUuZy4gYHN0aWNreS56Zi51bnN0dWNrZnJvbTpib3R0b21gXFxuICAgICAgICAgKiBAZXZlbnQgU3RpY2t5I3Vuc3R1Y2tmcm9tXFxuICAgICAgICAgKi9cXG4gICAgICAgIC50cmlnZ2VyKCdzdGlja3kuemYudW5zdHVja2Zyb206JyArIHRvcE9yQm90dG9tKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogU2V0cyB0aGUgJGVsZW1lbnQgYW5kICRjb250YWluZXIgc2l6ZXMgZm9yIHBsdWdpbi5cXG4gICAgICAgKiBDYWxscyBgX3NldEJyZWFrUG9pbnRzYC5cXG4gICAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiAtIG9wdGlvbmFsIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgb24gY29tcGxldGlvbiBvZiBgX3NldEJyZWFrUG9pbnRzYC5cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX3NldFNpemVzJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFNpemVzKGNiKSB7XFxuICAgICAgICB0aGlzLmNhblN0aWNrID0gRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodGhpcy5vcHRpb25zLnN0aWNreU9uKTtcXG4gICAgICAgIGlmICghdGhpcy5jYW5TdGljaykge1xcbiAgICAgICAgICBjYigpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcyxcXG4gICAgICAgICAgICBuZXdFbGVtV2lkdGggPSB0aGlzLiRjb250YWluZXJbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgsXFxuICAgICAgICAgICAgY29tcCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJGNvbnRhaW5lclswXSksXFxuICAgICAgICAgICAgcGRuZyA9IHBhcnNlSW50KGNvbXBbJ3BhZGRpbmctcmlnaHQnXSwgMTApO1xcblxcbiAgICAgICAgaWYgKHRoaXMuJGFuY2hvciAmJiB0aGlzLiRhbmNob3IubGVuZ3RoKSB7XFxuICAgICAgICAgIHRoaXMuYW5jaG9ySGVpZ2h0ID0gdGhpcy4kYW5jaG9yWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMuX3BhcnNlUG9pbnRzKCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0aGlzLiRlbGVtZW50LmNzcyh7XFxuICAgICAgICAgICdtYXgtd2lkdGgnOiBuZXdFbGVtV2lkdGggLSBwZG5nICsgJ3B4J1xcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICB2YXIgbmV3Q29udGFpbmVySGVpZ2h0ID0gdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgfHwgdGhpcy5jb250YWluZXJIZWlnaHQ7XFxuICAgICAgICBpZiAodGhpcy4kZWxlbWVudC5jc3MoXFxcImRpc3BsYXlcXFwiKSA9PSBcXFwibm9uZVxcXCIpIHtcXG4gICAgICAgICAgbmV3Q29udGFpbmVySGVpZ2h0ID0gMDtcXG4gICAgICAgIH1cXG4gICAgICAgIHRoaXMuY29udGFpbmVySGVpZ2h0ID0gbmV3Q29udGFpbmVySGVpZ2h0O1xcbiAgICAgICAgdGhpcy4kY29udGFpbmVyLmNzcyh7XFxuICAgICAgICAgIGhlaWdodDogbmV3Q29udGFpbmVySGVpZ2h0XFxuICAgICAgICB9KTtcXG4gICAgICAgIHRoaXMuZWxlbUhlaWdodCA9IG5ld0NvbnRhaW5lckhlaWdodDtcXG5cXG4gICAgICAgIGlmICh0aGlzLmlzU3R1Y2spIHtcXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5jc3MoeyBcXFwibGVmdFxcXCI6IHRoaXMuJGNvbnRhaW5lci5vZmZzZXQoKS5sZWZ0ICsgcGFyc2VJbnQoY29tcFsncGFkZGluZy1sZWZ0J10sIDEwKSB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX3NldEJyZWFrUG9pbnRzKG5ld0NvbnRhaW5lckhlaWdodCwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBpZiAoY2IpIHtcXG4gICAgICAgICAgICBjYigpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogU2V0cyB0aGUgdXBwZXIgYW5kIGxvd2VyIGJyZWFrcG9pbnRzIGZvciB0aGUgZWxlbWVudCB0byBiZWNvbWUgc3RpY2t5L3Vuc3RpY2t5LlxcbiAgICAgICAqIEBwYXJhbSB7TnVtYmVyfSBlbGVtSGVpZ2h0IC0gcHggdmFsdWUgZm9yIHN0aWNreS4kZWxlbWVudCBoZWlnaHQsIGNhbGN1bGF0ZWQgYnkgYF9zZXRTaXplc2AuXFxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgLSBvcHRpb25hbCBjYWxsYmFjayBmdW5jdGlvbiB0byBiZSBjYWxsZWQgb24gY29tcGxldGlvbi5cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX3NldEJyZWFrUG9pbnRzJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldEJyZWFrUG9pbnRzKGVsZW1IZWlnaHQsIGNiKSB7XFxuICAgICAgICBpZiAoIXRoaXMuY2FuU3RpY2spIHtcXG4gICAgICAgICAgaWYgKGNiKSB7XFxuICAgICAgICAgICAgY2IoKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHZhciBtVG9wID0gZW1DYWxjKHRoaXMub3B0aW9ucy5tYXJnaW5Ub3ApLFxcbiAgICAgICAgICAgIG1CdG0gPSBlbUNhbGModGhpcy5vcHRpb25zLm1hcmdpbkJvdHRvbSksXFxuICAgICAgICAgICAgdG9wUG9pbnQgPSB0aGlzLnBvaW50cyA/IHRoaXMucG9pbnRzWzBdIDogdGhpcy4kYW5jaG9yLm9mZnNldCgpLnRvcCxcXG4gICAgICAgICAgICBib3R0b21Qb2ludCA9IHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMV0gOiB0b3BQb2ludCArIHRoaXMuYW5jaG9ySGVpZ2h0LFxcblxcbiAgICAgICAgLy8gdG9wUG9pbnQgPSB0aGlzLiRhbmNob3Iub2Zmc2V0KCkudG9wIHx8IHRoaXMucG9pbnRzWzBdLFxcbiAgICAgICAgLy8gYm90dG9tUG9pbnQgPSB0b3BQb2ludCArIHRoaXMuYW5jaG9ySGVpZ2h0IHx8IHRoaXMucG9pbnRzWzFdLFxcbiAgICAgICAgd2luSGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdGlja1RvID09PSAndG9wJykge1xcbiAgICAgICAgICB0b3BQb2ludCAtPSBtVG9wO1xcbiAgICAgICAgICBib3R0b21Qb2ludCAtPSBlbGVtSGVpZ2h0ICsgbVRvcDtcXG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnN0aWNrVG8gPT09ICdib3R0b20nKSB7XFxuICAgICAgICAgIHRvcFBvaW50IC09IHdpbkhlaWdodCAtIChlbGVtSGVpZ2h0ICsgbUJ0bSk7XFxuICAgICAgICAgIGJvdHRvbVBvaW50IC09IHdpbkhlaWdodCAtIG1CdG07XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAvL3RoaXMgd291bGQgYmUgdGhlIHN0aWNrVG86IGJvdGggb3B0aW9uLi4uIHRyaWNreVxcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy50b3BQb2ludCA9IHRvcFBvaW50O1xcbiAgICAgICAgdGhpcy5ib3R0b21Qb2ludCA9IGJvdHRvbVBvaW50O1xcblxcbiAgICAgICAgaWYgKGNiKSB7XFxuICAgICAgICAgIGNiKCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIERlc3Ryb3lzIHRoZSBjdXJyZW50IHN0aWNreSBlbGVtZW50LlxcbiAgICAgICAqIFJlc2V0cyB0aGUgZWxlbWVudCB0byB0aGUgdG9wIHBvc2l0aW9uIGZpcnN0LlxcbiAgICAgICAqIFJlbW92ZXMgZXZlbnQgbGlzdGVuZXJzLCBKUy1hZGRlZCBjc3MgcHJvcGVydGllcyBhbmQgY2xhc3NlcywgYW5kIHVud3JhcHMgdGhlICRlbGVtZW50IGlmIHRoZSBKUyBhZGRlZCB0aGUgJGNvbnRhaW5lci5cXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ2Rlc3Ryb3knLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95KCkge1xcbiAgICAgICAgdGhpcy5fcmVtb3ZlU3RpY2t5KHRydWUpO1xcblxcbiAgICAgICAgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuc3RpY2t5Q2xhc3MgKyAnIGlzLWFuY2hvcmVkIGlzLWF0LXRvcCcpLmNzcyh7XFxuICAgICAgICAgIGhlaWdodDogJycsXFxuICAgICAgICAgIHRvcDogJycsXFxuICAgICAgICAgIGJvdHRvbTogJycsXFxuICAgICAgICAgICdtYXgtd2lkdGgnOiAnJ1xcbiAgICAgICAgfSkub2ZmKCdyZXNpemVtZS56Zi50cmlnZ2VyJyk7XFxuICAgICAgICBpZiAodGhpcy4kYW5jaG9yICYmIHRoaXMuJGFuY2hvci5sZW5ndGgpIHtcXG4gICAgICAgICAgdGhpcy4kYW5jaG9yLm9mZignY2hhbmdlLnpmLnN0aWNreScpO1xcbiAgICAgICAgfVxcbiAgICAgICAgJCh3aW5kb3cpLm9mZih0aGlzLnNjcm9sbExpc3RlbmVyKTtcXG5cXG4gICAgICAgIGlmICh0aGlzLndhc1dyYXBwZWQpIHtcXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC51bndyYXAoKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIHRoaXMuJGNvbnRhaW5lci5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuY29udGFpbmVyQ2xhc3MpLmNzcyh7XFxuICAgICAgICAgICAgaGVpZ2h0OiAnJ1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcXG4gICAgICB9XFxuICAgIH1dKTtcXG5cXG4gICAgcmV0dXJuIFN0aWNreTtcXG4gIH0oKTtcXG5cXG4gIFN0aWNreS5kZWZhdWx0cyA9IHtcXG4gICAgLyoqXFxuICAgICAqIEN1c3RvbWl6YWJsZSBjb250YWluZXIgdGVtcGxhdGUuIEFkZCB5b3VyIG93biBjbGFzc2VzIGZvciBzdHlsaW5nIGFuZCBzaXppbmcuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgJyZsdDtkaXYgZGF0YS1zdGlja3ktY29udGFpbmVyIGNsYXNzPVxcXCJzbWFsbC02IGNvbHVtbnNcXFwiJmd0OyZsdDsvZGl2Jmd0OydcXG4gICAgICovXFxuICAgIGNvbnRhaW5lcjogJzxkaXYgZGF0YS1zdGlja3ktY29udGFpbmVyPjwvZGl2PicsXFxuICAgIC8qKlxcbiAgICAgKiBMb2NhdGlvbiBpbiB0aGUgdmlldyB0aGUgZWxlbWVudCBzdGlja3MgdG8uXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgJ3RvcCdcXG4gICAgICovXFxuICAgIHN0aWNrVG86ICd0b3AnLFxcbiAgICAvKipcXG4gICAgICogSWYgYW5jaG9yZWQgdG8gYSBzaW5nbGUgZWxlbWVudCwgdGhlIGlkIG9mIHRoYXQgZWxlbWVudC5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAnZXhhbXBsZUlkJ1xcbiAgICAgKi9cXG4gICAgYW5jaG9yOiAnJyxcXG4gICAgLyoqXFxuICAgICAqIElmIHVzaW5nIG1vcmUgdGhhbiBvbmUgZWxlbWVudCBhcyBhbmNob3IgcG9pbnRzLCB0aGUgaWQgb2YgdGhlIHRvcCBhbmNob3IuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgJ2V4YW1wbGVJZDp0b3AnXFxuICAgICAqL1xcbiAgICB0b3BBbmNob3I6ICcnLFxcbiAgICAvKipcXG4gICAgICogSWYgdXNpbmcgbW9yZSB0aGFuIG9uZSBlbGVtZW50IGFzIGFuY2hvciBwb2ludHMsIHRoZSBpZCBvZiB0aGUgYm90dG9tIGFuY2hvci5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAnZXhhbXBsZUlkOmJvdHRvbSdcXG4gICAgICovXFxuICAgIGJ0bUFuY2hvcjogJycsXFxuICAgIC8qKlxcbiAgICAgKiBNYXJnaW4sIGluIGBlbWAncyB0byBhcHBseSB0byB0aGUgdG9wIG9mIHRoZSBlbGVtZW50IHdoZW4gaXQgYmVjb21lcyBzdGlja3kuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgMVxcbiAgICAgKi9cXG4gICAgbWFyZ2luVG9wOiAxLFxcbiAgICAvKipcXG4gICAgICogTWFyZ2luLCBpbiBgZW1gJ3MgdG8gYXBwbHkgdG8gdGhlIGJvdHRvbSBvZiB0aGUgZWxlbWVudCB3aGVuIGl0IGJlY29tZXMgc3RpY2t5LlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIDFcXG4gICAgICovXFxuICAgIG1hcmdpbkJvdHRvbTogMSxcXG4gICAgLyoqXFxuICAgICAqIEJyZWFrcG9pbnQgc3RyaW5nIHRoYXQgaXMgdGhlIG1pbmltdW0gc2NyZWVuIHNpemUgYW4gZWxlbWVudCBzaG91bGQgYmVjb21lIHN0aWNreS5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAnbWVkaXVtJ1xcbiAgICAgKi9cXG4gICAgc3RpY2t5T246ICdtZWRpdW0nLFxcbiAgICAvKipcXG4gICAgICogQ2xhc3MgYXBwbGllZCB0byBzdGlja3kgZWxlbWVudCwgYW5kIHJlbW92ZWQgb24gZGVzdHJ1Y3Rpb24uIEZvdW5kYXRpb24gZGVmYXVsdHMgdG8gYHN0aWNreWAuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgJ3N0aWNreSdcXG4gICAgICovXFxuICAgIHN0aWNreUNsYXNzOiAnc3RpY2t5JyxcXG4gICAgLyoqXFxuICAgICAqIENsYXNzIGFwcGxpZWQgdG8gc3RpY2t5IGNvbnRhaW5lci4gRm91bmRhdGlvbiBkZWZhdWx0cyB0byBgc3RpY2t5LWNvbnRhaW5lcmAuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgJ3N0aWNreS1jb250YWluZXInXFxuICAgICAqL1xcbiAgICBjb250YWluZXJDbGFzczogJ3N0aWNreS1jb250YWluZXInLFxcbiAgICAvKipcXG4gICAgICogTnVtYmVyIG9mIHNjcm9sbCBldmVudHMgYmV0d2VlbiB0aGUgcGx1Z2luJ3MgcmVjYWxjdWxhdGluZyBzdGlja3kgcG9pbnRzLiBTZXR0aW5nIGl0IHRvIGAwYCB3aWxsIGNhdXNlIGl0IHRvIHJlY2FsYyBldmVyeSBzY3JvbGwgZXZlbnQsIHNldHRpbmcgaXQgdG8gYC0xYCB3aWxsIHByZXZlbnQgcmVjYWxjIG9uIHNjcm9sbC5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSA1MFxcbiAgICAgKi9cXG4gICAgY2hlY2tFdmVyeTogLTFcXG4gIH07XFxuXFxuICAvKipcXG4gICAqIEhlbHBlciBmdW5jdGlvbiB0byBjYWxjdWxhdGUgZW0gdmFsdWVzXFxuICAgKiBAcGFyYW0gTnVtYmVyIHtlbX0gLSBudW1iZXIgb2YgZW0ncyB0byBjYWxjdWxhdGUgaW50byBwaXhlbHNcXG4gICAqL1xcbiAgZnVuY3Rpb24gZW1DYWxjKGVtKSB7XFxuICAgIHJldHVybiBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5LCBudWxsKS5mb250U2l6ZSwgMTApICogZW07XFxuICB9XFxuXFxuICAvLyBXaW5kb3cgZXhwb3J0c1xcbiAgRm91bmRhdGlvbi5wbHVnaW4oU3RpY2t5LCAnU3RpY2t5Jyk7XFxufShqUXVlcnkpO1xcbid1c2Ugc3RyaWN0JztcXG5cXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG4hZnVuY3Rpb24gKCQpIHtcXG5cXG4gIC8qKlxcbiAgICogVGFicyBtb2R1bGUuXFxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24udGFic1xcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5rZXlib2FyZFxcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC50aW1lckFuZEltYWdlTG9hZGVyIGlmIHRhYnMgY29udGFpbiBpbWFnZXNcXG4gICAqL1xcblxcbiAgdmFyIFRhYnMgPSBmdW5jdGlvbiAoKSB7XFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIHRhYnMuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAZmlyZXMgVGFicyNpbml0XFxuICAgICAqIEBwYXJhbSB7alF1ZXJ5fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBtYWtlIGludG8gdGFicy5cXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPdmVycmlkZXMgdG8gdGhlIGRlZmF1bHQgcGx1Z2luIHNldHRpbmdzLlxcbiAgICAgKi9cXG5cXG4gICAgZnVuY3Rpb24gVGFicyhlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRhYnMpO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBUYWJzLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcbiAgICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ1RhYnMnKTtcXG4gICAgICBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKCdUYWJzJywge1xcbiAgICAgICAgJ0VOVEVSJzogJ29wZW4nLFxcbiAgICAgICAgJ1NQQUNFJzogJ29wZW4nLFxcbiAgICAgICAgJ0FSUk9XX1JJR0hUJzogJ25leHQnLFxcbiAgICAgICAgJ0FSUk9XX1VQJzogJ3ByZXZpb3VzJyxcXG4gICAgICAgICdBUlJPV19ET1dOJzogJ25leHQnLFxcbiAgICAgICAgJ0FSUk9XX0xFRlQnOiAncHJldmlvdXMnXFxuICAgICAgICAvLyAnVEFCJzogJ25leHQnLFxcbiAgICAgICAgLy8gJ1NISUZUX1RBQic6ICdwcmV2aW91cydcXG4gICAgICB9KTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIHRhYnMgYnkgc2hvd2luZyBhbmQgZm9jdXNpbmcgKGlmIGF1dG9Gb2N1cz10cnVlKSB0aGUgcHJlc2V0IGFjdGl2ZSB0YWIuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcblxcbiAgICBfY3JlYXRlQ2xhc3MoVGFicywgW3tcXG4gICAgICBrZXk6ICdfaW5pdCcsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICAgIHRoaXMuJHRhYlRpdGxlcyA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLicgKyB0aGlzLm9wdGlvbnMubGlua0NsYXNzKTtcXG4gICAgICAgIHRoaXMuJHRhYkNvbnRlbnQgPSAkKCdbZGF0YS10YWJzLWNvbnRlbnQ9XFxcIicgKyB0aGlzLiRlbGVtZW50WzBdLmlkICsgJ1xcXCJdJyk7XFxuXFxuICAgICAgICB0aGlzLiR0YWJUaXRsZXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciAkZWxlbSA9ICQodGhpcyksXFxuICAgICAgICAgICAgICAkbGluayA9ICRlbGVtLmZpbmQoJ2EnKSxcXG4gICAgICAgICAgICAgIGlzQWN0aXZlID0gJGVsZW0uaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpLFxcbiAgICAgICAgICAgICAgaGFzaCA9ICRsaW5rWzBdLmhhc2guc2xpY2UoMSksXFxuICAgICAgICAgICAgICBsaW5rSWQgPSAkbGlua1swXS5pZCA/ICRsaW5rWzBdLmlkIDogaGFzaCArICctbGFiZWwnLFxcbiAgICAgICAgICAgICAgJHRhYkNvbnRlbnQgPSAkKCcjJyArIGhhc2gpO1xcblxcbiAgICAgICAgICAkZWxlbS5hdHRyKHsgJ3JvbGUnOiAncHJlc2VudGF0aW9uJyB9KTtcXG5cXG4gICAgICAgICAgJGxpbmsuYXR0cih7XFxuICAgICAgICAgICAgJ3JvbGUnOiAndGFiJyxcXG4gICAgICAgICAgICAnYXJpYS1jb250cm9scyc6IGhhc2gsXFxuICAgICAgICAgICAgJ2FyaWEtc2VsZWN0ZWQnOiBpc0FjdGl2ZSxcXG4gICAgICAgICAgICAnaWQnOiBsaW5rSWRcXG4gICAgICAgICAgfSk7XFxuXFxuICAgICAgICAgICR0YWJDb250ZW50LmF0dHIoe1xcbiAgICAgICAgICAgICdyb2xlJzogJ3RhYnBhbmVsJyxcXG4gICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiAhaXNBY3RpdmUsXFxuICAgICAgICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IGxpbmtJZFxcbiAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgaWYgKGlzQWN0aXZlICYmIF90aGlzLm9wdGlvbnMuYXV0b0ZvY3VzKSB7XFxuICAgICAgICAgICAgJGxpbmsuZm9jdXMoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1hdGNoSGVpZ2h0KSB7XFxuICAgICAgICAgIHZhciAkaW1hZ2VzID0gdGhpcy4kdGFiQ29udGVudC5maW5kKCdpbWcnKTtcXG5cXG4gICAgICAgICAgaWYgKCRpbWFnZXMubGVuZ3RoKSB7XFxuICAgICAgICAgICAgRm91bmRhdGlvbi5vbkltYWdlc0xvYWRlZCgkaW1hZ2VzLCB0aGlzLl9zZXRIZWlnaHQuYmluZCh0aGlzKSk7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgdGhpcy5fc2V0SGVpZ2h0KCk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuX2V2ZW50cygpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBBZGRzIGV2ZW50IGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIHRhYnMuXFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ19ldmVudHMnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfZXZlbnRzKCkge1xcbiAgICAgICAgdGhpcy5fYWRkS2V5SGFuZGxlcigpO1xcbiAgICAgICAgdGhpcy5fYWRkQ2xpY2tIYW5kbGVyKCk7XFxuICAgICAgICB0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIgPSBudWxsO1xcblxcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5tYXRjaEhlaWdodCkge1xcbiAgICAgICAgICB0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIgPSB0aGlzLl9zZXRIZWlnaHQuYmluZCh0aGlzKTtcXG5cXG4gICAgICAgICAgJCh3aW5kb3cpLm9uKCdjaGFuZ2VkLnpmLm1lZGlhcXVlcnknLCB0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBBZGRzIGNsaWNrIGhhbmRsZXJzIGZvciBpdGVtcyB3aXRoaW4gdGhlIHRhYnMuXFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ19hZGRDbGlja0hhbmRsZXInLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkQ2xpY2tIYW5kbGVyKCkge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCdjbGljay56Zi50YWJzJykub24oJ2NsaWNrLnpmLnRhYnMnLCAnLicgKyB0aGlzLm9wdGlvbnMubGlua0NsYXNzLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgIGlmICgkKHRoaXMpLmhhc0NsYXNzKCdpcy1hY3RpdmUnKSkge1xcbiAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICBfdGhpcy5faGFuZGxlVGFiQ2hhbmdlKCQodGhpcykpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEFkZHMga2V5Ym9hcmQgZXZlbnQgaGFuZGxlcnMgZm9yIGl0ZW1zIHdpdGhpbiB0aGUgdGFicy5cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX2FkZEtleUhhbmRsZXInLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYWRkS2V5SGFuZGxlcigpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICB2YXIgJGZpcnN0VGFiID0gX3RoaXMuJGVsZW1lbnQuZmluZCgnbGk6Zmlyc3Qtb2YtdHlwZScpO1xcbiAgICAgICAgdmFyICRsYXN0VGFiID0gX3RoaXMuJGVsZW1lbnQuZmluZCgnbGk6bGFzdC1vZi10eXBlJyk7XFxuXFxuICAgICAgICB0aGlzLiR0YWJUaXRsZXMub2ZmKCdrZXlkb3duLnpmLnRhYnMnKS5vbigna2V5ZG93bi56Zi50YWJzJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgaWYgKGUud2hpY2ggPT09IDkpIHJldHVybjtcXG5cXG4gICAgICAgICAgdmFyICRlbGVtZW50ID0gJCh0aGlzKSxcXG4gICAgICAgICAgICAgICRlbGVtZW50cyA9ICRlbGVtZW50LnBhcmVudCgndWwnKS5jaGlsZHJlbignbGknKSxcXG4gICAgICAgICAgICAgICRwcmV2RWxlbWVudCxcXG4gICAgICAgICAgICAgICRuZXh0RWxlbWVudDtcXG5cXG4gICAgICAgICAgJGVsZW1lbnRzLmVhY2goZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgICAgICBpZiAoJCh0aGlzKS5pcygkZWxlbWVudCkpIHtcXG4gICAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLndyYXBPbktleXMpIHtcXG4gICAgICAgICAgICAgICAgJHByZXZFbGVtZW50ID0gaSA9PT0gMCA/ICRlbGVtZW50cy5sYXN0KCkgOiAkZWxlbWVudHMuZXEoaSAtIDEpO1xcbiAgICAgICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSBpID09PSAkZWxlbWVudHMubGVuZ3RoIC0gMSA/ICRlbGVtZW50cy5maXJzdCgpIDogJGVsZW1lbnRzLmVxKGkgKyAxKTtcXG4gICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICRwcmV2RWxlbWVudCA9ICRlbGVtZW50cy5lcShNYXRoLm1heCgwLCBpIC0gMSkpO1xcbiAgICAgICAgICAgICAgICAkbmV4dEVsZW1lbnQgPSAkZWxlbWVudHMuZXEoTWF0aC5taW4oaSArIDEsICRlbGVtZW50cy5sZW5ndGggLSAxKSk7XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICByZXR1cm47XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KTtcXG5cXG4gICAgICAgICAgLy8gaGFuZGxlIGtleWJvYXJkIGV2ZW50IHdpdGgga2V5Ym9hcmQgdXRpbFxcbiAgICAgICAgICBGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLCAnVGFicycsIHtcXG4gICAgICAgICAgICBvcGVuOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAkZWxlbWVudC5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgX3RoaXMuX2hhbmRsZVRhYkNoYW5nZSgkZWxlbWVudCk7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBwcmV2aW91czogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgJHByZXZFbGVtZW50LmZpbmQoJ1tyb2xlPVxcXCJ0YWJcXFwiXScpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICBfdGhpcy5faGFuZGxlVGFiQ2hhbmdlKCRwcmV2RWxlbWVudCk7XFxuICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAkbmV4dEVsZW1lbnQuZmluZCgnW3JvbGU9XFxcInRhYlxcXCJdJykuZm9jdXMoKTtcXG4gICAgICAgICAgICAgIF90aGlzLl9oYW5kbGVUYWJDaGFuZ2UoJG5leHRFbGVtZW50KTtcXG4gICAgICAgICAgICB9LFxcbiAgICAgICAgICAgIGhhbmRsZWQ6IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBPcGVucyB0aGUgdGFiIGAkdGFyZ2V0Q29udGVudGAgZGVmaW5lZCBieSBgJHRhcmdldGAuXFxuICAgICAgICogQHBhcmFtIHtqUXVlcnl9ICR0YXJnZXQgLSBUYWIgdG8gb3Blbi5cXG4gICAgICAgKiBAZmlyZXMgVGFicyNjaGFuZ2VcXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ19oYW5kbGVUYWJDaGFuZ2UnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaGFuZGxlVGFiQ2hhbmdlKCR0YXJnZXQpIHtcXG4gICAgICAgIHZhciAkdGFiTGluayA9ICR0YXJnZXQuZmluZCgnW3JvbGU9XFxcInRhYlxcXCJdJyksXFxuICAgICAgICAgICAgaGFzaCA9ICR0YWJMaW5rWzBdLmhhc2gsXFxuICAgICAgICAgICAgJHRhcmdldENvbnRlbnQgPSB0aGlzLiR0YWJDb250ZW50LmZpbmQoaGFzaCksXFxuICAgICAgICAgICAgJG9sZFRhYiA9IHRoaXMuJGVsZW1lbnQuZmluZCgnLicgKyB0aGlzLm9wdGlvbnMubGlua0NsYXNzICsgJy5pcy1hY3RpdmUnKS5yZW1vdmVDbGFzcygnaXMtYWN0aXZlJykuZmluZCgnW3JvbGU9XFxcInRhYlxcXCJdJykuYXR0cih7ICdhcmlhLXNlbGVjdGVkJzogJ2ZhbHNlJyB9KTtcXG5cXG4gICAgICAgICQoJyMnICsgJG9sZFRhYi5hdHRyKCdhcmlhLWNvbnRyb2xzJykpLnJlbW92ZUNsYXNzKCdpcy1hY3RpdmUnKS5hdHRyKHsgJ2FyaWEtaGlkZGVuJzogJ3RydWUnIH0pO1xcblxcbiAgICAgICAgJHRhcmdldC5hZGRDbGFzcygnaXMtYWN0aXZlJyk7XFxuXFxuICAgICAgICAkdGFiTGluay5hdHRyKHsgJ2FyaWEtc2VsZWN0ZWQnOiAndHJ1ZScgfSk7XFxuXFxuICAgICAgICAkdGFyZ2V0Q29udGVudC5hZGRDbGFzcygnaXMtYWN0aXZlJykuYXR0cih7ICdhcmlhLWhpZGRlbic6ICdmYWxzZScgfSk7XFxuXFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHBsdWdpbiBoYXMgc3VjY2Vzc2Z1bGx5IGNoYW5nZWQgdGFicy5cXG4gICAgICAgICAqIEBldmVudCBUYWJzI2NoYW5nZVxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2NoYW5nZS56Zi50YWJzJywgWyR0YXJnZXRdKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogUHVibGljIG1ldGhvZCBmb3Igc2VsZWN0aW5nIGEgY29udGVudCBwYW5lIHRvIGRpc3BsYXkuXFxuICAgICAgICogQHBhcmFtIHtqUXVlcnkgfCBTdHJpbmd9IGVsZW0gLSBqUXVlcnkgb2JqZWN0IG9yIHN0cmluZyBvZiB0aGUgaWQgb2YgdGhlIHBhbmUgdG8gZGlzcGxheS5cXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ3NlbGVjdFRhYicsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNlbGVjdFRhYihlbGVtKSB7XFxuICAgICAgICB2YXIgaWRTdHI7XFxuXFxuICAgICAgICBpZiAodHlwZW9mIGVsZW0gPT09ICdvYmplY3QnKSB7XFxuICAgICAgICAgIGlkU3RyID0gZWxlbVswXS5pZDtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIGlkU3RyID0gZWxlbTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChpZFN0ci5pbmRleE9mKCcjJykgPCAwKSB7XFxuICAgICAgICAgIGlkU3RyID0gJyMnICsgaWRTdHI7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIgJHRhcmdldCA9IHRoaXMuJHRhYlRpdGxlcy5maW5kKCdbaHJlZj1cXFwiJyArIGlkU3RyICsgJ1xcXCJdJykucGFyZW50KCcuJyArIHRoaXMub3B0aW9ucy5saW5rQ2xhc3MpO1xcblxcbiAgICAgICAgdGhpcy5faGFuZGxlVGFiQ2hhbmdlKCR0YXJnZXQpO1xcbiAgICAgIH1cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ19zZXRIZWlnaHQnLFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIFNldHMgdGhlIGhlaWdodCBvZiBlYWNoIHBhbmVsIHRvIHRoZSBoZWlnaHQgb2YgdGhlIHRhbGxlc3QgcGFuZWwuXFxuICAgICAgICogSWYgZW5hYmxlZCBpbiBvcHRpb25zLCBnZXRzIGNhbGxlZCBvbiBtZWRpYSBxdWVyeSBjaGFuZ2UuXFxuICAgICAgICogSWYgbG9hZGluZyBjb250ZW50IHZpYSBleHRlcm5hbCBzb3VyY2UsIGNhbiBiZSBjYWxsZWQgZGlyZWN0bHkgb3Igd2l0aCBfcmVmbG93LlxcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9zZXRIZWlnaHQoKSB7XFxuICAgICAgICB2YXIgbWF4ID0gMDtcXG4gICAgICAgIHRoaXMuJHRhYkNvbnRlbnQuZmluZCgnLicgKyB0aGlzLm9wdGlvbnMucGFuZWxDbGFzcykuY3NzKCdoZWlnaHQnLCAnJykuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciBwYW5lbCA9ICQodGhpcyksXFxuICAgICAgICAgICAgICBpc0FjdGl2ZSA9IHBhbmVsLmhhc0NsYXNzKCdpcy1hY3RpdmUnKTtcXG5cXG4gICAgICAgICAgaWYgKCFpc0FjdGl2ZSkge1xcbiAgICAgICAgICAgIHBhbmVsLmNzcyh7ICd2aXNpYmlsaXR5JzogJ2hpZGRlbicsICdkaXNwbGF5JzogJ2Jsb2NrJyB9KTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICB2YXIgdGVtcCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O1xcblxcbiAgICAgICAgICBpZiAoIWlzQWN0aXZlKSB7XFxuICAgICAgICAgICAgcGFuZWwuY3NzKHtcXG4gICAgICAgICAgICAgICd2aXNpYmlsaXR5JzogJycsXFxuICAgICAgICAgICAgICAnZGlzcGxheSc6ICcnXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgbWF4ID0gdGVtcCA+IG1heCA/IHRlbXAgOiBtYXg7XFxuICAgICAgICB9KS5jc3MoJ2hlaWdodCcsIG1heCArICdweCcpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBEZXN0cm95cyBhbiBpbnN0YW5jZSBvZiBhbiB0YWJzLlxcbiAgICAgICAqIEBmaXJlcyBUYWJzI2Rlc3Ryb3llZFxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnZGVzdHJveScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmZpbmQoJy4nICsgdGhpcy5vcHRpb25zLmxpbmtDbGFzcykub2ZmKCcuemYudGFicycpLmhpZGUoKS5lbmQoKS5maW5kKCcuJyArIHRoaXMub3B0aW9ucy5wYW5lbENsYXNzKS5oaWRlKCk7XFxuXFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm1hdGNoSGVpZ2h0KSB7XFxuICAgICAgICAgIGlmICh0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIgIT0gbnVsbCkge1xcbiAgICAgICAgICAgICQod2luZG93KS5vZmYoJ2NoYW5nZWQuemYubWVkaWFxdWVyeScsIHRoaXMuX3NldEhlaWdodE1xSGFuZGxlcik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG5cXG4gICAgICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcXG4gICAgICB9XFxuICAgIH1dKTtcXG5cXG4gICAgcmV0dXJuIFRhYnM7XFxuICB9KCk7XFxuXFxuICBUYWJzLmRlZmF1bHRzID0ge1xcbiAgICAvKipcXG4gICAgICogQWxsb3dzIHRoZSB3aW5kb3cgdG8gc2Nyb2xsIHRvIGNvbnRlbnQgb2YgYWN0aXZlIHBhbmUgb24gbG9hZCBpZiBzZXQgdG8gdHJ1ZS5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSBmYWxzZVxcbiAgICAgKi9cXG4gICAgYXV0b0ZvY3VzOiBmYWxzZSxcXG5cXG4gICAgLyoqXFxuICAgICAqIEFsbG93cyBrZXlib2FyZCBpbnB1dCB0byAnd3JhcCcgYXJvdW5kIHRoZSB0YWIgbGlua3MuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgdHJ1ZVxcbiAgICAgKi9cXG4gICAgd3JhcE9uS2V5czogdHJ1ZSxcXG5cXG4gICAgLyoqXFxuICAgICAqIEFsbG93cyB0aGUgdGFiIGNvbnRlbnQgcGFuZXMgdG8gbWF0Y2ggaGVpZ2h0cyBpZiBzZXQgdG8gdHJ1ZS5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSBmYWxzZVxcbiAgICAgKi9cXG4gICAgbWF0Y2hIZWlnaHQ6IGZhbHNlLFxcblxcbiAgICAvKipcXG4gICAgICogQ2xhc3MgYXBwbGllZCB0byBgbGlgJ3MgaW4gdGFiIGxpbmsgbGlzdC5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAndGFicy10aXRsZSdcXG4gICAgICovXFxuICAgIGxpbmtDbGFzczogJ3RhYnMtdGl0bGUnLFxcblxcbiAgICAvKipcXG4gICAgICogQ2xhc3MgYXBwbGllZCB0byB0aGUgY29udGVudCBjb250YWluZXJzLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlICd0YWJzLXBhbmVsJ1xcbiAgICAgKi9cXG4gICAgcGFuZWxDbGFzczogJ3RhYnMtcGFuZWwnXFxuICB9O1xcblxcbiAgZnVuY3Rpb24gY2hlY2tDbGFzcygkZWxlbSkge1xcbiAgICByZXR1cm4gJGVsZW0uaGFzQ2xhc3MoJ2lzLWFjdGl2ZScpO1xcbiAgfVxcblxcbiAgLy8gV2luZG93IGV4cG9ydHNcXG4gIEZvdW5kYXRpb24ucGx1Z2luKFRhYnMsICdUYWJzJyk7XFxufShqUXVlcnkpO1xcbid1c2Ugc3RyaWN0JztcXG5cXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG4hZnVuY3Rpb24gKCQpIHtcXG5cXG4gIC8qKlxcbiAgICogVG9nZ2xlciBtb2R1bGUuXFxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24udG9nZ2xlclxcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5tb3Rpb25cXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcXG4gICAqL1xcblxcbiAgdmFyIFRvZ2dsZXIgPSBmdW5jdGlvbiAoKSB7XFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIFRvZ2dsZXIuXFxuICAgICAqIEBjbGFzc1xcbiAgICAgKiBAZmlyZXMgVG9nZ2xlciNpbml0XFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlbGVtZW50IC0galF1ZXJ5IG9iamVjdCB0byBhZGQgdGhlIHRyaWdnZXIgdG8uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3ZlcnJpZGVzIHRvIHRoZSBkZWZhdWx0IHBsdWdpbiBzZXR0aW5ncy5cXG4gICAgICovXFxuXFxuICAgIGZ1bmN0aW9uIFRvZ2dsZXIoZWxlbWVudCwgb3B0aW9ucykge1xcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBUb2dnbGVyKTtcXG5cXG4gICAgICB0aGlzLiRlbGVtZW50ID0gZWxlbWVudDtcXG4gICAgICB0aGlzLm9wdGlvbnMgPSAkLmV4dGVuZCh7fSwgVG9nZ2xlci5kZWZhdWx0cywgZWxlbWVudC5kYXRhKCksIG9wdGlvbnMpO1xcbiAgICAgIHRoaXMuY2xhc3NOYW1lID0gJyc7XFxuXFxuICAgICAgdGhpcy5faW5pdCgpO1xcbiAgICAgIHRoaXMuX2V2ZW50cygpO1xcblxcbiAgICAgIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgJ1RvZ2dsZXInKTtcXG4gICAgfVxcblxcbiAgICAvKipcXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIFRvZ2dsZXIgcGx1Z2luIGJ5IHBhcnNpbmcgdGhlIHRvZ2dsZSBjbGFzcyBmcm9tIGRhdGEtdG9nZ2xlciwgb3IgYW5pbWF0aW9uIGNsYXNzZXMgZnJvbSBkYXRhLWFuaW1hdGUuXFxuICAgICAqIEBmdW5jdGlvblxcbiAgICAgKiBAcHJpdmF0ZVxcbiAgICAgKi9cXG5cXG5cXG4gICAgX2NyZWF0ZUNsYXNzKFRvZ2dsZXIsIFt7XFxuICAgICAga2V5OiAnX2luaXQnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICAgIHZhciBpbnB1dDtcXG4gICAgICAgIC8vIFBhcnNlIGFuaW1hdGlvbiBjbGFzc2VzIGlmIHRoZXkgd2VyZSBzZXRcXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0ZSkge1xcbiAgICAgICAgICBpbnB1dCA9IHRoaXMub3B0aW9ucy5hbmltYXRlLnNwbGl0KCcgJyk7XFxuXFxuICAgICAgICAgIHRoaXMuYW5pbWF0aW9uSW4gPSBpbnB1dFswXTtcXG4gICAgICAgICAgdGhpcy5hbmltYXRpb25PdXQgPSBpbnB1dFsxXSB8fCBudWxsO1xcbiAgICAgICAgfVxcbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBwYXJzZSB0b2dnbGUgY2xhc3NcXG4gICAgICAgIGVsc2Uge1xcbiAgICAgICAgICAgIGlucHV0ID0gdGhpcy4kZWxlbWVudC5kYXRhKCd0b2dnbGVyJyk7XFxuICAgICAgICAgICAgLy8gQWxsb3cgZm9yIGEgLiBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdHJpbmdcXG4gICAgICAgICAgICB0aGlzLmNsYXNzTmFtZSA9IGlucHV0WzBdID09PSAnLicgPyBpbnB1dC5zbGljZSgxKSA6IGlucHV0O1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAvLyBBZGQgQVJJQSBhdHRyaWJ1dGVzIHRvIHRyaWdnZXJzXFxuICAgICAgICB2YXIgaWQgPSB0aGlzLiRlbGVtZW50WzBdLmlkO1xcbiAgICAgICAgJCgnW2RhdGEtb3Blbj1cXFwiJyArIGlkICsgJ1xcXCJdLCBbZGF0YS1jbG9zZT1cXFwiJyArIGlkICsgJ1xcXCJdLCBbZGF0YS10b2dnbGU9XFxcIicgKyBpZCArICdcXFwiXScpLmF0dHIoJ2FyaWEtY29udHJvbHMnLCBpZCk7XFxuICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGlzIGhpZGRlbiwgYWRkIGFyaWEtaGlkZGVuXFxuICAgICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCB0aGlzLiRlbGVtZW50LmlzKCc6aGlkZGVuJykgPyBmYWxzZSA6IHRydWUpO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBJbml0aWFsaXplcyBldmVudHMgZm9yIHRoZSB0b2dnbGUgdHJpZ2dlci5cXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX2V2ZW50cycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9ldmVudHMoKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZigndG9nZ2xlLnpmLnRyaWdnZXInKS5vbigndG9nZ2xlLnpmLnRyaWdnZXInLCB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogVG9nZ2xlcyB0aGUgdGFyZ2V0IGNsYXNzIG9uIHRoZSB0YXJnZXQgZWxlbWVudC4gQW4gZXZlbnQgaXMgZmlyZWQgZnJvbSB0aGUgb3JpZ2luYWwgdHJpZ2dlciBkZXBlbmRpbmcgb24gaWYgdGhlIHJlc3VsdGFudCBzdGF0ZSB3YXMgXFxcIm9uXFxcIiBvciBcXFwib2ZmXFxcIi5cXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKiBAZmlyZXMgVG9nZ2xlciNvblxcbiAgICAgICAqIEBmaXJlcyBUb2dnbGVyI29mZlxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAndG9nZ2xlJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xcbiAgICAgICAgdGhpc1t0aGlzLm9wdGlvbnMuYW5pbWF0ZSA/ICdfdG9nZ2xlQW5pbWF0ZScgOiAnX3RvZ2dsZUNsYXNzJ10oKTtcXG4gICAgICB9XFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfdG9nZ2xlQ2xhc3MnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdG9nZ2xlQ2xhc3MoKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LnRvZ2dsZUNsYXNzKHRoaXMuY2xhc3NOYW1lKTtcXG5cXG4gICAgICAgIHZhciBpc09uID0gdGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLmNsYXNzTmFtZSk7XFxuICAgICAgICBpZiAoaXNPbikge1xcbiAgICAgICAgICAvKipcXG4gICAgICAgICAgICogRmlyZXMgaWYgdGhlIHRhcmdldCBlbGVtZW50IGhhcyB0aGUgY2xhc3MgYWZ0ZXIgYSB0b2dnbGUuXFxuICAgICAgICAgICAqIEBldmVudCBUb2dnbGVyI29uXFxuICAgICAgICAgICAqL1xcbiAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ29uLnpmLnRvZ2dsZXInKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8qKlxcbiAgICAgICAgICAgKiBGaXJlcyBpZiB0aGUgdGFyZ2V0IGVsZW1lbnQgZG9lcyBub3QgaGF2ZSB0aGUgY2xhc3MgYWZ0ZXIgYSB0b2dnbGUuXFxuICAgICAgICAgICAqIEBldmVudCBUb2dnbGVyI29mZlxcbiAgICAgICAgICAgKi9cXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdvZmYuemYudG9nZ2xlcicpO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdGhpcy5fdXBkYXRlQVJJQShpc09uKTtcXG4gICAgICB9XFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfdG9nZ2xlQW5pbWF0ZScsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF90b2dnbGVBbmltYXRlKCkge1xcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gICAgICAgIGlmICh0aGlzLiRlbGVtZW50LmlzKCc6aGlkZGVuJykpIHtcXG4gICAgICAgICAgRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZUluKHRoaXMuJGVsZW1lbnQsIHRoaXMuYW5pbWF0aW9uSW4sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBfdGhpcy5fdXBkYXRlQVJJQSh0cnVlKTtcXG4gICAgICAgICAgICB0aGlzLnRyaWdnZXIoJ29uLnpmLnRvZ2dsZXInKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KHRoaXMuJGVsZW1lbnQsIHRoaXMuYW5pbWF0aW9uT3V0LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgX3RoaXMuX3VwZGF0ZUFSSUEoZmFsc2UpO1xcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlcignb2ZmLnpmLnRvZ2dsZXInKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX3VwZGF0ZUFSSUEnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfdXBkYXRlQVJJQShpc09uKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmF0dHIoJ2FyaWEtZXhwYW5kZWQnLCBpc09uID8gdHJ1ZSA6IGZhbHNlKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogRGVzdHJveXMgdGhlIGluc3RhbmNlIG9mIFRvZ2dsZXIgb24gdGhlIGVsZW1lbnQuXFxuICAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdkZXN0cm95JyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKCcuemYudG9nZ2xlcicpO1xcbiAgICAgICAgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xcbiAgICAgIH1cXG4gICAgfV0pO1xcblxcbiAgICByZXR1cm4gVG9nZ2xlcjtcXG4gIH0oKTtcXG5cXG4gIFRvZ2dsZXIuZGVmYXVsdHMgPSB7XFxuICAgIC8qKlxcbiAgICAgKiBUZWxscyB0aGUgcGx1Z2luIGlmIHRoZSBlbGVtZW50IHNob3VsZCBhbmltYXRlZCB3aGVuIHRvZ2dsZWQuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgZmFsc2VcXG4gICAgICovXFxuICAgIGFuaW1hdGU6IGZhbHNlXFxuICB9O1xcblxcbiAgLy8gV2luZG93IGV4cG9ydHNcXG4gIEZvdW5kYXRpb24ucGx1Z2luKFRvZ2dsZXIsICdUb2dnbGVyJyk7XFxufShqUXVlcnkpO1xcbid1c2Ugc3RyaWN0JztcXG5cXG52YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkgeyBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHsgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykgeyB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldOyBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7IGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTsgaWYgKFxcXCJ2YWx1ZVxcXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9IHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpOyByZXR1cm4gQ29uc3RydWN0b3I7IH07IH0oKTtcXG5cXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpOyB9IH1cXG5cXG4hZnVuY3Rpb24gKCQpIHtcXG5cXG4gIC8qKlxcbiAgICogVG9vbHRpcCBtb2R1bGUuXFxuICAgKiBAbW9kdWxlIGZvdW5kYXRpb24udG9vbHRpcFxcbiAgICogQHJlcXVpcmVzIGZvdW5kYXRpb24udXRpbC5ib3hcXG4gICAqIEByZXF1aXJlcyBmb3VuZGF0aW9uLnV0aWwudHJpZ2dlcnNcXG4gICAqL1xcblxcbiAgdmFyIFRvb2x0aXAgPSBmdW5jdGlvbiAoKSB7XFxuICAgIC8qKlxcbiAgICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGEgVG9vbHRpcC5cXG4gICAgICogQGNsYXNzXFxuICAgICAqIEBmaXJlcyBUb29sdGlwI2luaXRcXG4gICAgICogQHBhcmFtIHtqUXVlcnl9IGVsZW1lbnQgLSBqUXVlcnkgb2JqZWN0IHRvIGF0dGFjaCBhIHRvb2x0aXAgdG8uXFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gb2JqZWN0IHRvIGV4dGVuZCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uLlxcbiAgICAgKi9cXG5cXG4gICAgZnVuY3Rpb24gVG9vbHRpcChlbGVtZW50LCBvcHRpb25zKSB7XFxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIFRvb2x0aXApO1xcblxcbiAgICAgIHRoaXMuJGVsZW1lbnQgPSBlbGVtZW50O1xcbiAgICAgIHRoaXMub3B0aW9ucyA9ICQuZXh0ZW5kKHt9LCBUb29sdGlwLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgb3B0aW9ucyk7XFxuXFxuICAgICAgdGhpcy5pc0FjdGl2ZSA9IGZhbHNlO1xcbiAgICAgIHRoaXMuaXNDbGljayA9IGZhbHNlO1xcbiAgICAgIHRoaXMuX2luaXQoKTtcXG5cXG4gICAgICBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsICdUb29sdGlwJyk7XFxuICAgIH1cXG5cXG4gICAgLyoqXFxuICAgICAqIEluaXRpYWxpemVzIHRoZSB0b29sdGlwIGJ5IHNldHRpbmcgdGhlIGNyZWF0aW5nIHRoZSB0aXAgZWxlbWVudCwgYWRkaW5nIGl0J3MgdGV4dCwgc2V0dGluZyBwcml2YXRlIHZhcmlhYmxlcyBhbmQgc2V0dGluZyBhdHRyaWJ1dGVzIG9uIHRoZSBhbmNob3IuXFxuICAgICAqIEBwcml2YXRlXFxuICAgICAqL1xcblxcblxcbiAgICBfY3JlYXRlQ2xhc3MoVG9vbHRpcCwgW3tcXG4gICAgICBrZXk6ICdfaW5pdCcsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9pbml0KCkge1xcbiAgICAgICAgdmFyIGVsZW1JZCA9IHRoaXMuJGVsZW1lbnQuYXR0cignYXJpYS1kZXNjcmliZWRieScpIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgJ3Rvb2x0aXAnKTtcXG5cXG4gICAgICAgIHRoaXMub3B0aW9ucy5wb3NpdGlvbkNsYXNzID0gdGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3MgfHwgdGhpcy5fZ2V0UG9zaXRpb25DbGFzcyh0aGlzLiRlbGVtZW50KTtcXG4gICAgICAgIHRoaXMub3B0aW9ucy50aXBUZXh0ID0gdGhpcy5vcHRpb25zLnRpcFRleHQgfHwgdGhpcy4kZWxlbWVudC5hdHRyKCd0aXRsZScpO1xcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZSA/ICQodGhpcy5vcHRpb25zLnRlbXBsYXRlKSA6IHRoaXMuX2J1aWxkVGVtcGxhdGUoZWxlbUlkKTtcXG5cXG4gICAgICAgIHRoaXMudGVtcGxhdGUuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSkudGV4dCh0aGlzLm9wdGlvbnMudGlwVGV4dCkuaGlkZSgpO1xcblxcbiAgICAgICAgdGhpcy4kZWxlbWVudC5hdHRyKHtcXG4gICAgICAgICAgJ3RpdGxlJzogJycsXFxuICAgICAgICAgICdhcmlhLWRlc2NyaWJlZGJ5JzogZWxlbUlkLFxcbiAgICAgICAgICAnZGF0YS15ZXRpLWJveCc6IGVsZW1JZCxcXG4gICAgICAgICAgJ2RhdGEtdG9nZ2xlJzogZWxlbUlkLFxcbiAgICAgICAgICAnZGF0YS1yZXNpemUnOiBlbGVtSWRcXG4gICAgICAgIH0pLmFkZENsYXNzKHRoaXMudHJpZ2dlckNsYXNzKTtcXG5cXG4gICAgICAgIC8vaGVscGVyIHZhcmlhYmxlcyB0byB0cmFjayBtb3ZlbWVudCBvbiBjb2xsaXNpb25zXFxuICAgICAgICB0aGlzLnVzZWRQb3NpdGlvbnMgPSBbXTtcXG4gICAgICAgIHRoaXMuY291bnRlciA9IDQ7XFxuICAgICAgICB0aGlzLmNsYXNzQ2hhbmdlZCA9IGZhbHNlO1xcblxcbiAgICAgICAgdGhpcy5fZXZlbnRzKCk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEdyYWJzIHRoZSBjdXJyZW50IHBvc2l0aW9uaW5nIGNsYXNzLCBpZiBwcmVzZW50LCBhbmQgcmV0dXJucyB0aGUgdmFsdWUgb3IgYW4gZW1wdHkgc3RyaW5nLlxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfZ2V0UG9zaXRpb25DbGFzcycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRQb3NpdGlvbkNsYXNzKGVsZW1lbnQpIHtcXG4gICAgICAgIGlmICghZWxlbWVudCkge1xcbiAgICAgICAgICByZXR1cm4gJyc7XFxuICAgICAgICB9XFxuICAgICAgICAvLyB2YXIgcG9zaXRpb24gPSBlbGVtZW50LmF0dHIoJ2NsYXNzJykubWF0Y2goL3RvcHxsZWZ0fHJpZ2h0L2cpO1xcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gZWxlbWVudFswXS5jbGFzc05hbWUubWF0Y2goL1xcXFxiKHRvcHxsZWZ0fHJpZ2h0KVxcXFxiL2cpO1xcbiAgICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA/IHBvc2l0aW9uWzBdIDogJyc7XFxuICAgICAgICByZXR1cm4gcG9zaXRpb247XFxuICAgICAgfVxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX2J1aWxkVGVtcGxhdGUnLFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIGJ1aWxkcyB0aGUgdG9vbHRpcCBlbGVtZW50LCBhZGRzIGF0dHJpYnV0ZXMsIGFuZCByZXR1cm5zIHRoZSB0ZW1wbGF0ZS5cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBfYnVpbGRUZW1wbGF0ZShpZCkge1xcbiAgICAgICAgdmFyIHRlbXBsYXRlQ2xhc3NlcyA9ICh0aGlzLm9wdGlvbnMudG9vbHRpcENsYXNzICsgJyAnICsgdGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3MgKyAnICcgKyB0aGlzLm9wdGlvbnMudGVtcGxhdGVDbGFzc2VzKS50cmltKCk7XFxuICAgICAgICB2YXIgJHRlbXBsYXRlID0gJCgnPGRpdj48L2Rpdj4nKS5hZGRDbGFzcyh0ZW1wbGF0ZUNsYXNzZXMpLmF0dHIoe1xcbiAgICAgICAgICAncm9sZSc6ICd0b29sdGlwJyxcXG4gICAgICAgICAgJ2FyaWEtaGlkZGVuJzogdHJ1ZSxcXG4gICAgICAgICAgJ2RhdGEtaXMtYWN0aXZlJzogZmFsc2UsXFxuICAgICAgICAgICdkYXRhLWlzLWZvY3VzJzogZmFsc2UsXFxuICAgICAgICAgICdpZCc6IGlkXFxuICAgICAgICB9KTtcXG4gICAgICAgIHJldHVybiAkdGVtcGxhdGU7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIEZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgaWYgYSBjb2xsaXNpb24gZXZlbnQgaXMgZGV0ZWN0ZWQuXFxuICAgICAgICogQHBhcmFtIHtTdHJpbmd9IHBvc2l0aW9uIC0gcG9zaXRpb25pbmcgY2xhc3MgdG8gdHJ5XFxuICAgICAgICogQHByaXZhdGVcXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ19yZXBvc2l0aW9uJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3JlcG9zaXRpb24ocG9zaXRpb24pIHtcXG4gICAgICAgIHRoaXMudXNlZFBvc2l0aW9ucy5wdXNoKHBvc2l0aW9uID8gcG9zaXRpb24gOiAnYm90dG9tJyk7XFxuXFxuICAgICAgICAvL2RlZmF1bHQsIHRyeSBzd2l0Y2hpbmcgdG8gb3Bwb3NpdGUgc2lkZVxcbiAgICAgICAgaWYgKCFwb3NpdGlvbiAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZigndG9wJykgPCAwKSB7XFxuICAgICAgICAgIHRoaXMudGVtcGxhdGUuYWRkQ2xhc3MoJ3RvcCcpO1xcbiAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpIDwgMCkge1xcbiAgICAgICAgICB0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHBvc2l0aW9uKTtcXG4gICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdsZWZ0JyAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZigncmlnaHQnKSA8IDApIHtcXG4gICAgICAgICAgdGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyhwb3NpdGlvbikuYWRkQ2xhc3MoJ3JpZ2h0Jyk7XFxuICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAncmlnaHQnICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdsZWZ0JykgPCAwKSB7XFxuICAgICAgICAgIHRoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3MocG9zaXRpb24pLmFkZENsYXNzKCdsZWZ0Jyk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvL2lmIGRlZmF1bHQgY2hhbmdlIGRpZG4ndCB3b3JrLCB0cnkgYm90dG9tIG9yIGxlZnQgZmlyc3RcXG4gICAgICAgIGVsc2UgaWYgKCFwb3NpdGlvbiAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZigndG9wJykgPiAtMSAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignbGVmdCcpIDwgMCkge1xcbiAgICAgICAgICAgIHRoaXMudGVtcGxhdGUuYWRkQ2xhc3MoJ2xlZnQnKTtcXG4gICAgICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PT0gJ3RvcCcgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2JvdHRvbScpID4gLTEgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2xlZnQnKSA8IDApIHtcXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHBvc2l0aW9uKS5hZGRDbGFzcygnbGVmdCcpO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09PSAnbGVmdCcgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ3JpZ2h0JykgPiAtMSAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZignYm90dG9tJykgPCAwKSB7XFxuICAgICAgICAgICAgdGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyhwb3NpdGlvbik7XFxuICAgICAgICAgIH0gZWxzZSBpZiAocG9zaXRpb24gPT09ICdyaWdodCcgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoJ2xlZnQnKSA+IC0xICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKCdib3R0b20nKSA8IDApIHtcXG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHBvc2l0aW9uKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgICAvL2lmIG5vdGhpbmcgY2xlYXJlZCwgc2V0IHRvIGJvdHRvbVxcbiAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgIHRoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3MocG9zaXRpb24pO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIHRoaXMuY2xhc3NDaGFuZ2VkID0gdHJ1ZTtcXG4gICAgICAgIHRoaXMuY291bnRlci0tO1xcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBzZXRzIHRoZSBwb3NpdGlvbiBjbGFzcyBvZiBhbiBlbGVtZW50IGFuZCByZWN1cnNpdmVseSBjYWxscyBpdHNlbGYgdW50aWwgdGhlcmUgYXJlIG5vIG1vcmUgcG9zc2libGUgcG9zaXRpb25zIHRvIGF0dGVtcHQsIG9yIHRoZSB0b29sdGlwIGVsZW1lbnQgaXMgbm8gbG9uZ2VyIGNvbGxpZGluZy5cXG4gICAgICAgKiBpZiB0aGUgdG9vbHRpcCBpcyBsYXJnZXIgdGhhbiB0aGUgc2NyZWVuIHdpZHRoLCBkZWZhdWx0IHRvIGZ1bGwgd2lkdGggLSBhbnkgdXNlciBzZWxlY3RlZCBtYXJnaW5cXG4gICAgICAgKiBAcHJpdmF0ZVxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnX3NldFBvc2l0aW9uJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX3NldFBvc2l0aW9uKCkge1xcbiAgICAgICAgdmFyIHBvc2l0aW9uID0gdGhpcy5fZ2V0UG9zaXRpb25DbGFzcyh0aGlzLnRlbXBsYXRlKSxcXG4gICAgICAgICAgICAkdGlwRGltcyA9IEZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy50ZW1wbGF0ZSksXFxuICAgICAgICAgICAgJGFuY2hvckRpbXMgPSBGb3VuZGF0aW9uLkJveC5HZXREaW1lbnNpb25zKHRoaXMuJGVsZW1lbnQpLFxcbiAgICAgICAgICAgIGRpcmVjdGlvbiA9IHBvc2l0aW9uID09PSAnbGVmdCcgPyAnbGVmdCcgOiBwb3NpdGlvbiA9PT0gJ3JpZ2h0JyA/ICdsZWZ0JyA6ICd0b3AnLFxcbiAgICAgICAgICAgIHBhcmFtID0gZGlyZWN0aW9uID09PSAndG9wJyA/ICdoZWlnaHQnIDogJ3dpZHRoJyxcXG4gICAgICAgICAgICBvZmZzZXQgPSBwYXJhbSA9PT0gJ2hlaWdodCcgPyB0aGlzLm9wdGlvbnMudk9mZnNldCA6IHRoaXMub3B0aW9ucy5oT2Zmc2V0LFxcbiAgICAgICAgICAgIF90aGlzID0gdGhpcztcXG5cXG4gICAgICAgIGlmICgkdGlwRGltcy53aWR0aCA+PSAkdGlwRGltcy53aW5kb3dEaW1zLndpZHRoIHx8ICF0aGlzLmNvdW50ZXIgJiYgIUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy50ZW1wbGF0ZSkpIHtcXG4gICAgICAgICAgdGhpcy50ZW1wbGF0ZS5vZmZzZXQoRm91bmRhdGlvbi5Cb3guR2V0T2Zmc2V0cyh0aGlzLnRlbXBsYXRlLCB0aGlzLiRlbGVtZW50LCAnY2VudGVyIGJvdHRvbScsIHRoaXMub3B0aW9ucy52T2Zmc2V0LCB0aGlzLm9wdGlvbnMuaE9mZnNldCwgdHJ1ZSkpLmNzcyh7XFxuICAgICAgICAgICAgLy8gdGhpcy4kZWxlbWVudC5vZmZzZXQoRm91bmRhdGlvbi5HZXRPZmZzZXRzKHRoaXMudGVtcGxhdGUsIHRoaXMuJGVsZW1lbnQsICdjZW50ZXIgYm90dG9tJywgdGhpcy5vcHRpb25zLnZPZmZzZXQsIHRoaXMub3B0aW9ucy5oT2Zmc2V0LCB0cnVlKSkuY3NzKHtcXG4gICAgICAgICAgICAnd2lkdGgnOiAkYW5jaG9yRGltcy53aW5kb3dEaW1zLndpZHRoIC0gdGhpcy5vcHRpb25zLmhPZmZzZXQgKiAyLFxcbiAgICAgICAgICAgICdoZWlnaHQnOiAnYXV0bydcXG4gICAgICAgICAgfSk7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMudGVtcGxhdGUub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy50ZW1wbGF0ZSwgdGhpcy4kZWxlbWVudCwgJ2NlbnRlciAnICsgKHBvc2l0aW9uIHx8ICdib3R0b20nKSwgdGhpcy5vcHRpb25zLnZPZmZzZXQsIHRoaXMub3B0aW9ucy5oT2Zmc2V0KSk7XFxuXFxuICAgICAgICB3aGlsZSAoIUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy50ZW1wbGF0ZSkgJiYgdGhpcy5jb3VudGVyKSB7XFxuICAgICAgICAgIHRoaXMuX3JlcG9zaXRpb24ocG9zaXRpb24pO1xcbiAgICAgICAgICB0aGlzLl9zZXRQb3NpdGlvbigpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG5cXG4gICAgICAvKipcXG4gICAgICAgKiByZXZlYWxzIHRoZSB0b29sdGlwLCBhbmQgZmlyZXMgYW4gZXZlbnQgdG8gY2xvc2UgYW55IG90aGVyIG9wZW4gdG9vbHRpcHMgb24gdGhlIHBhZ2VcXG4gICAgICAgKiBAZmlyZXMgVG9vbHRpcCNjbG9zZW1lXFxuICAgICAgICogQGZpcmVzIFRvb2x0aXAjc2hvd1xcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAnc2hvdycsXFxuICAgICAgdmFsdWU6IGZ1bmN0aW9uIHNob3coKSB7XFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNob3dPbiAhPT0gJ2FsbCcgJiYgIUZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHRoaXMub3B0aW9ucy5zaG93T24pKSB7XFxuICAgICAgICAgIC8vIGNvbnNvbGUuZXJyb3IoJ1RoZSBzY3JlZW4gaXMgdG9vIHNtYWxsIHRvIGRpc3BsYXkgdGhpcyB0b29sdGlwJyk7XFxuICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICB0aGlzLnRlbXBsYXRlLmNzcygndmlzaWJpbGl0eScsICdoaWRkZW4nKS5zaG93KCk7XFxuICAgICAgICB0aGlzLl9zZXRQb3NpdGlvbigpO1xcblxcbiAgICAgICAgLyoqXFxuICAgICAgICAgKiBGaXJlcyB0byBjbG9zZSBhbGwgb3RoZXIgb3BlbiB0b29sdGlwcyBvbiB0aGUgcGFnZVxcbiAgICAgICAgICogQGV2ZW50IENsb3NlbWUjdG9vbHRpcFxcbiAgICAgICAgICovXFxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoJ2Nsb3NlbWUuemYudG9vbHRpcCcsIHRoaXMudGVtcGxhdGUuYXR0cignaWQnKSk7XFxuXFxuICAgICAgICB0aGlzLnRlbXBsYXRlLmF0dHIoe1xcbiAgICAgICAgICAnZGF0YS1pcy1hY3RpdmUnOiB0cnVlLFxcbiAgICAgICAgICAnYXJpYS1oaWRkZW4nOiBmYWxzZVxcbiAgICAgICAgfSk7XFxuICAgICAgICBfdGhpcy5pc0FjdGl2ZSA9IHRydWU7XFxuICAgICAgICAvLyBjb25zb2xlLmxvZyh0aGlzLnRlbXBsYXRlKTtcXG4gICAgICAgIHRoaXMudGVtcGxhdGUuc3RvcCgpLmhpZGUoKS5jc3MoJ3Zpc2liaWxpdHknLCAnJykuZmFkZUluKHRoaXMub3B0aW9ucy5mYWRlSW5EdXJhdGlvbiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAvL21heWJlIGRvIHN0dWZmP1xcbiAgICAgICAgfSk7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHRvb2x0aXAgaXMgc2hvd25cXG4gICAgICAgICAqIEBldmVudCBUb29sdGlwI3Nob3dcXG4gICAgICAgICAqL1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC50cmlnZ2VyKCdzaG93LnpmLnRvb2x0aXAnKTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogSGlkZXMgdGhlIGN1cnJlbnQgdG9vbHRpcCwgYW5kIHJlc2V0cyB0aGUgcG9zaXRpb25pbmcgY2xhc3MgaWYgaXQgd2FzIGNoYW5nZWQgZHVlIHRvIGNvbGxpc2lvblxcbiAgICAgICAqIEBmaXJlcyBUb29sdGlwI2hpZGVcXG4gICAgICAgKiBAZnVuY3Rpb25cXG4gICAgICAgKi9cXG5cXG4gICAgfSwge1xcbiAgICAgIGtleTogJ2hpZGUnLFxcbiAgICAgIHZhbHVlOiBmdW5jdGlvbiBoaWRlKCkge1xcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ2hpZGluZycsIHRoaXMuJGVsZW1lbnQuZGF0YSgneWV0aS1ib3gnKSk7XFxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5zdG9wKCkuYXR0cih7XFxuICAgICAgICAgICdhcmlhLWhpZGRlbic6IHRydWUsXFxuICAgICAgICAgICdkYXRhLWlzLWFjdGl2ZSc6IGZhbHNlXFxuICAgICAgICB9KS5mYWRlT3V0KHRoaXMub3B0aW9ucy5mYWRlT3V0RHVyYXRpb24sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgX3RoaXMuaXNBY3RpdmUgPSBmYWxzZTtcXG4gICAgICAgICAgX3RoaXMuaXNDbGljayA9IGZhbHNlO1xcbiAgICAgICAgICBpZiAoX3RoaXMuY2xhc3NDaGFuZ2VkKSB7XFxuICAgICAgICAgICAgX3RoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3MoX3RoaXMuX2dldFBvc2l0aW9uQ2xhc3MoX3RoaXMudGVtcGxhdGUpKS5hZGRDbGFzcyhfdGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3MpO1xcblxcbiAgICAgICAgICAgIF90aGlzLnVzZWRQb3NpdGlvbnMgPSBbXTtcXG4gICAgICAgICAgICBfdGhpcy5jb3VudGVyID0gNDtcXG4gICAgICAgICAgICBfdGhpcy5jbGFzc0NoYW5nZWQgPSBmYWxzZTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgICAvKipcXG4gICAgICAgICAqIGZpcmVzIHdoZW4gdGhlIHRvb2x0aXAgaXMgaGlkZGVuXFxuICAgICAgICAgKiBAZXZlbnQgVG9vbHRpcCNoaWRlXFxuICAgICAgICAgKi9cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudHJpZ2dlcignaGlkZS56Zi50b29sdGlwJyk7XFxuICAgICAgfVxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIGFkZHMgZXZlbnQgbGlzdGVuZXJzIGZvciB0aGUgdG9vbHRpcCBhbmQgaXRzIGFuY2hvclxcbiAgICAgICAqIFRPRE8gY29tYmluZSBzb21lIG9mIHRoZSBsaXN0ZW5lcnMgbGlrZSBmb2N1cyBhbmQgbW91c2VlbnRlciwgZXRjLlxcbiAgICAgICAqIEBwcml2YXRlXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdfZXZlbnRzJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gX2V2ZW50cygpIHtcXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XFxuICAgICAgICB2YXIgJHRlbXBsYXRlID0gdGhpcy50ZW1wbGF0ZTtcXG4gICAgICAgIHZhciBpc0ZvY3VzID0gZmFsc2U7XFxuXFxuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5kaXNhYmxlSG92ZXIpIHtcXG5cXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5vbignbW91c2VlbnRlci56Zi50b29sdGlwJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBpZiAoIV90aGlzLmlzQWN0aXZlKSB7XFxuICAgICAgICAgICAgICBfdGhpcy50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIF90aGlzLnNob3coKTtcXG4gICAgICAgICAgICAgIH0sIF90aGlzLm9wdGlvbnMuaG92ZXJEZWxheSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KS5vbignbW91c2VsZWF2ZS56Zi50b29sdGlwJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX3RoaXMudGltZW91dCk7XFxuICAgICAgICAgICAgaWYgKCFpc0ZvY3VzIHx8IF90aGlzLmlzQ2xpY2sgJiYgIV90aGlzLm9wdGlvbnMuY2xpY2tPcGVuKSB7XFxuICAgICAgICAgICAgICBfdGhpcy5oaWRlKCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY2xpY2tPcGVuKSB7XFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ21vdXNlZG93bi56Zi50b29sdGlwJywgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBlLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICAgIGlmIChfdGhpcy5pc0NsaWNrKSB7XFxuICAgICAgICAgICAgICAvL190aGlzLmhpZGUoKTtcXG4gICAgICAgICAgICAgIC8vIF90aGlzLmlzQ2xpY2sgPSBmYWxzZTtcXG4gICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICBfdGhpcy5pc0NsaWNrID0gdHJ1ZTtcXG4gICAgICAgICAgICAgICAgaWYgKChfdGhpcy5vcHRpb25zLmRpc2FibGVIb3ZlciB8fCAhX3RoaXMuJGVsZW1lbnQuYXR0cigndGFiaW5kZXgnKSkgJiYgIV90aGlzLmlzQWN0aXZlKSB7XFxuICAgICAgICAgICAgICAgICAgX3RoaXMuc2hvdygpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICB9XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgdGhpcy4kZWxlbWVudC5vbignbW91c2Vkb3duLnpmLnRvb2x0aXAnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgICAgX3RoaXMuaXNDbGljayA9IHRydWU7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZGlzYWJsZUZvclRvdWNoKSB7XFxuICAgICAgICAgIHRoaXMuJGVsZW1lbnQub24oJ3RhcC56Zi50b29sdGlwIHRvdWNoZW5kLnpmLnRvb2x0aXAnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIF90aGlzLmlzQWN0aXZlID8gX3RoaXMuaGlkZSgpIDogX3RoaXMuc2hvdygpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub24oe1xcbiAgICAgICAgICAvLyAndG9nZ2xlLnpmLnRyaWdnZXInOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLFxcbiAgICAgICAgICAvLyAnY2xvc2UuemYudHJpZ2dlcic6IHRoaXMuaGlkZS5iaW5kKHRoaXMpXFxuICAgICAgICAgICdjbG9zZS56Zi50cmlnZ2VyJzogdGhpcy5oaWRlLmJpbmQodGhpcylcXG4gICAgICAgIH0pO1xcblxcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vbignZm9jdXMuemYudG9vbHRpcCcsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIGlzRm9jdXMgPSB0cnVlO1xcbiAgICAgICAgICBpZiAoX3RoaXMuaXNDbGljaykge1xcbiAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCBzaG93aW5nIG9wZW4gb24gY2xpY2tzLCB3ZSBuZWVkIHRvIHByZXRlbmQgYSBjbGljay1sYXVuY2hlZCBmb2N1cyBpc24ndFxcbiAgICAgICAgICAgIC8vIGEgcmVhbCBmb2N1cywgb3RoZXJ3aXNlIG9uIGhvdmVyIGFuZCBjb21lIGJhY2sgd2UgZ2V0IGJhZCBiZWhhdmlvclxcbiAgICAgICAgICAgIGlmICghX3RoaXMub3B0aW9ucy5jbGlja09wZW4pIHtcXG4gICAgICAgICAgICAgIGlzRm9jdXMgPSBmYWxzZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIF90aGlzLnNob3coKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSkub24oJ2ZvY3Vzb3V0LnpmLnRvb2x0aXAnLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICBpc0ZvY3VzID0gZmFsc2U7XFxuICAgICAgICAgIF90aGlzLmlzQ2xpY2sgPSBmYWxzZTtcXG4gICAgICAgICAgX3RoaXMuaGlkZSgpO1xcbiAgICAgICAgfSkub24oJ3Jlc2l6ZW1lLnpmLnRyaWdnZXInLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGlmIChfdGhpcy5pc0FjdGl2ZSkge1xcbiAgICAgICAgICAgIF90aGlzLl9zZXRQb3NpdGlvbigpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogYWRkcyBhIHRvZ2dsZSBtZXRob2QsIGluIGFkZGl0aW9uIHRvIHRoZSBzdGF0aWMgc2hvdygpICYgaGlkZSgpIGZ1bmN0aW9uc1xcbiAgICAgICAqIEBmdW5jdGlvblxcbiAgICAgICAqL1xcblxcbiAgICB9LCB7XFxuICAgICAga2V5OiAndG9nZ2xlJyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xcbiAgICAgICAgaWYgKHRoaXMuaXNBY3RpdmUpIHtcXG4gICAgICAgICAgdGhpcy5oaWRlKCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICB0aGlzLnNob3coKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogRGVzdHJveXMgYW4gaW5zdGFuY2Ugb2YgdG9vbHRpcCwgcmVtb3ZlcyB0ZW1wbGF0ZSBlbGVtZW50IGZyb20gdGhlIHZpZXcuXFxuICAgICAgICogQGZ1bmN0aW9uXFxuICAgICAgICovXFxuXFxuICAgIH0sIHtcXG4gICAgICBrZXk6ICdkZXN0cm95JyxcXG4gICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cigndGl0bGUnLCB0aGlzLnRlbXBsYXRlLnRleHQoKSkub2ZmKCcuemYudHJpZ2dlciAuemYudG9vdGlwJylcXG4gICAgICAgIC8vICAucmVtb3ZlQ2xhc3MoJ2hhcy10aXAnKVxcbiAgICAgICAgLnJlbW92ZUF0dHIoJ2FyaWEtZGVzY3JpYmVkYnknKS5yZW1vdmVBdHRyKCdkYXRhLXlldGktYm94JykucmVtb3ZlQXR0cignZGF0YS10b2dnbGUnKS5yZW1vdmVBdHRyKCdkYXRhLXJlc2l6ZScpO1xcblxcbiAgICAgICAgdGhpcy50ZW1wbGF0ZS5yZW1vdmUoKTtcXG5cXG4gICAgICAgIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcXG4gICAgICB9XFxuICAgIH1dKTtcXG5cXG4gICAgcmV0dXJuIFRvb2x0aXA7XFxuICB9KCk7XFxuXFxuICBUb29sdGlwLmRlZmF1bHRzID0ge1xcbiAgICBkaXNhYmxlRm9yVG91Y2g6IGZhbHNlLFxcbiAgICAvKipcXG4gICAgICogVGltZSwgaW4gbXMsIGJlZm9yZSBhIHRvb2x0aXAgc2hvdWxkIG9wZW4gb24gaG92ZXIuXFxuICAgICAqIEBvcHRpb25cXG4gICAgICogQGV4YW1wbGUgMjAwXFxuICAgICAqL1xcbiAgICBob3ZlckRlbGF5OiAyMDAsXFxuICAgIC8qKlxcbiAgICAgKiBUaW1lLCBpbiBtcywgYSB0b29sdGlwIHNob3VsZCB0YWtlIHRvIGZhZGUgaW50byB2aWV3LlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIDE1MFxcbiAgICAgKi9cXG4gICAgZmFkZUluRHVyYXRpb246IDE1MCxcXG4gICAgLyoqXFxuICAgICAqIFRpbWUsIGluIG1zLCBhIHRvb2x0aXAgc2hvdWxkIHRha2UgdG8gZmFkZSBvdXQgb2Ygdmlldy5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAxNTBcXG4gICAgICovXFxuICAgIGZhZGVPdXREdXJhdGlvbjogMTUwLFxcbiAgICAvKipcXG4gICAgICogRGlzYWJsZXMgaG92ZXIgZXZlbnRzIGZyb20gb3BlbmluZyB0aGUgdG9vbHRpcCBpZiBzZXQgdG8gdHJ1ZVxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIGZhbHNlXFxuICAgICAqL1xcbiAgICBkaXNhYmxlSG92ZXI6IGZhbHNlLFxcbiAgICAvKipcXG4gICAgICogT3B0aW9uYWwgYWRkdGlvbmFsIGNsYXNzZXMgdG8gYXBwbHkgdG8gdGhlIHRvb2x0aXAgdGVtcGxhdGUgb24gaW5pdC5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAnbXktY29vbC10aXAtY2xhc3MnXFxuICAgICAqL1xcbiAgICB0ZW1wbGF0ZUNsYXNzZXM6ICcnLFxcbiAgICAvKipcXG4gICAgICogTm9uLW9wdGlvbmFsIGNsYXNzIGFkZGVkIHRvIHRvb2x0aXAgdGVtcGxhdGVzLiBGb3VuZGF0aW9uIGRlZmF1bHQgaXMgJ3Rvb2x0aXAnLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlICd0b29sdGlwJ1xcbiAgICAgKi9cXG4gICAgdG9vbHRpcENsYXNzOiAndG9vbHRpcCcsXFxuICAgIC8qKlxcbiAgICAgKiBDbGFzcyBhcHBsaWVkIHRvIHRoZSB0b29sdGlwIGFuY2hvciBlbGVtZW50LlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlICdoYXMtdGlwJ1xcbiAgICAgKi9cXG4gICAgdHJpZ2dlckNsYXNzOiAnaGFzLXRpcCcsXFxuICAgIC8qKlxcbiAgICAgKiBNaW5pbXVtIGJyZWFrcG9pbnQgc2l6ZSBhdCB3aGljaCB0byBvcGVuIHRoZSB0b29sdGlwLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlICdzbWFsbCdcXG4gICAgICovXFxuICAgIHNob3dPbjogJ3NtYWxsJyxcXG4gICAgLyoqXFxuICAgICAqIEN1c3RvbSB0ZW1wbGF0ZSB0byBiZSB1c2VkIHRvIGdlbmVyYXRlIG1hcmt1cCBmb3IgdG9vbHRpcC5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAnJmx0O2RpdiBjbGFzcz1cXFwidG9vbHRpcFxcXCImZ3Q7Jmx0Oy9kaXYmZ3Q7J1xcbiAgICAgKi9cXG4gICAgdGVtcGxhdGU6ICcnLFxcbiAgICAvKipcXG4gICAgICogVGV4dCBkaXNwbGF5ZWQgaW4gdGhlIHRvb2x0aXAgdGVtcGxhdGUgb24gb3Blbi5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAnU29tZSBjb29sIHNwYWNlIGZhY3QgaGVyZS4nXFxuICAgICAqL1xcbiAgICB0aXBUZXh0OiAnJyxcXG4gICAgdG91Y2hDbG9zZVRleHQ6ICdUYXAgdG8gY2xvc2UuJyxcXG4gICAgLyoqXFxuICAgICAqIEFsbG93cyB0aGUgdG9vbHRpcCB0byByZW1haW4gb3BlbiBpZiB0cmlnZ2VyZWQgd2l0aCBhIGNsaWNrIG9yIHRvdWNoIGV2ZW50LlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIHRydWVcXG4gICAgICovXFxuICAgIGNsaWNrT3BlbjogdHJ1ZSxcXG4gICAgLyoqXFxuICAgICAqIEFkZGl0aW9uYWwgcG9zaXRpb25pbmcgY2xhc3Nlcywgc2V0IGJ5IHRoZSBKU1xcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlICd0b3AnXFxuICAgICAqL1xcbiAgICBwb3NpdGlvbkNsYXNzOiAnJyxcXG4gICAgLyoqXFxuICAgICAqIERpc3RhbmNlLCBpbiBwaXhlbHMsIHRoZSB0ZW1wbGF0ZSBzaG91bGQgcHVzaCBhd2F5IGZyb20gdGhlIGFuY2hvciBvbiB0aGUgWSBheGlzLlxcbiAgICAgKiBAb3B0aW9uXFxuICAgICAqIEBleGFtcGxlIDEwXFxuICAgICAqL1xcbiAgICB2T2Zmc2V0OiAxMCxcXG4gICAgLyoqXFxuICAgICAqIERpc3RhbmNlLCBpbiBwaXhlbHMsIHRoZSB0ZW1wbGF0ZSBzaG91bGQgcHVzaCBhd2F5IGZyb20gdGhlIGFuY2hvciBvbiB0aGUgWCBheGlzLCBpZiBhbGlnbmVkIHRvIGEgc2lkZS5cXG4gICAgICogQG9wdGlvblxcbiAgICAgKiBAZXhhbXBsZSAxMlxcbiAgICAgKi9cXG4gICAgaE9mZnNldDogMTJcXG4gIH07XFxuXFxuICAvKipcXG4gICAqIFRPRE8gdXRpbGl6ZSByZXNpemUgZXZlbnQgdHJpZ2dlclxcbiAgICovXFxuXFxuICAvLyBXaW5kb3cgZXhwb3J0c1xcbiAgRm91bmRhdGlvbi5wbHVnaW4oVG9vbHRpcCwgJ1Rvb2x0aXAnKTtcXG59KGpRdWVyeSk7XFxuXCJcblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vfi9yYXctbG9hZGVyIS4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvZm91bmRhdGlvbi5qc1xuICoqIG1vZHVsZSBpZCA9IDVcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 6 */
/***/ function(module, exports) {

	eval("'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n(function () {\n    // Overwriting the built in view.remove() function.\n    // Reasoning: I decided to do it this way because of the issues arising from\n    // the acutal destruction of my \"#container\" div\n    Backbone.View.prototype.remove = function () {\n        this.$el.empty().off();\n        this.stopListening();\n        return this;\n    };\n    // writing a custom close function for backbone views for the purpose of garbage collection\n    Backbone.View.prototype.close = function () {\n        this.remove();\n        this.unbind();\n        //prototype necessary to disconnect any model and collection events attached to a view.\n        if (this.onClose) {\n            this.onClose();\n        }\n    };\n    //A serialize object function that I saw no purpose in trying to rewrite\n    //Source: http://stackoverflow.com/questions/1184624/convert-form-data-to-javascript-object-with-jquery\n    $.fn.serializeObject = function () {\n        var o = {};\n        var a = this.serializeArray();\n        $.each(a, function () {\n            if (o[this.name] !== undefined) {\n                if (!o[this.name].push) {\n                    o[this.name] = [o[this.name]];\n                }\n                o[this.name].push(this.value || '');\n            } else {\n                o[this.name] = this.value || '';\n            }\n        });\n        return o;\n    };\n})();\n\nvar app = exports.app = app || function () {\n\n    var api = {\n        event_bus: _.extend({}, Backbone.Events),\n        views: {},\n        models: {},\n        collections: {},\n        templates: {},\n        content: null,\n        router: null,\n        init: function init() {\n            this.content = $('#container');\n\n            //Initialize Foundation\n            $(document).foundation();\n\n            window.session = new api.models.Session();\n\n            Backbone.history.start();\n            return this;\n        },\n        changeContent: function changeContent(el) {\n            this.content.empty().append(el);\n            return this;\n        },\n        //Global 'createTemplate' function\n        createTemplate: function createTemplate(templatePath, data) {\n            var templateString = window['JST'][templatePath](data);\n            return templateString;\n        },\n        //This is a helper function that will resize a parent div so that\n        //a child of the parent can be vertically aligned within\n        resizeFunction: function resizeFunction(elementArray) {\n            for (var i = 0; i < elementArray.length; i++) {\n                $('#' + elementArray[i] + '>.verticalParentHeight').each(function () {\n                    $(\".verticalParent\", this).css(\"height\", $(this).height());\n                });\n            }\n        }\n    };\n\n    //Notes on Factories:\n    // - Static views are attached the factory at initialization. Dynamic\n    //views are recreated and rereferenced to the factory object.\n    var ViewsFactory = {\n        createTemplate: function createTemplate(templatePath, data) {\n            var templateString = window['JST'][templatePath](data);\n            return templateString;\n        },\n        showView: function showView(view) {\n            if (this.currentView) {\n                this.currentView.close();\n            }\n\n            this.currentView = view;\n            this.currentView.render();\n        },\n        login: function login() {\n            if (!this.loginView) {\n                this.loginView = new api.views.login({\n                    el: $('#container'),\n                    template: this.createTemplate('templates/login.tpl'),\n                    model: new api.models.PersonLogin()\n                });\n            }\n            return this.loginView;\n        },\n        home: function home() {\n            if (!this.homeView) {\n                this.homeView = new api.views.home({\n                    el: $('#container'),\n                    template: this.createTemplate('templates/home.tpl')\n                });\n            }\n            return this.homeView;\n        },\n        loginCreation: function loginCreation() {\n            if (!this.loginCreationView) {\n                this.loginCreationView = new api.views.loginCreation({\n                    el: $('#container'),\n                    template: this.createTemplate('templates/loginCreation.tpl'),\n                    model: new api.models.PersonCreation()\n                });\n            }\n            return this.loginCreationView;\n        },\n        timeSheet: function timeSheet() {\n            this.timeSheetView = new api.views.timeSheet({\n                el: $('#container'),\n                template: this.createTemplate('templates/timeSheet.tpl')\n            });\n            return this.timeSheetView;\n        },\n        admin: function admin() {\n            this.AdminView = new api.views.admin({\n                el: $('#container'),\n                template: this.createTemplate('templates/AdminPanel.tpl'),\n                collection: new api.collections.Persons()\n            });\n            return this.AdminView;\n        }\n    };\n\n    var HeaderViewFactory = {\n        showView: function showView(view) {\n            if (this.currentView) {\n                this.currentView.close();\n            }\n\n            this.currentView = view;\n            this.currentView.render();\n        },\n        loggedInHeader: function loggedInHeader(data) {\n            this.loggedInHeaderView = new api.views.loggedInHeader({\n                el: $('#headerBar-view'),\n                model: new api.models.Logout(),\n                data: data\n            });\n            return this.loggedInHeaderView;\n        },\n        loggedOutHeader: function loggedOutHeader() {\n            if (!this.loggedOutHeaderView) {\n                this.loggedOutHeaderView = new api.views.loggedOutHeader({\n                    el: $('#headerBar-view'),\n                    template: api.createTemplate('templates/loggedOutHeader.tpl')\n                });\n            }\n            return this.loggedOutHeaderView;\n        }\n    };\n\n    var Router = Backbone.Router.extend({\n        routes: {\n            'AdminPanel': 'admin',\n            'timeSheet': 'timeSheet',\n            'CreateAccount': 'loginCreation',\n            'login': 'login',\n            '': 'home'\n        },\n        admin: function admin() {\n            app.event_bus.trigger('admin');\n        },\n        loginCreation: function loginCreation() {\n            app.event_bus.trigger('loginCreation');\n        },\n        login: function login() {\n            app.event_bus.trigger('login');\n        },\n        home: function home() {\n            app.event_bus.trigger('home');\n        },\n        timeSheet: function timeSheet() {\n            app.event_bus.trigger('timeSheet');\n        }\n    });\n    api.router = new Router();\n\n    //Route Watcher\n    // This is a replacement for the 'execute' function of the router.\n    // Was necessary as not all routes will now fire that execute function with\n    // the event driven nature of my navigation.\n    // NOTE: Using setTimeout in this function because I was getting some strange behavior in Chrome\n    // triggering an event within the 'fetch'. setTimeout ensures the call stack has been fully\n    // executed until it attempts to pass the message down the event_bus\n    var routeWatcher = {\n        inspect: function inspect(callback) {\n            //Using a cookie to handle whether or not the user has already been authenticated\n            var that = this;\n            window.session.fetch({\n                success: function success(model, response) {\n                    var route = Backbone.history.getFragment();\n                    if (response.isAuthenticated) {\n                        var data = { FirstName: response.FirstName, LastName: response.LastName };\n                        var view = HeaderViewFactory.loggedInHeader(data);\n                        HeaderViewFactory.showView(view);\n                        if (response.Role === 'ADMIN') {\n                            if (_.contains(that.requiresAuthAdmin, route)) {\n                                return callback(true);\n                            } else {\n                                window.setTimeout(function () {\n                                    app.event_bus.trigger('admin');\n                                }, 0);\n                                return callback(false);\n                            }\n                        } else {\n                            if (_.contains(that.requiresAuth, route)) {\n                                return callback(true);\n                            } else {\n                                window.setTimeout(function () {\n                                    app.event_bus.trigger('timeSheet');\n                                }, 0);\n                                return callback(false);\n                            }\n                        }\n                    } else {\n                        var view = HeaderViewFactory.loggedOutHeader();\n                        HeaderViewFactory.showView(view);\n                        if (_.contains(that.notRequireAuth, route)) {\n                            return callback(true);\n                        } else {\n                            window.setTimeout(function () {\n                                app.event_bus.trigger('login');\n                            }, 0);\n                            return callback(false);\n                        }\n                    }\n                },\n                error: function error(model, response) {\n                    console.log(\"There was an error with the server.\");\n                }\n            });\n        },\n        requiresAuthAdmin: ['AdminPanel'],\n        requiresAuth: ['timeSheet'],\n        notRequireAuth: ['CreateAccount', 'login', '']\n    };\n\n    // Tying navigation calls into an event driven architecture\n    api.event_bus.bind('home', function () {\n        api.router.navigate('');\n        routeWatcher.inspect(function (continueRouting) {\n            if (continueRouting) {\n                var view = ViewsFactory.home();\n                ViewsFactory.showView(view);\n            }\n        });\n    });\n    api.event_bus.bind('login', function () {\n        api.router.navigate('login');\n        routeWatcher.inspect(function (continueRouting) {\n            if (continueRouting) {\n                var view = ViewsFactory.login();\n                ViewsFactory.showView(view);\n            }\n        });\n    });\n    api.event_bus.bind('loginCreation', function () {\n        app.router.navigate('CreateAccount');\n        routeWatcher.inspect(function (continueRouting) {\n            if (continueRouting) {\n                var view = ViewsFactory.loginCreation();\n                ViewsFactory.showView(view);\n            }\n        });\n    });\n    api.event_bus.bind('admin', function () {\n        app.router.navigate('AdminPanel');\n        routeWatcher.inspect(function (continueRouting) {\n            if (continueRouting) {\n                var view = ViewsFactory.admin();\n                ViewsFactory.showView(view);\n            }\n        });\n    });\n    api.event_bus.bind('timeSheet', function () {\n        app.router.navigate('timeSheet');\n        routeWatcher.inspect(function (continueRouting) {\n            if (continueRouting) {\n                var view = ViewsFactory.timeSheet();\n                ViewsFactory.showView(view);\n            }\n        });\n    });\n\n    return api;\n}();\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvYXBwLmpzPzM1ZGIiXSwibmFtZXMiOlsiQmFja2JvbmUiLCJWaWV3IiwicHJvdG90eXBlIiwicmVtb3ZlIiwiJGVsIiwiZW1wdHkiLCJvZmYiLCJzdG9wTGlzdGVuaW5nIiwiY2xvc2UiLCJ1bmJpbmQiLCJvbkNsb3NlIiwiJCIsImZuIiwic2VyaWFsaXplT2JqZWN0IiwibyIsImEiLCJzZXJpYWxpemVBcnJheSIsImVhY2giLCJuYW1lIiwidW5kZWZpbmVkIiwicHVzaCIsInZhbHVlIiwiYXBwIiwiYXBpIiwiZXZlbnRfYnVzIiwiXyIsImV4dGVuZCIsIkV2ZW50cyIsInZpZXdzIiwibW9kZWxzIiwiY29sbGVjdGlvbnMiLCJ0ZW1wbGF0ZXMiLCJjb250ZW50Iiwicm91dGVyIiwiaW5pdCIsImRvY3VtZW50IiwiZm91bmRhdGlvbiIsIndpbmRvdyIsInNlc3Npb24iLCJTZXNzaW9uIiwiaGlzdG9yeSIsInN0YXJ0IiwiY2hhbmdlQ29udGVudCIsImVsIiwiYXBwZW5kIiwiY3JlYXRlVGVtcGxhdGUiLCJ0ZW1wbGF0ZVBhdGgiLCJkYXRhIiwidGVtcGxhdGVTdHJpbmciLCJyZXNpemVGdW5jdGlvbiIsImVsZW1lbnRBcnJheSIsImkiLCJsZW5ndGgiLCJjc3MiLCJoZWlnaHQiLCJWaWV3c0ZhY3RvcnkiLCJzaG93VmlldyIsInZpZXciLCJjdXJyZW50VmlldyIsInJlbmRlciIsImxvZ2luIiwibG9naW5WaWV3IiwidGVtcGxhdGUiLCJtb2RlbCIsIlBlcnNvbkxvZ2luIiwiaG9tZSIsImhvbWVWaWV3IiwibG9naW5DcmVhdGlvbiIsImxvZ2luQ3JlYXRpb25WaWV3IiwiUGVyc29uQ3JlYXRpb24iLCJ0aW1lU2hlZXQiLCJ0aW1lU2hlZXRWaWV3IiwiYWRtaW4iLCJBZG1pblZpZXciLCJjb2xsZWN0aW9uIiwiUGVyc29ucyIsIkhlYWRlclZpZXdGYWN0b3J5IiwibG9nZ2VkSW5IZWFkZXIiLCJsb2dnZWRJbkhlYWRlclZpZXciLCJMb2dvdXQiLCJsb2dnZWRPdXRIZWFkZXIiLCJsb2dnZWRPdXRIZWFkZXJWaWV3IiwiUm91dGVyIiwicm91dGVzIiwidHJpZ2dlciIsInJvdXRlV2F0Y2hlciIsImluc3BlY3QiLCJjYWxsYmFjayIsInRoYXQiLCJmZXRjaCIsInN1Y2Nlc3MiLCJyZXNwb25zZSIsInJvdXRlIiwiZ2V0RnJhZ21lbnQiLCJpc0F1dGhlbnRpY2F0ZWQiLCJGaXJzdE5hbWUiLCJMYXN0TmFtZSIsIlJvbGUiLCJjb250YWlucyIsInJlcXVpcmVzQXV0aEFkbWluIiwic2V0VGltZW91dCIsInJlcXVpcmVzQXV0aCIsIm5vdFJlcXVpcmVBdXRoIiwiZXJyb3IiLCJjb25zb2xlIiwibG9nIiwiYmluZCIsIm5hdmlnYXRlIiwiY29udGludWVSb3V0aW5nIl0sIm1hcHBpbmdzIjoiOzs7OztBQUFBLENBQUMsWUFBVTtBQUNQO0FBQ0E7QUFDQTtBQUNBQSxhQUFTQyxJQUFULENBQWNDLFNBQWQsQ0FBd0JDLE1BQXhCLEdBQWlDLFlBQVc7QUFDcEMsYUFBS0MsR0FBTCxDQUFTQyxLQUFULEdBQWlCQyxHQUFqQjtBQUNBLGFBQUtDLGFBQUw7QUFDQSxlQUFPLElBQVA7QUFDUCxLQUpEO0FBS0E7QUFDQVAsYUFBU0MsSUFBVCxDQUFjQyxTQUFkLENBQXdCTSxLQUF4QixHQUFnQyxZQUFXO0FBQ3ZDLGFBQUtMLE1BQUw7QUFDQSxhQUFLTSxNQUFMO0FBQ0E7QUFDQSxZQUFJLEtBQUtDLE9BQVQsRUFBaUI7QUFDYixpQkFBS0EsT0FBTDtBQUNIO0FBQ0osS0FQRDtBQVFBO0FBQ0E7QUFDQUMsTUFBRUMsRUFBRixDQUFLQyxlQUFMLEdBQXVCLFlBQ3ZCO0FBQ0ksWUFBSUMsSUFBSSxFQUFSO0FBQ0EsWUFBSUMsSUFBSSxLQUFLQyxjQUFMLEVBQVI7QUFDQUwsVUFBRU0sSUFBRixDQUFPRixDQUFQLEVBQVUsWUFBVztBQUNqQixnQkFBSUQsRUFBRSxLQUFLSSxJQUFQLE1BQWlCQyxTQUFyQixFQUFnQztBQUM1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LE1BQUosQ0FBVzBFLFFBQVgsQ0FBb0IsZUFBcEI7QUFDQXRCLHFCQUFhQyxPQUFiLENBQXFCLFVBQVNzQixlQUFULEVBQTBCO0FBQzNDLGdCQUFJQSxlQUFKLEVBQXFCO0FBQ2pCLG9CQUFJbkQsT0FBT0YsYUFBYVksYUFBYixFQUFYO0FBQ0FaLDZCQUFhQyxRQUFiLENBQXNCQyxJQUF0QjtBQUNIO0FBQ0osU0FMRDtBQU1ILEtBUkQ7QUFTQWxDLFFBQUlDLFNBQUosQ0FBY2tGLElBQWQsQ0FBbUIsT0FBbkIsRUFBNEIsWUFBVztBQUNuQ3BGLFlBQUlXLE1BQUosQ0FBVzBFLFFBQVgsQ0FBb0IsWUFBcEI7QUFDQXRCLHFCQUFhQyxPQUFiLENBQXFCLFVBQVNzQixlQUFULEVBQTBCO0FBQzNDLGdCQUFJQSxlQUFKLEVBQXFCO0FBQ2pCLG9CQUFJbkQsT0FBT0YsYUFBYWlCLEtBQWIsRUFBWDtBQUNBakIsNkJBQWFDLFFBQWIsQ0FBc0JDLElBQXRCO0FBQ0g7QUFDSixTQUxEO0FBTUgsS0FSRDtBQVNBbEMsUUFBSUMsU0FBSixDQUFja0YsSUFBZCxDQUFtQixXQUFuQixFQUFnQyxZQUFXO0FBQ3ZDcEYsWUFBSVcsTUFBSixDQUFXMEUsUUFBWCxDQUFvQixXQUFwQjtBQUNBdEIscUJBQWFDLE9BQWIsQ0FBcUIsVUFBU3NCLGVBQVQsRUFBMEI7QUFDM0MsZ0JBQUlBLGVBQUosRUFBcUI7QUFDakIsb0JBQUluRCxPQUFPRixhQUFhZSxTQUFiLEVBQVg7QUFDQWYsNkJBQWFDLFFBQWIsQ0FBc0JDLElBQXRCO0FBQ0g7QUFDSixTQUxEO0FBTUgsS0FSRDs7QUFVQSxXQUFPbEMsR0FBUDtBQUNILENBMVF1QixFQUFqQiIsImZpbGUiOiI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7XG4gICAgLy8gT3ZlcndyaXRpbmcgdGhlIGJ1aWx0IGluIHZpZXcucmVtb3ZlKCkgZnVuY3Rpb24uXG4gICAgLy8gUmVhc29uaW5nOiBJIGRlY2lkZWQgdG8gZG8gaXQgdGhpcyB3YXkgYmVjYXVzZSBvZiB0aGUgaXNzdWVzIGFyaXNpbmcgZnJvbVxuICAgIC8vIHRoZSBhY3V0YWwgZGVzdHJ1Y3Rpb24gb2YgbXkgXCIjY29udGFpbmVyXCIgZGl2XG4gICAgQmFja2JvbmUuVmlldy5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLiRlbC5lbXB0eSgpLm9mZigpO1xuICAgICAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuICAgIC8vIHdyaXRpbmcgYSBjdXN0b20gY2xvc2UgZnVuY3Rpb24gZm9yIGJhY2tib25lIHZpZXdzIGZvciB0aGUgcHVycG9zZSBvZiBnYXJiYWdlIGNvbGxlY3Rpb25cbiAgICBCYWNrYm9uZS5WaWV3LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICB0aGlzLnVuYmluZCgpO1xuICAgICAgICAvL3Byb3RvdHlwZSBuZWNlc3NhcnkgdG8gZGlzY29ubmVjdCBhbnkgbW9kZWwgYW5kIGNvbGxlY3Rpb24gZXZlbnRzIGF0dGFjaGVkIHRvIGEgdmlldy5cbiAgICAgICAgaWYgKHRoaXMub25DbG9zZSl7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy9BIHNlcmlhbGl6ZSBvYmplY3QgZnVuY3Rpb24gdGhhdCBJIHNhdyBubyBwdXJwb3NlIGluIHRyeWluZyB0byByZXdyaXRlXG4gICAgLy9Tb3VyY2U6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTE4NDYyNC9jb252ZXJ0LWZvcm0tZGF0YS10by1qYXZhc2NyaXB0LW9iamVjdC13aXRoLWpxdWVyeVxuICAgICQuZm4uc2VyaWFsaXplT2JqZWN0ID0gZnVuY3Rpb24oKVxuICAgIHtcbiAgICAgICAgdmFyIG8gPSB7fTtcbiAgICAgICAgdmFyIGEgPSB0aGlzLnNlcmlhbGl6ZUFycmF5KCk7XG4gICAgICAgICQuZWFjaChhLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChvW3RoaXMubmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICghb1t0aGlzLm5hbWVdLnB1c2gpIHtcbiAgICAgICAgICAgICAgICAgICAgb1t0aGlzLm5hbWVdID0gW29bdGhpcy5uYW1lXV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9bdGhpcy5uYW1lXS5wdXNoKHRoaXMudmFsdWUgfHwgJycpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvW3RoaXMubmFtZV0gPSB0aGlzLnZhbHVlIHx8ICcnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG87XG4gICAgfTtcbn0pKCk7XG5cbmV4cG9ydCB2YXIgYXBwID0gYXBwIHx8IChmdW5jdGlvbiAoKSB7XG5cblxuICAgIHZhciBhcGkgPSB7XG4gICAgICAgIGV2ZW50X2J1czogXy5leHRlbmQoe30sIEJhY2tib25lLkV2ZW50cyksXG4gICAgICAgIHZpZXdzOiB7fSxcbiAgICAgICAgbW9kZWxzOiB7fSxcbiAgICAgICAgY29sbGVjdGlvbnM6IHt9LFxuICAgICAgICB0ZW1wbGF0ZXM6IHt9LFxuICAgICAgICBjb250ZW50OiBudWxsLFxuICAgICAgICByb3V0ZXI6IG51bGwsXG4gICAgICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5jb250ZW50ID0gJCgnI2NvbnRhaW5lcicpO1xuXG4gICAgICAgICAgICAvL0luaXRpYWxpemUgRm91bmRhdGlvblxuICAgICAgICAgICAgJChkb2N1bWVudCkuZm91bmRhdGlvbigpO1xuXG4gICAgICAgICAgICB3aW5kb3cuc2Vzc2lvbiA9IG5ldyBhcGkubW9kZWxzLlNlc3Npb24oKTtcblxuICAgICAgICAgICAgQmFja2JvbmUuaGlzdG9yeS5zdGFydCgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIGNoYW5nZUNvbnRlbnQ6IGZ1bmN0aW9uKGVsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRlbnQuZW1wdHkoKS5hcHBlbmQoZWwpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG4gICAgICAgIC8vR2xvYmFsICdjcmVhdGVUZW1wbGF0ZScgZnVuY3Rpb25cbiAgICAgICAgY3JlYXRlVGVtcGxhdGU6IGZ1bmN0aW9uKHRlbXBsYXRlUGF0aCwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlU3RyaW5nID0gd2luZG93WydKU1QnXVt0ZW1wbGF0ZVBhdGhdKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHRlbXBsYXRlU3RyaW5nO1xuICAgICAgICB9LFxuICAgICAgICAvL1RoaXMgaXMgYSBoZWxwZXIgZnVuY3Rpb24gdGhhdCB3aWxsIHJlc2l6ZSBhIHBhcmVudCBkaXYgc28gdGhhdFxuICAgICAgICAvL2EgY2hpbGQgb2YgdGhlIHBhcmVudCBjYW4gYmUgdmVydGljYWxseSBhbGlnbmVkIHdpdGhpblxuICAgICAgICByZXNpemVGdW5jdGlvbjogZnVuY3Rpb24oZWxlbWVudEFycmF5KSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpICA9IDA7IGkgPCBlbGVtZW50QXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAkKCcjJytlbGVtZW50QXJyYXlbaV0rJz4udmVydGljYWxQYXJlbnRIZWlnaHQnKS5lYWNoKCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICQoXCIudmVydGljYWxQYXJlbnRcIiwgdGhpcykuY3NzKFwiaGVpZ2h0XCIsICQodGhpcykuaGVpZ2h0KCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vTm90ZXMgb24gRmFjdG9yaWVzOlxuICAgIC8vIC0gU3RhdGljIHZpZXdzIGFyZSBhdHRhY2hlZCB0aGUgZmFjdG9yeSBhdCBpbml0aWFsaXphdGlvbi4gRHluYW1pY1xuICAgIC8vdmlld3MgYXJlIHJlY3JlYXRlZCBhbmQgcmVyZWZlcmVuY2VkIHRvIHRoZSBmYWN0b3J5IG9iamVjdC5cbiAgICB2YXIgVmlld3NGYWN0b3J5ID0ge1xuICAgICAgICBjcmVhdGVUZW1wbGF0ZTogZnVuY3Rpb24odGVtcGxhdGVQYXRoLCBkYXRhKSB7XG4gICAgICAgICAgICB2YXIgdGVtcGxhdGVTdHJpbmcgPSB3aW5kb3dbJ0pTVCddW3RlbXBsYXRlUGF0aF0oZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gdGVtcGxhdGVTdHJpbmc7XG4gICAgICAgIH0sXG4gICAgICAgIHNob3dWaWV3OiBmdW5jdGlvbih2aWV3KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50Vmlldykge1xuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXcuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5jdXJyZW50VmlldyA9IHZpZXc7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3LnJlbmRlcigpO1xuICAgICAgICB9LFxuICAgICAgICBsb2dpbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZighdGhpcy5sb2dpblZpZXcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxvZ2luVmlldyA9IG5ldyBhcGkudmlld3MubG9naW4oe1xuICAgICAgICAgICAgICAgICAgICBlbDogJCgnI2NvbnRhaW5lcicpLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogdGhpcy5jcmVhdGVUZW1wbGF0ZSgndGVtcGxhdGVzL2xvZ2luLnRwbCcpLFxuICAgICAgICAgICAgICAgICAgICBtb2RlbDogbmV3IGFwaS5tb2RlbHMuUGVyc29uTG9naW4oKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9naW5WaWV3O1xuICAgICAgICB9LFxuICAgICAgICBob21lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5ob21lVmlldykge1xuICAgICAgICAgICAgICAgIHRoaXMuaG9tZVZpZXcgPSBuZXcgYXBpLnZpZXdzLmhvbWUoe1xuICAgICAgICAgICAgICAgICAgICBlbDogJCgnI2NvbnRhaW5lcicpLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogdGhpcy5jcmVhdGVUZW1wbGF0ZSgndGVtcGxhdGVzL2hvbWUudHBsJylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmhvbWVWaWV3O1xuICAgICAgICB9LFxuICAgICAgICBsb2dpbkNyZWF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5sb2dpbkNyZWF0aW9uVmlldykge1xuICAgICAgICAgICAgICAgIHRoaXMubG9naW5DcmVhdGlvblZpZXcgPSBuZXcgYXBpLnZpZXdzLmxvZ2luQ3JlYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICBlbDogJCgnI2NvbnRhaW5lcicpLFxuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogdGhpcy5jcmVhdGVUZW1wbGF0ZSgndGVtcGxhdGVzL2xvZ2luQ3JlYXRpb24udHBsJyksXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsOiBuZXcgYXBpLm1vZGVscy5QZXJzb25DcmVhdGlvbigpXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2dpbkNyZWF0aW9uVmlldztcbiAgICAgICAgfSxcbiAgICAgICAgdGltZVNoZWV0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMudGltZVNoZWV0VmlldyA9IG5ldyBhcGkudmlld3MudGltZVNoZWV0KHtcbiAgICAgICAgICAgICAgICBlbDogJCgnI2NvbnRhaW5lcicpLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiB0aGlzLmNyZWF0ZVRlbXBsYXRlKCd0ZW1wbGF0ZXMvdGltZVNoZWV0LnRwbCcpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRpbWVTaGVldFZpZXc7XG4gICAgICAgIH0sXG4gICAgICAgIGFkbWluOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuQWRtaW5WaWV3ID0gbmV3IGFwaS52aWV3cy5hZG1pbih7XG4gICAgICAgICAgICAgICAgZWw6ICQoJyNjb250YWluZXInKSxcbiAgICAgICAgICAgICAgICB0ZW1wbGF0ZTogdGhpcy5jcmVhdGVUZW1wbGF0ZSgndGVtcGxhdGVzL0FkbWluUGFuZWwudHBsJyksXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbjogbmV3IGFwaS5jb2xsZWN0aW9ucy5QZXJzb25zKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuQWRtaW5WaWV3O1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHZhciBIZWFkZXJWaWV3RmFjdG9yeSA9IHtcbiAgICAgICAgc2hvd1ZpZXc6IGZ1bmN0aW9uKHZpZXcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRWaWV3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50Vmlldy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRWaWV3ID0gdmlldztcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFZpZXcucmVuZGVyKCk7XG4gICAgICAgIH0sXG4gICAgICAgIGxvZ2dlZEluSGVhZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLmxvZ2dlZEluSGVhZGVyVmlldyA9IG5ldyBhcGkudmlld3MubG9nZ2VkSW5IZWFkZXIoe1xuICAgICAgICAgICAgICAgIGVsOiAkKCcjaGVhZGVyQmFyLXZpZXcnKSxcbiAgICAgICAgICAgICAgICBtb2RlbDogbmV3IGFwaS5tb2RlbHMuTG9nb3V0KCksXG4gICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sb2dnZWRJbkhlYWRlclZpZXc7XG4gICAgICAgIH0sXG4gICAgICAgIGxvZ2dlZE91dEhlYWRlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZighdGhpcy5sb2dnZWRPdXRIZWFkZXJWaWV3KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5sb2dnZWRPdXRIZWFkZXJWaWV3ID0gbmV3IGFwaS52aWV3cy5sb2dnZWRPdXRIZWFkZXIoe1xuICAgICAgICAgICAgICAgICAgICBlbDogJCgnI2hlYWRlckJhci12aWV3JyksXG4gICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBhcGkuY3JlYXRlVGVtcGxhdGUoJ3RlbXBsYXRlcy9sb2dnZWRPdXRIZWFkZXIudHBsJylcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxvZ2dlZE91dEhlYWRlclZpZXc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgUm91dGVyID0gQmFja2JvbmUuUm91dGVyLmV4dGVuZCh7XG4gICAgICAgIHJvdXRlczoge1xuICAgICAgICAgICAgJ0FkbWluUGFuZWwnIDogJ2FkbWluJyxcbiAgICAgICAgICAgICd0aW1lU2hlZXQnIDogJ3RpbWVTaGVldCcsXG4gICAgICAgICAgICAnQ3JlYXRlQWNjb3VudCcgOiAnbG9naW5DcmVhdGlvbicsXG4gICAgICAgICAgICAnbG9naW4nIDogJ2xvZ2luJyxcbiAgICAgICAgICAgICcnIDogJ2hvbWUnXG4gICAgICAgIH0sXG4gICAgICAgIGFkbWluOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGFwcC5ldmVudF9idXMudHJpZ2dlcignYWRtaW4nKTtcbiAgICAgICAgfSxcbiAgICAgICAgbG9naW5DcmVhdGlvbiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGFwcC5ldmVudF9idXMudHJpZ2dlcignbG9naW5DcmVhdGlvbicpO1xuICAgICAgICB9LFxuICAgICAgICBsb2dpbiA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXBwLmV2ZW50X2J1cy50cmlnZ2VyKCdsb2dpbicpO1xuICAgICAgICB9LFxuICAgICAgICBob21lIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhcHAuZXZlbnRfYnVzLnRyaWdnZXIoJ2hvbWUnKTtcbiAgICAgICAgfSxcbiAgICAgICAgdGltZVNoZWV0IDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhcHAuZXZlbnRfYnVzLnRyaWdnZXIoJ3RpbWVTaGVldCcpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgYXBpLnJvdXRlciA9IG5ldyBSb3V0ZXIoKTtcblxuICAgIC8vUm91dGUgV2F0Y2hlclxuICAgIC8vIFRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgdGhlICdleGVjdXRlJyBmdW5jdGlvbiBvZiB0aGUgcm91dGVyLlxuICAgIC8vIFdhcyBuZWNlc3NhcnkgYXMgbm90IGFsbCByb3V0ZXMgd2lsbCBub3cgZmlyZSB0aGF0IGV4ZWN1dGUgZnVuY3Rpb24gd2l0aFxuICAgIC8vIHRoZSBldmVudCBkcml2ZW4gbmF0dXJlIG9mIG15IG5hdmlnYXRpb24uXG4gICAgLy8gTk9URTogVXNpbmcgc2V0VGltZW91dCBpbiB0aGlzIGZ1bmN0aW9uIGJlY2F1c2UgSSB3YXMgZ2V0dGluZyBzb21lIHN0cmFuZ2UgYmVoYXZpb3IgaW4gQ2hyb21lXG4gICAgLy8gdHJpZ2dlcmluZyBhbiBldmVudCB3aXRoaW4gdGhlICdmZXRjaCcuIHNldFRpbWVvdXQgZW5zdXJlcyB0aGUgY2FsbCBzdGFjayBoYXMgYmVlbiBmdWxseVxuICAgIC8vIGV4ZWN1dGVkIHVudGlsIGl0IGF0dGVtcHRzIHRvIHBhc3MgdGhlIG1lc3NhZ2UgZG93biB0aGUgZXZlbnRfYnVzXG4gICAgdmFyIHJvdXRlV2F0Y2hlciA9IHtcbiAgICAgICAgaW5zcGVjdDogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgIC8vVXNpbmcgYSBjb29raWUgdG8gaGFuZGxlIHdoZXRoZXIgb3Igbm90IHRoZSB1c2VyIGhhcyBhbHJlYWR5IGJlZW4gYXV0aGVudGljYXRlZFxuICAgICAgICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgd2luZG93LnNlc3Npb24uZmV0Y2goe1xuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKG1vZGVsLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcm91dGUgPSBCYWNrYm9uZS5oaXN0b3J5LmdldEZyYWdtZW50KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5pc0F1dGhlbnRpY2F0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkYXRhID0geyBGaXJzdE5hbWU6IHJlc3BvbnNlLkZpcnN0TmFtZSwgTGFzdE5hbWU6IHJlc3BvbnNlLkxhc3ROYW1lfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gSGVhZGVyVmlld0ZhY3RvcnkubG9nZ2VkSW5IZWFkZXIoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBIZWFkZXJWaWV3RmFjdG9yeS5zaG93Vmlldyh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZS5Sb2xlID09PSAnQURNSU4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF8uY29udGFpbnModGhhdC5yZXF1aXJlc0F1dGhBZG1pbiwgcm91dGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcC5ldmVudF9idXMudHJpZ2dlcignYWRtaW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoXy5jb250YWlucyh0aGF0LnJlcXVpcmVzQXV0aCwgcm91dGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcC5ldmVudF9idXMudHJpZ2dlcigndGltZVNoZWV0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gSGVhZGVyVmlld0ZhY3RvcnkubG9nZ2VkT3V0SGVhZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBIZWFkZXJWaWV3RmFjdG9yeS5zaG93Vmlldyh2aWV3KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfLmNvbnRhaW5zKHRoYXQubm90UmVxdWlyZUF1dGgsIHJvdXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFwcC5ldmVudF9idXMudHJpZ2dlcignbG9naW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24obW9kZWwsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiVGhlcmUgd2FzIGFuIGVycm9yIHdpdGggdGhlIHNlcnZlci5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgcmVxdWlyZXNBdXRoQWRtaW46IFsnQWRtaW5QYW5lbCddLFxuICAgICAgICByZXF1aXJlc0F1dGg6IFsndGltZVNoZWV0J10sXG4gICAgICAgIG5vdFJlcXVpcmVBdXRoOiBbJ0NyZWF0ZUFjY291bnQnLCAnbG9naW4nLCAnJ11cbiAgICB9O1xuXG4gICAgLy8gVHlpbmcgbmF2aWdhdGlvbiBjYWxscyBpbnRvIGFuIGV2ZW50IGRyaXZlbiBhcmNoaXRlY3R1cmVcbiAgICBhcGkuZXZlbnRfYnVzLmJpbmQoJ2hvbWUnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgYXBpLnJvdXRlci5uYXZpZ2F0ZSgnJyk7XG4gICAgICAgIHJvdXRlV2F0Y2hlci5pbnNwZWN0KGZ1bmN0aW9uKGNvbnRpbnVlUm91dGluZykge1xuICAgICAgICAgICAgaWYgKGNvbnRpbnVlUm91dGluZykge1xuICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gVmlld3NGYWN0b3J5LmhvbWUoKTtcbiAgICAgICAgICAgICAgICBWaWV3c0ZhY3Rvcnkuc2hvd1ZpZXcodmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGFwaS5ldmVudF9idXMuYmluZCgnbG9naW4nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgYXBpLnJvdXRlci5uYXZpZ2F0ZSgnbG9naW4nKTtcbiAgICAgICAgcm91dGVXYXRjaGVyLmluc3BlY3QoZnVuY3Rpb24oY29udGludWVSb3V0aW5nKSB7XG4gICAgICAgICAgICBpZiAoY29udGludWVSb3V0aW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZpZXcgPSBWaWV3c0ZhY3RvcnkubG9naW4oKTtcbiAgICAgICAgICAgICAgICBWaWV3c0ZhY3Rvcnkuc2hvd1ZpZXcodmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGFwaS5ldmVudF9idXMuYmluZCgnbG9naW5DcmVhdGlvbicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBhcHAucm91dGVyLm5hdmlnYXRlKCdDcmVhdGVBY2NvdW50Jyk7XG4gICAgICAgIHJvdXRlV2F0Y2hlci5pbnNwZWN0KGZ1bmN0aW9uKGNvbnRpbnVlUm91dGluZykge1xuICAgICAgICAgICAgaWYgKGNvbnRpbnVlUm91dGluZykge1xuICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gVmlld3NGYWN0b3J5LmxvZ2luQ3JlYXRpb24oKTtcbiAgICAgICAgICAgICAgICBWaWV3c0ZhY3Rvcnkuc2hvd1ZpZXcodmlldyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIGFwaS5ldmVudF9idXMuYmluZCgnYWRtaW4nLCBmdW5jdGlvbigpIHtcbiAgICAgICAgYXBwLnJvdXRlci5uYXZpZ2F0ZSgnQWRtaW5QYW5lbCcpO1xuICAgICAgICByb3V0ZVdhdGNoZXIuaW5zcGVjdChmdW5jdGlvbihjb250aW51ZVJvdXRpbmcpIHtcbiAgICAgICAgICAgIGlmIChjb250aW51ZVJvdXRpbmcpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmlldyA9IFZpZXdzRmFjdG9yeS5hZG1pbigpO1xuICAgICAgICAgICAgICAgIFZpZXdzRmFjdG9yeS5zaG93Vmlldyh2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgYXBpLmV2ZW50X2J1cy5iaW5kKCd0aW1lU2hlZXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgYXBwLnJvdXRlci5uYXZpZ2F0ZSgndGltZVNoZWV0Jyk7XG4gICAgICAgIHJvdXRlV2F0Y2hlci5pbnNwZWN0KGZ1bmN0aW9uKGNvbnRpbnVlUm91dGluZykge1xuICAgICAgICAgICAgaWYgKGNvbnRpbnVlUm91dGluZykge1xuICAgICAgICAgICAgICAgIHZhciB2aWV3ID0gVmlld3NGYWN0b3J5LnRpbWVTaGVldCgpO1xuICAgICAgICAgICAgICAgIFZpZXdzRmFjdG9yeS5zaG93Vmlldyh2aWV3KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gYXBpO1xufSkoKTtcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvYXBwL2NsaWVudC1hcHAvYXBwLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	eval("var map = {\n\t\"./Logout.js\": 8,\n\t\"./Person.js\": 9,\n\t\"./PersonCreation.js\": 10,\n\t\"./PersonLogin.js\": 11,\n\t\"./ResendSignupEmail.js\": 12,\n\t\"./Session.js\": 13,\n\t\"./TimeSheet.js\": 14,\n\t\"./TokenCreation.js\": 15\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 7;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvbW9kZWxzIF4oLipcXC4oanMkKSlbXi5dKiQvZ2k/ZWFkMyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVEQUF1RDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiI3LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIG1hcCA9IHtcblx0XCIuL0xvZ291dC5qc1wiOiA4LFxuXHRcIi4vUGVyc29uLmpzXCI6IDksXG5cdFwiLi9QZXJzb25DcmVhdGlvbi5qc1wiOiAxMCxcblx0XCIuL1BlcnNvbkxvZ2luLmpzXCI6IDExLFxuXHRcIi4vUmVzZW5kU2lnbnVwRW1haWwuanNcIjogMTIsXG5cdFwiLi9TZXNzaW9uLmpzXCI6IDEzLFxuXHRcIi4vVGltZVNoZWV0LmpzXCI6IDE0LFxuXHRcIi4vVG9rZW5DcmVhdGlvbi5qc1wiOiAxNVxufTtcbmZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0KHJlcSkge1xuXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyh3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSk7XG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHRSZXNvbHZlKHJlcSkge1xuXHRyZXR1cm4gbWFwW3JlcV0gfHwgKGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiICsgcmVxICsgXCInLlwiKSB9KCkpO1xufTtcbndlYnBhY2tDb250ZXh0LmtleXMgPSBmdW5jdGlvbiB3ZWJwYWNrQ29udGV4dEtleXMoKSB7XG5cdHJldHVybiBPYmplY3Qua2V5cyhtYXApO1xufTtcbndlYnBhY2tDb250ZXh0LnJlc29sdmUgPSB3ZWJwYWNrQ29udGV4dFJlc29sdmU7XG5tb2R1bGUuZXhwb3J0cyA9IHdlYnBhY2tDb250ZXh0O1xud2VicGFja0NvbnRleHQuaWQgPSA3O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hcHAvY2xpZW50LWFwcC9tb2RlbHMgXiguKlxcLihqcyQpKVteLl0qJC9naVxuICoqIG1vZHVsZSBpZCA9IDdcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.models.Logout = Backbone.Model.extend({\n  urlRoot: '/logout'\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvbW9kZWxzL0xvZ291dC5qcz8yZTU2Il0sIm5hbWVzIjpbIm1vZGVscyIsIkxvZ291dCIsIkJhY2tib25lIiwiTW9kZWwiLCJleHRlbmQiLCJ1cmxSb290Il0sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBLFNBQUlBLE1BQUosQ0FBV0MsTUFBWCxHQUFvQkMsU0FBU0MsS0FBVCxDQUFlQyxNQUFmLENBQXNCO0FBQ3hDQyxXQUFTO0FBRCtCLENBQXRCLENBQXBCIiwiZmlsZSI6IjguanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcHAgfSBmcm9tICcuLi9hcHAnO1xuXG5hcHAubW9kZWxzLkxvZ291dCA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG4gIHVybFJvb3Q6ICcvbG9nb3V0J1xufSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvYXBwL2NsaWVudC1hcHAvbW9kZWxzL0xvZ291dC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.models.Person = Backbone.Model.extend({});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvbW9kZWxzL1BlcnNvbi5qcz9hMTBiIl0sIm5hbWVzIjpbIm1vZGVscyIsIlBlcnNvbiIsIkJhY2tib25lIiwiTW9kZWwiLCJleHRlbmQiXSwibWFwcGluZ3MiOiI7O0FBQUE7O0FBRUEsU0FBSUEsTUFBSixDQUFXQyxNQUFYLEdBQW9CQyxTQUFTQyxLQUFULENBQWVDLE1BQWYsQ0FBc0IsRUFBdEIsQ0FBcEIiLCJmaWxlIjoiOS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFwcCB9IGZyb20gJy4uL2FwcCc7XG5cbmFwcC5tb2RlbHMuUGVyc29uID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcbn0pO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2FwcC9jbGllbnQtYXBwL21vZGVscy9QZXJzb24uanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.models.PersonCreation = Backbone.Model.extend({\n  urlRoot: '/loginCreation',\n  defaults: {\n    AuthToken: '',\n    FirstName: '',\n    LastName: '',\n    Email: '',\n    ConfirmEmail: '',\n    Password: '',\n    ConfirmPassword: ''\n  },\n  validation: {\n    AuthToken: [{\n      required: true\n    }, {\n      length: 32,\n      pattern: /^[0-9a-fA-F]+$/,\n      msg: 'Invalid Authentication Token format'\n    }],\n    FirstName: [{\n      required: true\n    }, {\n      pattern: /^[a-zA-Z]+$/,\n      msg: 'Invalid First Name'\n    }],\n    LastName: [{\n      required: true\n    }, {\n      pattern: /^[a-zA-Z]+$/,\n      msg: 'Invalid Last Name'\n    }],\n    Email: [{\n      required: true\n    }, {\n      pattern: 'email',\n      msg: 'Invalid Email'\n    }],\n    ConfirmEmail: [{\n      required: true\n    }, {\n      equalTo: 'Email',\n      msg: 'Does not match Email'\n    }],\n    Password: [{\n      required: true\n    }, {\n      //One digit and one character minimum\n      pattern: /^(?=.*[\\d])(?=.*[A-Za-z])[\\w\\d!?@#$%_]{7,15}$/,\n      msg: 'Invalid Password. Must include a digit'\n    }],\n    ConfirmPassword: [{\n      required: true\n    }, {\n      equalTo: 'Password',\n      msg: 'Does not match Password'\n    }]\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvbW9kZWxzL1BlcnNvbkNyZWF0aW9uLmpzP2IzMjgiXSwibmFtZXMiOlsibW9kZWxzIiwiUGVyc29uQ3JlYXRpb24iLCJCYWNrYm9uZSIsIk1vZGVsIiwiZXh0ZW5kIiwidXJsUm9vdCIsImRlZmF1bHRzIiwiQXV0aFRva2VuIiwiRmlyc3ROYW1lIiwiTGFzdE5hbWUiLCJFbWFpbCIsIkNvbmZpcm1FbWFpbCIsIlBhc3N3b3JkIiwiQ29uZmlybVBhc3N3b3JkIiwidmFsaWRhdGlvbiIsInJlcXVpcmVkIiwibGVuZ3RoIiwicGF0dGVybiIsIm1zZyIsImVxdWFsVG8iXSwibWFwcGluZ3MiOiI7O0FBQUE7O0FBRUEsU0FBSUEsTUFBSixDQUFXQyxjQUFYLEdBQTRCQyxTQUFTQyxLQUFULENBQWVDLE1BQWYsQ0FBc0I7QUFDaERDLFdBQVMsZ0JBRHVDO0FBRWhEQyxZQUFVO0FBQ1JDLGVBQVcsRUFESDtBQUVSQyxlQUFXLEVBRkg7QUFHUkMsY0FBVSxFQUhGO0FBSVJDLFdBQU8sRUFKQztBQUtSQyxrQkFBYyxFQUxOO0FBTVJDLGNBQVUsRUFORjtBQU9SQyxxQkFBaUI7QUFQVCxHQUZzQztBQVdoREMsY0FBWTtBQUNWUCxlQUFXLENBQUM7QUFDVlEsZ0JBQVU7QUFEQSxLQUFELEVBRVI7QUFDREMsY0FBUSxFQURQO0FBRURDLGVBQVMsZ0JBRlI7QUFHREMsV0FBSztBQUhKLEtBRlEsQ0FERDtBQVFWVixlQUFXLENBQUM7QUFDVk8sZ0JBQVU7QUFEQSxLQUFELEVBRVI7QUFDREUsZUFBUyxhQURSO0FBRURDLFdBQUs7QUFGSixLQUZRLENBUkQ7QUFjVlQsY0FBVSxDQUFDO0FBQ1RNLGdCQUFVO0FBREQsS0FBRCxFQUVQO0FBQ0RFLGVBQVMsYUFEUjtBQUVEQyxXQUFLO0FBRkosS0FGTyxDQWRBO0FBb0JWUixXQUFPLENBQUM7QUFDTkssZ0JBQVU7QUFESixLQUFELEVBRUo7QUFDREUsZUFBUyxPQURSO0FBRURDLFdBQUs7QUFGSixLQUZJLENBcEJHO0FBMEJWUCxrQkFBYyxDQUFDO0FBQ2JJLGdCQUFVO0FBREcsS0FBRCxFQUVYO0FBQ0RJLGVBQVMsT0FEUjtBQUVERCxXQUFLO0FBRkosS0FGVyxDQTFCSjtBQWdDVk4sY0FBVSxDQUFDO0FBQ1RHLGdCQUFVO0FBREQsS0FBRCxFQUVQO0FBQ0Q7QUFDQUUsZUFBUywrQ0FGUjtBQUdEQyxXQUFLO0FBSEosS0FGTyxDQWhDQTtBQXVDVkwscUJBQWlCLENBQUM7QUFDaEJFLGdCQUFVO0FBRE0sS0FBRCxFQUVkO0FBQ0RJLGVBQVMsVUFEUjtBQUVERCxXQUFLO0FBRkosS0FGYztBQXZDUDtBQVhvQyxDQUF0QixDQUE1QiIsImZpbGUiOiIxMC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFwcCB9IGZyb20gJy4uL2FwcCc7XG5cbmFwcC5tb2RlbHMuUGVyc29uQ3JlYXRpb24gPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuICB1cmxSb290OiAnL2xvZ2luQ3JlYXRpb24nLFxuICBkZWZhdWx0czoge1xuICAgIEF1dGhUb2tlbjogJycsXG4gICAgRmlyc3ROYW1lOiAnJyxcbiAgICBMYXN0TmFtZTogJycsXG4gICAgRW1haWw6ICcnLFxuICAgIENvbmZpcm1FbWFpbDogJycsXG4gICAgUGFzc3dvcmQ6ICcnLFxuICAgIENvbmZpcm1QYXNzd29yZDogJydcbiAgfSxcbiAgdmFsaWRhdGlvbjoge1xuICAgIEF1dGhUb2tlbjogW3tcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSwge1xuICAgICAgbGVuZ3RoOiAzMixcbiAgICAgIHBhdHRlcm46IC9eWzAtOWEtZkEtRl0rJC8sXG4gICAgICBtc2c6ICdJbnZhbGlkIEF1dGhlbnRpY2F0aW9uIFRva2VuIGZvcm1hdCdcbiAgICB9XSxcbiAgICBGaXJzdE5hbWU6IFt7XG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC9eW2EtekEtWl0rJC8sXG4gICAgICBtc2c6ICdJbnZhbGlkIEZpcnN0IE5hbWUnXG4gICAgfV0sXG4gICAgTGFzdE5hbWU6IFt7XG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46IC9eW2EtekEtWl0rJC8sXG4gICAgICBtc2c6ICdJbnZhbGlkIExhc3QgTmFtZSdcbiAgICB9XSxcbiAgICBFbWFpbDogW3tcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSwge1xuICAgICAgcGF0dGVybjogJ2VtYWlsJyxcbiAgICAgIG1zZzogJ0ludmFsaWQgRW1haWwnXG4gICAgfV0sXG4gICAgQ29uZmlybUVtYWlsOiBbe1xuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LCB7XG4gICAgICBlcXVhbFRvOiAnRW1haWwnLFxuICAgICAgbXNnOiAnRG9lcyBub3QgbWF0Y2ggRW1haWwnXG4gICAgfV0sXG4gICAgUGFzc3dvcmQ6IFt7XG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIC8vT25lIGRpZ2l0IGFuZCBvbmUgY2hhcmFjdGVyIG1pbmltdW1cbiAgICAgIHBhdHRlcm46IC9eKD89LipbXFxkXSkoPz0uKltBLVphLXpdKVtcXHdcXGQhP0AjJCVfXXs3LDE1fSQvLFxuICAgICAgbXNnOiAnSW52YWxpZCBQYXNzd29yZC4gTXVzdCBpbmNsdWRlIGEgZGlnaXQnXG4gICAgfV0sXG4gICAgQ29uZmlybVBhc3N3b3JkOiBbe1xuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LCB7XG4gICAgICBlcXVhbFRvOiAnUGFzc3dvcmQnLFxuICAgICAgbXNnOiAnRG9lcyBub3QgbWF0Y2ggUGFzc3dvcmQnXG4gICAgfV1cbiAgfVxufSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvYXBwL2NsaWVudC1hcHAvbW9kZWxzL1BlcnNvbkNyZWF0aW9uLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.models.PersonLogin = Backbone.Model.extend({\n  urlRoot: '/login',\n  defaults: {\n    Email: '',\n    Password: ''\n  },\n  validation: {\n    Email: [{\n      required: true\n    }, {\n      pattern: 'email',\n      msg: 'Invalid Email'\n    }],\n    Password: {\n      required: true\n    }\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvbW9kZWxzL1BlcnNvbkxvZ2luLmpzPzFlYmUiXSwibmFtZXMiOlsibW9kZWxzIiwiUGVyc29uTG9naW4iLCJCYWNrYm9uZSIsIk1vZGVsIiwiZXh0ZW5kIiwidXJsUm9vdCIsImRlZmF1bHRzIiwiRW1haWwiLCJQYXNzd29yZCIsInZhbGlkYXRpb24iLCJyZXF1aXJlZCIsInBhdHRlcm4iLCJtc2ciXSwibWFwcGluZ3MiOiI7O0FBQUE7O0FBRUEsU0FBSUEsTUFBSixDQUFXQyxXQUFYLEdBQXlCQyxTQUFTQyxLQUFULENBQWVDLE1BQWYsQ0FBc0I7QUFDN0NDLFdBQVMsUUFEb0M7QUFFN0NDLFlBQVU7QUFDUkMsV0FBTyxFQURDO0FBRVJDLGNBQVU7QUFGRixHQUZtQztBQU03Q0MsY0FBWTtBQUNWRixXQUFPLENBQUM7QUFDTkcsZ0JBQVU7QUFESixLQUFELEVBRUo7QUFDREMsZUFBUyxPQURSO0FBRURDLFdBQUs7QUFGSixLQUZJLENBREc7QUFPVkosY0FBVTtBQUNSRSxnQkFBVTtBQURGO0FBUEE7QUFOaUMsQ0FBdEIsQ0FBekIiLCJmaWxlIjoiMTEuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcHAgfSBmcm9tICcuLi9hcHAnO1xuXG5hcHAubW9kZWxzLlBlcnNvbkxvZ2luID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcbiAgdXJsUm9vdDogJy9sb2dpbicsXG4gIGRlZmF1bHRzOiB7XG4gICAgRW1haWw6ICcnLFxuICAgIFBhc3N3b3JkOiAnJ1xuICB9LFxuICB2YWxpZGF0aW9uOiB7XG4gICAgRW1haWw6IFt7XG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH0sIHtcbiAgICAgIHBhdHRlcm46ICdlbWFpbCcsXG4gICAgICBtc2c6ICdJbnZhbGlkIEVtYWlsJ1xuICAgIH1dLFxuICAgIFBhc3N3b3JkOiB7XG4gICAgICByZXF1aXJlZDogdHJ1ZVxuICAgIH1cbiAgfVxufSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvYXBwL2NsaWVudC1hcHAvbW9kZWxzL1BlcnNvbkxvZ2luLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.models.ResendSignupEmail = Backbone.Model.extend({\n  urlRoot: '/resendSignupEmail'\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvbW9kZWxzL1Jlc2VuZFNpZ251cEVtYWlsLmpzPzY4MGMiXSwibmFtZXMiOlsibW9kZWxzIiwiUmVzZW5kU2lnbnVwRW1haWwiLCJCYWNrYm9uZSIsIk1vZGVsIiwiZXh0ZW5kIiwidXJsUm9vdCJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7QUFFQSxTQUFJQSxNQUFKLENBQVdDLGlCQUFYLEdBQStCQyxTQUFTQyxLQUFULENBQWVDLE1BQWYsQ0FBc0I7QUFDbkRDLFdBQVM7QUFEMEMsQ0FBdEIsQ0FBL0IiLCJmaWxlIjoiMTIuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcHAgfSBmcm9tICcuLi9hcHAnO1xuXG5hcHAubW9kZWxzLlJlc2VuZFNpZ251cEVtYWlsID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcbiAgdXJsUm9vdDogJy9yZXNlbmRTaWdudXBFbWFpbCdcbn0pO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2FwcC9jbGllbnQtYXBwL21vZGVscy9SZXNlbmRTaWdudXBFbWFpbC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.models.Session = Backbone.Model.extend({\n  urlRoot: '/session'\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvbW9kZWxzL1Nlc3Npb24uanM/NGM3MiJdLCJuYW1lcyI6WyJtb2RlbHMiLCJTZXNzaW9uIiwiQmFja2JvbmUiLCJNb2RlbCIsImV4dGVuZCIsInVybFJvb3QiXSwibWFwcGluZ3MiOiI7O0FBQUE7O0FBRUEsU0FBSUEsTUFBSixDQUFXQyxPQUFYLEdBQXFCQyxTQUFTQyxLQUFULENBQWVDLE1BQWYsQ0FBc0I7QUFDekNDLFdBQVM7QUFEZ0MsQ0FBdEIsQ0FBckIiLCJmaWxlIjoiMTMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBhcHAgfSBmcm9tICcuLi9hcHAnO1xuXG5hcHAubW9kZWxzLlNlc3Npb24gPSBCYWNrYm9uZS5Nb2RlbC5leHRlbmQoe1xuICB1cmxSb290OiAnL3Nlc3Npb24nXG59KTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9hcHAvY2xpZW50LWFwcC9tb2RlbHMvU2Vzc2lvbi5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.models.TimeSheet = Backbone.Model.extend({\n  idAttribute: 'weekStartDate'\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvbW9kZWxzL1RpbWVTaGVldC5qcz80M2MzIl0sIm5hbWVzIjpbIm1vZGVscyIsIlRpbWVTaGVldCIsIkJhY2tib25lIiwiTW9kZWwiLCJleHRlbmQiLCJpZEF0dHJpYnV0ZSJdLCJtYXBwaW5ncyI6Ijs7QUFBQTs7QUFFQSxTQUFJQSxNQUFKLENBQVdDLFNBQVgsR0FBdUJDLFNBQVNDLEtBQVQsQ0FBZUMsTUFBZixDQUFzQjtBQUMzQ0MsZUFBYTtBQUQ4QixDQUF0QixDQUF2QiIsImZpbGUiOiIxNC5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFwcCB9IGZyb20gJy4uL2FwcCc7XG5cbmFwcC5tb2RlbHMuVGltZVNoZWV0ID0gQmFja2JvbmUuTW9kZWwuZXh0ZW5kKHtcbiAgaWRBdHRyaWJ1dGU6ICd3ZWVrU3RhcnREYXRlJ1xufSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvYXBwL2NsaWVudC1hcHAvbW9kZWxzL1RpbWVTaGVldC5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.models.TokenCreation = Backbone.Model.extend({\n  urlRoot: '/tokenCreation',\n  validation: {\n    Email: [{\n      required: true\n    }, {\n      pattern: 'email',\n      msg: 'Invalid Email'\n    }],\n    ConfirmEmail: [{\n      required: true\n    }, {\n      equalTo: 'Email',\n      msg: 'Does not match Email'\n    }]\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvbW9kZWxzL1Rva2VuQ3JlYXRpb24uanM/YmU4NiJdLCJuYW1lcyI6WyJtb2RlbHMiLCJUb2tlbkNyZWF0aW9uIiwiQmFja2JvbmUiLCJNb2RlbCIsImV4dGVuZCIsInVybFJvb3QiLCJ2YWxpZGF0aW9uIiwiRW1haWwiLCJyZXF1aXJlZCIsInBhdHRlcm4iLCJtc2ciLCJDb25maXJtRW1haWwiLCJlcXVhbFRvIl0sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBLFNBQUlBLE1BQUosQ0FBV0MsYUFBWCxHQUEyQkMsU0FBU0MsS0FBVCxDQUFlQyxNQUFmLENBQXNCO0FBQy9DQyxXQUFTLGdCQURzQztBQUUvQ0MsY0FBWTtBQUNWQyxXQUFPLENBQUM7QUFDTkMsZ0JBQVU7QUFESixLQUFELEVBRUo7QUFDREMsZUFBUyxPQURSO0FBRURDLFdBQUs7QUFGSixLQUZJLENBREc7QUFPVkMsa0JBQWMsQ0FBQztBQUNiSCxnQkFBVTtBQURHLEtBQUQsRUFFWDtBQUNESSxlQUFTLE9BRFI7QUFFREYsV0FBSztBQUZKLEtBRlc7QUFQSjtBQUZtQyxDQUF0QixDQUEzQiIsImZpbGUiOiIxNS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGFwcCB9IGZyb20gJy4uL2FwcCc7XG5cbmFwcC5tb2RlbHMuVG9rZW5DcmVhdGlvbiA9IEJhY2tib25lLk1vZGVsLmV4dGVuZCh7XG4gIHVybFJvb3Q6ICcvdG9rZW5DcmVhdGlvbicsXG4gIHZhbGlkYXRpb246IHtcbiAgICBFbWFpbDogW3tcbiAgICAgIHJlcXVpcmVkOiB0cnVlXG4gICAgfSwge1xuICAgICAgcGF0dGVybjogJ2VtYWlsJyxcbiAgICAgIG1zZzogJ0ludmFsaWQgRW1haWwnXG4gICAgfV0sXG4gICAgQ29uZmlybUVtYWlsOiBbe1xuICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICB9LCB7XG4gICAgICBlcXVhbFRvOiAnRW1haWwnLFxuICAgICAgbXNnOiAnRG9lcyBub3QgbWF0Y2ggRW1haWwnXG4gICAgfV1cbiAgfVxufSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvYXBwL2NsaWVudC1hcHAvbW9kZWxzL1Rva2VuQ3JlYXRpb24uanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	eval("var map = {\n\t\"./Persons.js\": 17,\n\t\"./TimeSheets.js\": 18\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 16;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvY29sbGVjdGlvbnMgXiguKlxcLihqcyQpKVteLl0qJC9naT9iZTNlIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsdURBQXVEO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6IjE2LmpzIiwic291cmNlc0NvbnRlbnQiOlsidmFyIG1hcCA9IHtcblx0XCIuL1BlcnNvbnMuanNcIjogMTcsXG5cdFwiLi9UaW1lU2hlZXRzLmpzXCI6IDE4XG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpKTtcbn07XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdHJldHVybiBtYXBbcmVxXSB8fCAoZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIicuXCIpIH0oKSk7XG59O1xud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IDE2O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hcHAvY2xpZW50LWFwcC9jb2xsZWN0aW9ucyBeKC4qXFwuKGpzJCkpW14uXSokL2dpXG4gKiogbW9kdWxlIGlkID0gMTZcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.collections.Persons = Backbone.Collection.extend({\n  url: '/persons',\n  model: _app.app.models.Person\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvY29sbGVjdGlvbnMvUGVyc29ucy5qcz9mNWJhIl0sIm5hbWVzIjpbImNvbGxlY3Rpb25zIiwiUGVyc29ucyIsIkJhY2tib25lIiwiQ29sbGVjdGlvbiIsImV4dGVuZCIsInVybCIsIm1vZGVsIiwibW9kZWxzIiwiUGVyc29uIl0sIm1hcHBpbmdzIjoiOztBQUFBOztBQUVBLFNBQUlBLFdBQUosQ0FBZ0JDLE9BQWhCLEdBQTBCQyxTQUFTQyxVQUFULENBQW9CQyxNQUFwQixDQUEyQjtBQUNuREMsT0FBSyxVQUQ4QztBQUVuREMsU0FBTyxTQUFJQyxNQUFKLENBQVdDO0FBRmlDLENBQTNCLENBQTFCIiwiZmlsZSI6IjE3LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXBwIH0gZnJvbSAnLi4vYXBwJztcblxuYXBwLmNvbGxlY3Rpb25zLlBlcnNvbnMgPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG4gIHVybDogJy9wZXJzb25zJyxcbiAgbW9kZWw6IGFwcC5tb2RlbHMuUGVyc29uXG59KTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9hcHAvY2xpZW50LWFwcC9jb2xsZWN0aW9ucy9QZXJzb25zLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.collections.TimeSheets = Backbone.Collection.extend({\n  url: '/timeSheets',\n  model: _app.app.models.TimeSheet,\n  parse: function parse(response) {\n    return response.results;\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvY29sbGVjdGlvbnMvVGltZVNoZWV0cy5qcz85OGY2Il0sIm5hbWVzIjpbImNvbGxlY3Rpb25zIiwiVGltZVNoZWV0cyIsIkJhY2tib25lIiwiQ29sbGVjdGlvbiIsImV4dGVuZCIsInVybCIsIm1vZGVsIiwibW9kZWxzIiwiVGltZVNoZWV0IiwicGFyc2UiLCJyZXNwb25zZSIsInJlc3VsdHMiXSwibWFwcGluZ3MiOiI7O0FBQUE7O0FBRUEsU0FBSUEsV0FBSixDQUFnQkMsVUFBaEIsR0FBNkJDLFNBQVNDLFVBQVQsQ0FBb0JDLE1BQXBCLENBQTJCO0FBQ3REQyxPQUFLLGFBRGlEO0FBRXREQyxTQUFPLFNBQUlDLE1BQUosQ0FBV0MsU0FGb0M7QUFHdERDLFNBQU8sZUFBU0MsUUFBVCxFQUFtQjtBQUN4QixXQUFPQSxTQUFTQyxPQUFoQjtBQUNEO0FBTHFELENBQTNCLENBQTdCIiwiZmlsZSI6IjE4LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgYXBwIH0gZnJvbSAnLi4vYXBwJztcblxuYXBwLmNvbGxlY3Rpb25zLlRpbWVTaGVldHMgPSBCYWNrYm9uZS5Db2xsZWN0aW9uLmV4dGVuZCh7XG4gIHVybDogJy90aW1lU2hlZXRzJyxcbiAgbW9kZWw6IGFwcC5tb2RlbHMuVGltZVNoZWV0LFxuICBwYXJzZTogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UucmVzdWx0cztcbiAgfVxufSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvYXBwL2NsaWVudC1hcHAvY29sbGVjdGlvbnMvVGltZVNoZWV0cy5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	eval("var map = {\n\t\"./admin.js\": 20,\n\t\"./calendar.js\": 21,\n\t\"./home.js\": 22,\n\t\"./loggedInHeader.js\": 23,\n\t\"./loggedOutHeader.js\": 24,\n\t\"./login.js\": 25,\n\t\"./loginCreation.js\": 26,\n\t\"./personCollection.js\": 27,\n\t\"./timeSelector.js\": 29,\n\t\"./timeSelectorDay.js\": 30,\n\t\"./timeSheet.js\": 31,\n\t\"./unverifiedUser.js\": 32,\n\t\"./verifiedUser.js\": 33\n};\nfunction webpackContext(req) {\n\treturn __webpack_require__(webpackContextResolve(req));\n};\nfunction webpackContextResolve(req) {\n\treturn map[req] || (function() { throw new Error(\"Cannot find module '\" + req + \"'.\") }());\n};\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = 19;\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvdmlld3MgXiguKlxcLihqcyQpKVteLl0qJC9naT82N2NiIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHVEQUF1RDtBQUN4RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIxOS5qcyIsInNvdXJjZXNDb250ZW50IjpbInZhciBtYXAgPSB7XG5cdFwiLi9hZG1pbi5qc1wiOiAyMCxcblx0XCIuL2NhbGVuZGFyLmpzXCI6IDIxLFxuXHRcIi4vaG9tZS5qc1wiOiAyMixcblx0XCIuL2xvZ2dlZEluSGVhZGVyLmpzXCI6IDIzLFxuXHRcIi4vbG9nZ2VkT3V0SGVhZGVyLmpzXCI6IDI0LFxuXHRcIi4vbG9naW4uanNcIjogMjUsXG5cdFwiLi9sb2dpbkNyZWF0aW9uLmpzXCI6IDI2LFxuXHRcIi4vcGVyc29uQ29sbGVjdGlvbi5qc1wiOiAyNyxcblx0XCIuL3RpbWVTZWxlY3Rvci5qc1wiOiAyOSxcblx0XCIuL3RpbWVTZWxlY3RvckRheS5qc1wiOiAzMCxcblx0XCIuL3RpbWVTaGVldC5qc1wiOiAzMSxcblx0XCIuL3VudmVyaWZpZWRVc2VyLmpzXCI6IDMyLFxuXHRcIi4vdmVyaWZpZWRVc2VyLmpzXCI6IDMzXG59O1xuZnVuY3Rpb24gd2VicGFja0NvbnRleHQocmVxKSB7XG5cdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKHdlYnBhY2tDb250ZXh0UmVzb2x2ZShyZXEpKTtcbn07XG5mdW5jdGlvbiB3ZWJwYWNrQ29udGV4dFJlc29sdmUocmVxKSB7XG5cdHJldHVybiBtYXBbcmVxXSB8fCAoZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIgKyByZXEgKyBcIicuXCIpIH0oKSk7XG59O1xud2VicGFja0NvbnRleHQua2V5cyA9IGZ1bmN0aW9uIHdlYnBhY2tDb250ZXh0S2V5cygpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKG1hcCk7XG59O1xud2VicGFja0NvbnRleHQucmVzb2x2ZSA9IHdlYnBhY2tDb250ZXh0UmVzb2x2ZTtcbm1vZHVsZS5leHBvcnRzID0gd2VicGFja0NvbnRleHQ7XG53ZWJwYWNrQ29udGV4dC5pZCA9IDE5O1xuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9hcHAvY2xpZW50LWFwcC92aWV3cyBeKC4qXFwuKGpzJCkpW14uXSokL2dpXG4gKiogbW9kdWxlIGlkID0gMTlcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.views.admin = Backbone.View.extend({\n  initialize: function initialize(data) {\n    this.options = data;\n\n    this.tokenCreationModel = new _app.app.models.TokenCreation();\n\n    this.template = _.template(this.options.template);\n\n    Backbone.Validation.bind(this, {\n      model: this.tokenCreationModel,\n      valid: function valid(view, attr) {\n        var element = view.$(\"[name=\" + attr + \"]\");\n        var parent = element.closest('.inputWrapper');\n        element.removeClass('error');\n        parent.find('small.error').html('').addClass('hidden');\n      },\n      invalid: function invalid(view, attr, error) {\n        //Hide server errors if input error arises\n        $('#serverError').html('').addClass('hidden');\n        var element = view.$(\"[name=\" + attr + \"]\");\n        var parent = element.closest('.inputWrapper');\n        element.addClass('error');\n        parent.find('small.error').html(error).removeClass('hidden');\n      }\n    });\n  },\n  render: function render() {\n    var that = this;\n\n    this.unverifiedPersons = new _app.app.collections.Persons();\n    this.verifiedPersons = new _app.app.collections.Persons();\n\n    //Render Parent\n    that.$el.html(that.template({}));\n\n    this.verifiedPersons.fetch({\n      data: { verified: true },\n      success: function success(collection, response, options) {\n        that.verifiedCollectionView = new _app.app.views.personCollectionView({\n          collection: that.verifiedPersons,\n          childView: _app.app.views.verifiedUser,\n          el: $('#verifiedUsers-view')\n        });\n\n        that.verifiedCollectionView.render();\n      }\n    });\n\n    this.unverifiedPersons.fetch({\n      data: { verified: false },\n      success: function success(collection, response, options) {\n        that.unverifiedCollectionView = new _app.app.views.personCollectionView({\n          collection: that.unverifiedPersons,\n          childView: _app.app.views.unverifiedUser,\n          el: $('#unverifiedUsers-view')\n        });\n\n        that.unverifiedCollectionView.render();\n      }\n    });\n\n    this.delegateEvents();\n  },\n  events: {\n    'click .verified.user': 'expandUserInfo',\n    'click .unverified.user': 'expandUserInfo',\n    'click #submitCreateUserButton': 'createToken'\n  },\n  expandUserInfo: function expandUserInfo(element) {\n    var toggleElement = $(element.currentTarget).next('.personInfo');\n    if ($(toggleElement).height() !== 0) {\n      $(toggleElement).height(\"0px\");\n    } else {\n      this.fetchUserInfo(toggleElement);\n    }\n  },\n  fetchUserInfo: function fetchUserInfo(toggleElement) {\n    var totalHeight = 0;\n    $(toggleElement).children().each(function () {\n      totalHeight += $(this).outerHeight(true);\n    });\n    $(toggleElement).height(totalHeight + \"px\");\n  },\n  createToken: function createToken() {\n    var that = this;\n    event.preventDefault();\n    var data = $('#createUserRequest').serializeObject();\n    this.tokenCreationModel.set(data);\n    if (this.tokenCreationModel.isValid(true)) {\n      this.tokenCreationModel.save({\n        Email: data.Email\n      }, {\n        success: function success(model, response) {\n          $('#signupEmailModal').foundation('reveal', 'open');\n          $('#serverError').html('').addClass('hidden');\n          $('#createUserRequest')[0].reset();\n          that.unverifiedCollectionView.collection.fetch({\n            data: { verified: false }\n          });\n        },\n        error: function error(model, response) {\n          $('#serverError').html(response.responseJSON.message).removeClass('hidden');\n        }\n      });\n    }\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvdmlld3MvYWRtaW4uanM/MTE4MCJdLCJuYW1lcyI6WyJ2aWV3cyIsImFkbWluIiwiQmFja2JvbmUiLCJWaWV3IiwiZXh0ZW5kIiwiaW5pdGlhbGl6ZSIsImRhdGEiLCJvcHRpb25zIiwidG9rZW5DcmVhdGlvbk1vZGVsIiwibW9kZWxzIiwiVG9rZW5DcmVhdGlvbiIsInRlbXBsYXRlIiwiXyIsIlZhbGlkYXRpb24iLCJiaW5kIiwibW9kZWwiLCJ2YWxpZCIsInZpZXciLCJhdHRyIiwiZWxlbWVudCIsIiQiLCJwYXJlbnQiLCJjbG9zZXN0IiwicmVtb3ZlQ2xhc3MiLCJmaW5kIiwiaHRtbCIsImFkZENsYXNzIiwiaW52YWxpZCIsImVycm9yIiwicmVuZGVyIiwidGhhdCIsInVudmVyaWZpZWRQZXJzb25zIiwiY29sbGVjdGlvbnMiLCJQZXJzb25zIiwidmVyaWZpZWRQZXJzb25zIiwiJGVsIiwiZmV0Y2giLCJ2ZXJpZmllZCIsInN1Y2Nlc3MiLCJjb2xsZWN0aW9uIiwicmVzcG9uc2UiLCJ2ZXJpZmllZENvbGxlY3Rpb25WaWV3IiwicGVyc29uQ29sbGVjdGlvblZpZXciLCJjaGlsZFZpZXciLCJ2ZXJpZmllZFVzZXIiLCJlbCIsInVudmVyaWZpZWRDb2xsZWN0aW9uVmlldyIsInVudmVyaWZpZWRVc2VyIiwiZGVsZWdhdGVFdmVudHMiLCJldmVudHMiLCJleHBhbmRVc2VySW5mbyIsInRvZ2dsZUVsZW1lbnQiLCJjdXJyZW50VGFyZ2V0IiwibmV4dCIsImhlaWdodCIsImZldGNoVXNlckluZm8iLCJ0b3RhbEhlaWdodCIsImNoaWxkcmVuIiwiZWFjaCIsIm91dGVySGVpZ2h0IiwiY3JlYXRlVG9rZW4iLCJldmVudCIsInByZXZlbnREZWZhdWx0Iiwic2VyaWFsaXplT2JqZWN0Iiwic2V0IiwiaXNWYWxpZCIsInNhdmUiLCJFbWFpbCIsImZvdW5kYXRpb24iLCJyZXNldCIsInJlc3BvbnNlSlNPTiIs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QnlELE9BQXhCLENBQWdDLElBQWhDLENBQUosRUFBMkM7QUFDdkMsV0FBS3pELGtCQUFMLENBQXdCMEQsSUFBeEIsQ0FBNkI7QUFDekJDLGVBQU83RCxLQUFLNkQ7QUFEYSxPQUE3QixFQUVHO0FBQ0M3QixpQkFBUyxpQkFBU3ZCLEtBQVQsRUFBZ0J5QixRQUFoQixFQUEwQjtBQUNqQ3BCLFlBQUUsbUJBQUYsRUFBdUJnRCxVQUF2QixDQUFrQyxRQUFsQyxFQUE0QyxNQUE1QztBQUNBaEQsWUFBRSxjQUFGLEVBQWtCSyxJQUFsQixDQUF1QixFQUF2QixFQUEyQkMsUUFBM0IsQ0FBb0MsUUFBcEM7QUFDQU4sWUFBRSxvQkFBRixFQUF3QixDQUF4QixFQUEyQmlELEtBQTNCO0FBQ0F2QyxlQUFLZ0Isd0JBQUwsQ0FBOEJQLFVBQTlCLENBQXlDSCxLQUF6QyxDQUErQztBQUM3QzlCLGtCQUFNLEVBQUUrQixVQUFVLEtBQVo7QUFEdUMsV0FBL0M7QUFHRCxTQVJGO0FBU0NULGVBQU8sZUFBU2IsS0FBVCxFQUFnQnlCLFFBQWhCLEVBQTBCO0FBQzdCcEIsWUFBRSxjQUFGLEVBQWtCSyxJQUFsQixDQUF1QmUsU0FBUzhCLFlBQVQsQ0FBc0JDLE9BQTdDLEVBQXNEaEQsV0FBdEQsQ0FBa0UsUUFBbEU7QUFDSDtBQVhGLE9BRkg7QUFlSDtBQUNGO0FBekdvQyxDQUFyQixDQUFsQiIsImZpbGUiOiIyMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IGFwcCB9IGZyb20gJy4uL2FwcCc7XG5cbmFwcC52aWV3cy5hZG1pbiA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZGF0YSkge1xuICAgIHRoaXMub3B0aW9ucyA9IGRhdGE7XG5cbiAgICB0aGlzLnRva2VuQ3JlYXRpb25Nb2RlbCA9IG5ldyBhcHAubW9kZWxzLlRva2VuQ3JlYXRpb24oKTtcblxuICAgIHRoaXMudGVtcGxhdGUgPSBfLnRlbXBsYXRlKHRoaXMub3B0aW9ucy50ZW1wbGF0ZSk7XG5cbiAgICBCYWNrYm9uZS5WYWxpZGF0aW9uLmJpbmQodGhpcywge1xuICAgICAgbW9kZWw6IHRoaXMudG9rZW5DcmVhdGlvbk1vZGVsLFxuICAgICAgdmFsaWQ6IGZ1bmN0aW9uKHZpZXcsIGF0dHIpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB2aWV3LiQoXCJbbmFtZT1cIithdHRyK1wiXVwiKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsZW1lbnQuY2xvc2VzdCgnLmlucHV0V3JhcHBlcicpO1xuICAgICAgICBlbGVtZW50LnJlbW92ZUNsYXNzKCdlcnJvcicpO1xuICAgICAgICBwYXJlbnQuZmluZCgnc21hbGwuZXJyb3InKS5odG1sKCcnKS5hZGRDbGFzcygnaGlkZGVuJyk7XG4gICAgICB9LFxuICAgICAgaW52YWxpZDogZnVuY3Rpb24odmlldywgYXR0ciwgZXJyb3IpIHtcbiAgICAgICAgLy9IaWRlIHNlcnZlciBlcnJvcnMgaWYgaW5wdXQgZXJyb3IgYXJpc2VzXG4gICAgICAgICQoJyNzZXJ2ZXJFcnJvcicpLmh0bWwoJycpLmFkZENsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSB2aWV3LiQoXCJbbmFtZT1cIithdHRyK1wiXVwiKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IGVsZW1lbnQuY2xvc2VzdCgnLmlucHV0V3JhcHBlcicpO1xuICAgICAgICBlbGVtZW50LmFkZENsYXNzKCdlcnJvcicpO1xuICAgICAgICBwYXJlbnQuZmluZCgnc21hbGwuZXJyb3InKS5odG1sKGVycm9yKS5yZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG4gIHJlbmRlcjogZnVuY3Rpb24oKXtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICB0aGlzLnVudmVyaWZpZWRQZXJzb25zID0gbmV3IGFwcC5jb2xsZWN0aW9ucy5QZXJzb25zKCk7XG4gICAgdGhpcy52ZXJpZmllZFBlcnNvbnMgPSBuZXcgYXBwLmNvbGxlY3Rpb25zLlBlcnNvbnMoKTtcblxuICAgIC8vUmVuZGVyIFBhcmVudFxuICAgIHRoYXQuJGVsLmh0bWwodGhhdC50ZW1wbGF0ZSh7fSkpO1xuXG4gICAgdGhpcy52ZXJpZmllZFBlcnNvbnMuZmV0Y2goe1xuICAgICAgZGF0YTogeyB2ZXJpZmllZDogdHJ1ZSB9LFxuICAgICAgc3VjY2VzczogZnVuY3Rpb24gKGNvbGxlY3Rpb24sIHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgICAgIHRoYXQudmVyaWZpZWRDb2xsZWN0aW9uVmlldyA9IG5ldyBhcHAudmlld3MucGVyc29uQ29sbGVjdGlvblZpZXcoe1xuICAgICAgICAgIGNvbGxlY3Rpb246IHRoYXQudmVyaWZpZWRQZXJzb25zLFxuICAgICAgICAgIGNoaWxkVmlldzogYXBwLnZpZXdzLnZlcmlmaWVkVXNlcixcbiAgICAgICAgICBlbDogJCgnI3ZlcmlmaWVkVXNlcnMtdmlldycpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoYXQudmVyaWZpZWRDb2xsZWN0aW9uVmlldy5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHRoaXMudW52ZXJpZmllZFBlcnNvbnMuZmV0Y2goe1xuICAgICAgZGF0YTogeyB2ZXJpZmllZDogZmFsc2UgfSxcbiAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uIChjb2xsZWN0aW9uLCByZXNwb25zZSwgb3B0aW9ucykge1xuICAgICAgICB0aGF0LnVudmVyaWZpZWRDb2xsZWN0aW9uVmlldyA9IG5ldyBhcHAudmlld3MucGVyc29uQ29sbGVjdGlvblZpZXcoe1xuICAgICAgICAgIGNvbGxlY3Rpb246IHRoYXQudW52ZXJpZmllZFBlcnNvbnMsXG4gICAgICAgICAgY2hpbGRWaWV3OiBhcHAudmlld3MudW52ZXJpZmllZFVzZXIsXG4gICAgICAgICAgZWw6ICQoJyN1bnZlcmlmaWVkVXNlcnMtdmlldycpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoYXQudW52ZXJpZmllZENvbGxlY3Rpb25WaWV3LnJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICB9LFxuICBldmVudHM6IHtcbiAgICAnY2xpY2sgLnZlcmlmaWVkLnVzZXInIDogJ2V4cGFuZFVzZXJJbmZvJyxcbiAgICAnY2xpY2sgLnVudmVyaWZpZWQudXNlcicgOiAnZXhwYW5kVXNlckluZm8nLFxuICAgICdjbGljayAjc3VibWl0Q3JlYXRlVXNlckJ1dHRvbicgOiAnY3JlYXRlVG9rZW4nXG4gIH0sXG4gIGV4cGFuZFVzZXJJbmZvOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdmFyIHRvZ2dsZUVsZW1lbnQgPSAkKGVsZW1lbnQuY3VycmVudFRhcmdldCkubmV4dCgnLnBlcnNvbkluZm8nKTtcbiAgICBpZiAoJCh0b2dnbGVFbGVtZW50KS5oZWlnaHQoKSAhPT0gMCkge1xuICAgICAgJCh0b2dnbGVFbGVtZW50KS5oZWlnaHQoXCIwcHhcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZmV0Y2hVc2VySW5mbyh0b2dnbGVFbGVtZW50KTtcbiAgICB9XG4gIH0sXG4gIGZldGNoVXNlckluZm86IGZ1bmN0aW9uKHRvZ2dsZUVsZW1lbnQpIHtcbiAgICB2YXIgdG90YWxIZWlnaHQgPSAwO1xuICAgICQodG9nZ2xlRWxlbWVudCkuY2hpbGRyZW4oKS5lYWNoKGZ1bmN0aW9uKCkge1xuICAgICAgdG90YWxIZWlnaHQgKz0gJCh0aGlzKS5vdXRlckhlaWdodCh0cnVlKTtcbiAgICB9KTtcbiAgICAkKHRvZ2dsZUVsZW1lbnQpLmhlaWdodCh0b3RhbEhlaWdodCtcInB4XCIpO1xuICB9LFxuICBjcmVhdGVUb2tlbjogZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdmFyIGRhdGEgPSAkKCcjY3JlYXRlVXNlclJlcXVlc3QnKS5zZXJpYWxpemVPYmplY3QoKTtcbiAgICB0aGlzLnRva2VuQ3JlYXRpb25Nb2RlbC5zZXQoZGF0YSk7XG4gICAgaWYgKHRoaXMudG9rZW5DcmVhdGlvbk1vZGVsLmlzVmFsaWQodHJ1ZSkpIHtcbiAgICAgICAgdGhpcy50b2tlbkNyZWF0aW9uTW9kZWwuc2F2ZSh7XG4gICAgICAgICAgICBFbWFpbDogZGF0YS5FbWFpbFxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihtb2RlbCwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgJCgnI3NpZ251cEVtYWlsTW9kYWwnKS5mb3VuZGF0aW9uKCdyZXZlYWwnLCAnb3BlbicpO1xuICAgICAgICAgICAgICAkKCcjc2VydmVyRXJyb3InKS5odG1sKCcnKS5hZGRDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICQoJyNjcmVhdGVVc2VyUmVxdWVzdCcpWzBdLnJlc2V0KCk7XG4gICAgICAgICAgICAgIHRoYXQudW52ZXJpZmllZENvbGxlY3Rpb25WaWV3LmNvbGxlY3Rpb24uZmV0Y2goe1xuICAgICAgICAgICAgICAgIGRhdGE6IHsgdmVyaWZpZWQ6IGZhbHNlIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKG1vZGVsLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICQoJyNzZXJ2ZXJFcnJvcicpLmh0bWwocmVzcG9uc2UucmVzcG9uc2VKU09OLm1lc3NhZ2UpLnJlbW92ZUNsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICB9XG59KTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9hcHAvY2xpZW50LWFwcC92aWV3cy9hZG1pbi5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.views.Calendar = Backbone.View.extend({\n  initialize: function initialize(data) {\n    this.options = data;\n    this.listenTo(_app.app.event_bus, 'inputChange', this.registerInputChange);\n    this.timeSelectorInputChanged = false;\n    this.selectedWeekId = '';\n  },\n  render: function render() {\n    this.setElement($(this.options.el));\n    var that = this;\n    $(this.options.el).clndr({\n      render: function render(data) {\n        this.template = _.template(_app.app.createTemplate('templates/clndr.tpl', data));\n        return this.template;\n      },\n      clickEvents: {\n        onMonthChange: function onMonthChange(month) {\n          that.fetchCollection(month, function (err) {\n            if (err) return console.log(err);\n            var weekSelectorDate = moment.utc(that.collection.at(0).get('weekStartDate')).format('YYYY-MM-DD');\n            that.renderNextPrevButtons();\n            that.renderDays(weekSelectorDate);\n          });\n        }\n      }\n    });\n\n    this.fetchCollection(this.options.renderWeekStartDate, function (err) {\n      that.renderDays(that.options.renderWeekStartDate);\n      that.renderNextPrevButtons();\n      that.delegateEvents();\n    });\n  },\n  events: {\n    'click .weekDiv': 'checkInputWeekSelected',\n    'click #changeTimeSheetNo': 'unregisterWeekSelected',\n    'click #changeTimeSheetYes': 'registerWeekSelected'\n  },\n  registerInputChange: function registerInputChange() {\n    this.timeSelectorInputChanged = true;\n  },\n  renderDays: function renderDays(weekSelectorDate) {\n    //render week divs on top of calendar\n    var daysContainer = document.getElementById('daysContainer');\n    var startWeekDate = moment.utc(this.collection.at(0).get('weekStartDate'));\n    var endWeekDate = moment.utc(this.collection.at(this.collection.length - 1).get('weekStartDate'));\n    for (startWeekDate; moment(startWeekDate).isSameOrBefore(endWeekDate); startWeekDate = moment(startWeekDate).add(1, 'w')) {\n      var weekDiv = document.createElement('div');\n      var weekDivSpan = document.createElement('span');\n      var formattedDate = moment(startWeekDate).format('YYYY-MM-DD');\n      var weekStartDayDiv = document.getElementById(formattedDate);\n      weekDiv.id = formattedDate + '-weekDiv';\n      weekDiv.className = 'weekDiv';\n\n      //complete || incomplete || empty\n      var model = this.collection.find(function (timeSheet) {\n        var modelStartDate = moment(timeSheet.get('weekStartDate'));\n        return moment(modelStartDate).isSame(startWeekDate);\n      });\n      if (model) {\n        if (model.get('totalTime') === null) {\n          weekDiv.className += ' incomplete';\n          weekDiv.dataset.date = formattedDate;\n          weekDivSpan.innerHTML = 'Incomplete';\n        } else {\n          weekDiv.className += ' complete';\n          weekDiv.dataset.date = formattedDate;\n          weekDivSpan.innerHTML = 'Complete';\n        }\n      }\n      weekDiv.appendChild(weekDivSpan);\n      daysContainer.appendChild(weekDiv);\n\n      //Shift to location\n\n      weekDiv.style.top = weekStartDayDiv.offsetTop + 'px';\n      weekDiv.style.left = weekStartDayDiv.offsetLeft + 'px';\n    }\n    this.shiftWeekSelector(weekSelectorDate);\n  },\n  checkInputWeekSelected: function checkInputWeekSelected(element) {\n    this.selectedWeekId = element.currentTarget.id;\n    if (this.timeSelectorInputChanged) {\n      //Temporarily shifting view element to global to catch modal events\n      this.setElement($('#changeTimeSheetModal').foundation('reveal', 'open'));\n    } else {\n      this.registerWeekSelected();\n    }\n  },\n  unregisterWeekSelected: function unregisterWeekSelected() {\n    $('#changeTimeSheetModal').foundation('reveal', 'close');\n    //switching back to proper view element\n    this.setElement($(this.options.el));\n  },\n  registerWeekSelected: function registerWeekSelected() {\n    $('#changeTimeSheetModal').foundation('reveal', 'close');\n    //switching back to proper view element\n    this.setElement($(this.options.el));\n    var weekDiv = document.getElementById(this.selectedWeekId);\n    $('.selected').removeClass('selected');\n    this.shiftWeekSelector(weekDiv.dataset.date);\n    weekDiv.className += ' selected';\n  },\n  shiftWeekSelector: function shiftWeekSelector(date) {\n    this.trigger('timeSelector', date);\n    this.timeSelectorInputChanged = false;\n    var weekStartDayDiv = document.getElementById(date);\n    var weekSelector = document.getElementById('weekSelector');\n    var weekDiv = document.getElementById(date + '-weekDiv');\n    weekDiv.className += ' selected';\n    weekSelector.style.top = weekStartDayDiv.offsetTop + 'px';\n    weekSelector.style.left = weekStartDayDiv.offsetLeft + 'px';\n  },\n  renderNextPrevButtons: function renderNextPrevButtons() {\n    if (this.options.next) {\n      $('.clndr-next-button').removeClass('inactive');\n    } else {\n      $('.clndr-next-button').addClass('inactive');\n    }\n    if (this.options.prev) {\n      $('.clndr-previous-button').removeClass('inactive');\n    } else {\n      $('.clndr-previous-button').addClass('inactive');\n    }\n  },\n  fetchCollection: function fetchCollection(date, done) {\n    var that = this;\n    var initializedSelectStartDate, initializedSelectEndDate;\n\n    //Check for prev/next month mondays viewable\n    var prevMonthMonday = document.getElementsByClassName('last-month monday');\n    if (prevMonthMonday.length) {\n      initializedSelectStartDate = prevMonthMonday[0].id;\n    } else {\n      initializedSelectStartDate = moment(date).startOf('month').format('YYYY-MM-DD');\n    }\n    var nextMonthMonday = document.getElementsByClassName('next-month monday');\n    if (nextMonthMonday.length) {\n      initializedSelectEndDate = nextMonthMonday[0].id;\n    } else {\n      initializedSelectEndDate = moment(date).endOf('month').format('YYYY-MM-DD');\n    }\n    this.collection.fetch({\n      reset: true,\n      data: {\n        timeSelectorWeekDate: moment(date).startOf('isoWeek').format('YYYY-MM-DD'),\n        selectStartDate: initializedSelectStartDate,\n        selectEndDate: initializedSelectEndDate\n      },\n      success: function success(collection, response, options) {\n        that.options.next = response.next;\n        that.options.prev = response.prev;\n        done(null);\n      },\n      error: function error(collection, response, options) {\n        //handle server error\n        done(err);\n      }\n    });\n  }\n}); //NOTES:\n// - Reading it sounds like innerHTML opens the possibility for XSS attacks\n// though only when you are using user input. Just something to keep in mind.\n// - Next/Prev month rerenders the 'days' subview of the calendar. With that,\n// I'm recreating the necessary DOM elements each time.\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvdmlld3MvY2FsZW5kYXIuanM/MjA0YiJdLCJuYW1lcyI6WyJ2aWV3cyIsIkNhbGVuZGFyIiwiQmFja2JvbmUiLCJWaWV3IiwiZXh0ZW5kIiwiaW5pdGlhbGl6ZSIsImRhdGEiLCJvcHRpb25zIiwibGlzdGVuVG8iLCJldmVudF9idXMiLCJyZWdpc3RlcklucHV0Q2hhbmdlIiwidGltZVNlbGVjdG9ySW5wdXRDaGFuZ2VkIiwic2VsZWN0ZWRXZWVrSWQiLCJyZW5kZXIiLCJzZXRFbGVtZW50IiwiJCIsImVsIiwidGhhdCIsImNsbmRyIiwidGVtcGxhdGUiLCJfIiwiY3JlYXRlVGVtcGxhdGUiLCJjbGlja0V2ZW50cyIsIm9uTW9udGhDaGFuZ2UiLCJtb250aCIsImZldGNoQ29sbGVjdGlvbiIsImVyciIsImNvbnNvbGUiLCJsb2ciLCJ3ZWVrU2VsZWN0b3JEYXRlIiwibW9tZW50IiwidXRjIiwiY29sbGVjdGlvbiIsImF0IiwiZ2V0IiwiZm9ybWF0IiwicmVuZGVyTmV4dFByZXZCdXR0b25zIiwicmVuZGVyRGF5cyIsInJlbmRlcldlZWtTdGFydERhdGUiLCJkZWxlZ2F0ZUV2ZW50cyIsImV2ZW50cyIsImRheXNDb250YWluZXIiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwic3RhcnRXZWVrRGF0ZSIsImVuZFdlZWtEYXRlIiwibGVuZ3RoIiwiaXNTYW1lT3JCZWZvcmUiLCJhZGQiLCJ3ZWVrRGl2IiwiY3JlYXRlRWxlbWVudCIsIndlZWtEaXZTcGFuIiwiZm9ybWF0dGVkRGF0ZSIsIndlZWtTdGFydERheURpdiIsImlkIiwiY2xhc3NOYW1lIiwibW9kZWwiLCJmaW5kIiwidGltZVNoZWV0IiwibW9kZWxTdGFydERhdGUiLCJpc1NhbWUiLCJkYXRhc2V0IiwiZGF0ZSIsImlubmVySFRNTCIsImFwcGVuZENoaWxkIiwic3R5bGUiLCJ0b3AiLCJvZmZzZXRUb3AiLCJsZWZ0Iiwib2Zmc2V0TGVmdCIsInNoaWZ0V2Vla1NlbGVjdG9yIiwiY2hlY2tJbnB1dFdlZWtTZWxlY3RlZCIsImVsZW1lbnQiLCJjdXJyZW50VGFyZ2V0IiwiZm91bmRhdGlvbiIsInJlZ2lzdGVyV2Vla1NlbGVjdGVkIiwidW5yZWdpc3RlcldlZWtTZWxlY3RlZCIsInJlbW92ZUNsYXNzIiwidHJpZ2dlciIsIndlZWtTZWxlY3RvciIsIm5leHQiLCJhZGRDbGFzcyIsInByZXYiLCJkb25lIiwiaW5pdGlhbGl6ZWRTZWxlY3RTdGFydERhdGUiLCJpbml0aWFsaXplZFNlbGVjdEVuZERhdGUiLCJwcmV2TW9udGhNb25kYXkiLCJnZXRFbGVtZW50c0J5Q2xhc3NOYW1lIiwic3RhcnRPZiIsIm5leHRNb250aE1vbmRheSIsImVuZE9mIiwiZmV0Y2giLCJyZXNldCIsInRpbWVTZWxlY3RvcldlZWtEYXRlIiwic2VsZWN0U3RhcnREYXRlIiwic2VsZWN0RW5kRGF0ZSIsInN1Y2Nlc3MiLCJyZXNwb25zZSIsImVycm9yIl0sIm1hcHBpbmdzIjoiOztBQU1BOztBQUVBLFNBQUlBLEtBQUosQ0FBVUMsUUFBVixHQUFxQkMsU0FBU0MsSUFBVCxDQUFjQyxNQUFkLENBQXFCO0FBQ3hDQyxjQUFZLG9CQUFTQyxJQUFULEVBQWU7QUFDekIsU0FBS0MsT0FBTCxHQUFlRCxJQUFmO0FBQ0EsU0FBS0UsUUFBTCxDQUFjLFNBQUlDLFNBQWxCLEVBQTZCLGFBQTdCLEVBQTRDLEtBQUtDLG1CQUFqRDtBQUNBLFNBQUtDLHdCQUFMLEdBQWdDLEtBQWhDO0FBQ0EsU0FBS0MsY0FBTCxHQUFzQixFQUF0QjtBQUNELEdBTnVDO0FBT3hDQyxVQUFRLGtCQUFXO0FBQ2pCLFNBQUtDLFVBQUwsQ0FBZ0JDLEVBQUUsS0FBS1IsT0FBTCxDQUFhUyxFQUFmLENBQWhCO0FBQ0EsUUFBSUMsT0FBTyxJQUFYO0FBQ0FGLE1BQUUsS0FBS1IsT0FBTCxDQUFhUyxFQUFmLEVBQW1CRSxLQUFuQixDQUF5QjtBQUNyQkwsY0FBUSxnQkFBU1AsSUFBVCxFQUFlO0FBQ25CLGFB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O0FBRUwyRCx5QkFBaUJWLDBCQUZaO0FBR0xXLHVCQUFlVjtBQUhWLE9BRmE7QUFPcEJXLGVBQVMsaUJBQVNoRSxVQUFULEVBQXFCaUUsUUFBckIsRUFBK0IxRixPQUEvQixFQUF3QztBQUMvQ1UsYUFBS1YsT0FBTCxDQUFheUUsSUFBYixHQUFvQmlCLFNBQVNqQixJQUE3QjtBQUNBL0QsYUFBS1YsT0FBTCxDQUFhMkUsSUFBYixHQUFvQmUsU0FBU2YsSUFBN0I7QUFDQUMsYUFBSyxJQUFMO0FBQ0QsT0FYbUI7QUFZcEJlLGFBQU8sZUFBU2xFLFVBQVQsRUFBcUJpRSxRQUFyQixFQUErQjFGLE9BQS9CLEVBQXdDO0FBQzdDO0FBQ0E0RSxhQUFLekQsR0FBTDtBQUNEO0FBZm1CLEtBQXRCO0FBaUJEO0FBaEt1QyxDQUFyQixDQUFyQixDLENBUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiIyMS5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vTk9URVM6XG4vLyAtIFJlYWRpbmcgaXQgc291bmRzIGxpa2UgaW5uZXJIVE1MIG9wZW5zIHRoZSBwb3NzaWJpbGl0eSBmb3IgWFNTIGF0dGFja3Ncbi8vIHRob3VnaCBvbmx5IHdoZW4geW91IGFyZSB1c2luZyB1c2VyIGlucHV0LiBKdXN0IHNvbWV0aGluZyB0byBrZWVwIGluIG1pbmQuXG4vLyAtIE5leHQvUHJldiBtb250aCByZXJlbmRlcnMgdGhlICdkYXlzJyBzdWJ2aWV3IG9mIHRoZSBjYWxlbmRhci4gV2l0aCB0aGF0LFxuLy8gSSdtIHJlY3JlYXRpbmcgdGhlIG5lY2Vzc2FyeSBET00gZWxlbWVudHMgZWFjaCB0aW1lLlxuXG5pbXBvcnQgeyBhcHAgfSBmcm9tICcuLi9hcHAnO1xuXG5hcHAudmlld3MuQ2FsZW5kYXIgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBkYXRhO1xuICAgIHRoaXMubGlzdGVuVG8oYXBwLmV2ZW50X2J1cywgJ2lucHV0Q2hhbmdlJywgdGhpcy5yZWdpc3RlcklucHV0Q2hhbmdlKTtcbiAgICB0aGlzLnRpbWVTZWxlY3RvcklucHV0Q2hhbmdlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2VsZWN0ZWRXZWVrSWQgPSAnJztcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNldEVsZW1lbnQoJCh0aGlzLm9wdGlvbnMuZWwpKTtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgJCh0aGlzLm9wdGlvbnMuZWwpLmNsbmRyKHtcbiAgICAgICAgcmVuZGVyOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLnRlbXBsYXRlID0gXy50ZW1wbGF0ZShhcHAuY3JlYXRlVGVtcGxhdGUoJ3RlbXBsYXRlcy9jbG5kci50cGwnLCBkYXRhKSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xpY2tFdmVudHM6IHtcbiAgICAgICAgICBvbk1vbnRoQ2hhbmdlOiBmdW5jdGlvbihtb250aCkge1xuICAgICAgICAgICAgdGhhdC5mZXRjaENvbGxlY3Rpb24obW9udGgsIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICBpZiAoZXJyKSByZXR1cm4gY29uc29sZS5sb2coZXJyKTtcbiAgICAgICAgICAgICAgdmFyIHdlZWtTZWxlY3RvckRhdGUgPSBtb21lbnQudXRjKHRoYXQuY29sbGVjdGlvbi5hdCgwKS5nZXQoJ3dlZWtTdGFydERhdGUnKSkuZm9ybWF0KCdZWVlZLU1NLUREJyk7XG4gICAgICAgICAgICAgIHRoYXQucmVuZGVyTmV4dFByZXZCdXR0b25zKCk7XG4gICAgICAgICAgICAgIHRoYXQucmVuZGVyRGF5cyh3ZWVrU2VsZWN0b3JEYXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5mZXRjaENvbGxlY3Rpb24odGhpcy5vcHRpb25zLnJlbmRlcldlZWtTdGFydERhdGUsIGZ1bmN0aW9uKGVycikge1xuICAgICAgdGhhdC5yZW5kZXJEYXlzKHRoYXQub3B0aW9ucy5yZW5kZXJXZWVrU3RhcnREYXRlKTtcbiAgICAgIHRoYXQucmVuZGVyTmV4dFByZXZCdXR0b25zKCk7XG4gICAgICB0aGF0LmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgfSk7XG4gIH0sXG4gIGV2ZW50czoge1xuICAgICdjbGljayAud2Vla0RpdicgOiAnY2hlY2tJbnB1dFdlZWtTZWxlY3RlZCcsXG4gICAgJ2NsaWNrICNjaGFuZ2VUaW1lU2hlZXRObycgOiAndW5yZWdpc3RlcldlZWtTZWxlY3RlZCcsXG4gICAgJ2NsaWNrICNjaGFuZ2VUaW1lU2hlZXRZZXMnIDogJ3JlZ2lzdGVyV2Vla1NlbGVjdGVkJ1xuICB9LFxuICByZWdpc3RlcklucHV0Q2hhbmdlOiBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnRpbWVTZWxlY3RvcklucHV0Q2hhbmdlZCA9IHRydWU7XG4gIH0sXG4gIHJlbmRlckRheXM6IGZ1bmN0aW9uKHdlZWtTZWxlY3RvckRhdGUpIHtcbiAgICAvL3JlbmRlciB3ZWVrIGRpdnMgb24gdG9wIG9mIGNhbGVuZGFyXG4gICAgdmFyIGRheXNDb250YWluZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZGF5c0NvbnRhaW5lcicpO1xuICAgIHZhciBzdGFydFdlZWtEYXRlID0gbW9tZW50LnV0Yyh0aGlzLmNvbGxlY3Rpb24uYXQoMCkuZ2V0KCd3ZWVrU3RhcnREYXRlJykpO1xuICAgIHZhciBlbmRXZWVrRGF0ZSA9IG1vbWVudC51dGModGhpcy5jb2xsZWN0aW9uLmF0KHRoaXMuY29sbGVjdGlvbi5sZW5ndGgtMSkuZ2V0KCd3ZWVrU3RhcnREYXRlJykpO1xuICAgIGZvciAoc3RhcnRXZWVrRGF0ZSA7IG1vbWVudChzdGFydFdlZWtEYXRlKS5pc1NhbWVPckJlZm9yZShlbmRXZWVrRGF0ZSkgOyBzdGFydFdlZWtEYXRlID0gbW9tZW50KHN0YXJ0V2Vla0RhdGUpLmFkZCgxLCAndycpKSB7XG4gICAgICB2YXIgd2Vla0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgdmFyIHdlZWtEaXZTcGFuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgdmFyIGZvcm1hdHRlZERhdGUgPSBtb21lbnQoc3RhcnRXZWVrRGF0ZSkuZm9ybWF0KCdZWVlZLU1NLUREJyk7XG4gICAgICB2YXIgd2Vla1N0YXJ0RGF5RGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZm9ybWF0dGVkRGF0ZSk7XG4gICAgICB3ZWVrRGl2LmlkID0gZm9ybWF0dGVkRGF0ZSsnLXdlZWtEaXYnO1xuICAgICAgd2Vla0Rpdi5jbGFzc05hbWUgPSAnd2Vla0Rpdic7XG5cbiAgICAgIC8vY29tcGxldGUgfHwgaW5jb21wbGV0ZSB8fCBlbXB0eVxuICAgICAgdmFyIG1vZGVsID0gdGhpcy5jb2xsZWN0aW9uLmZpbmQoZnVuY3Rpb24odGltZVNoZWV0KSB7XG4gICAgICAgIHZhciBtb2RlbFN0YXJ0RGF0ZSA9IG1vbWVudCh0aW1lU2hlZXQuZ2V0KCd3ZWVrU3RhcnREYXRlJykpO1xuICAgICAgICByZXR1cm4gbW9tZW50KG1vZGVsU3RhcnREYXRlKS5pc1NhbWUoc3RhcnRXZWVrRGF0ZSk7XG4gICAgICB9KTtcbiAgICAgIGlmIChtb2RlbCkge1xuICAgICAgICBpZihtb2RlbC5nZXQoJ3RvdGFsVGltZScpID09PSBudWxsKSB7XG4gICAgICAgICAgd2Vla0Rpdi5jbGFzc05hbWUgKz0gJyBpbmNvbXBsZXRlJztcbiAgICAgICAgICB3ZWVrRGl2LmRhdGFzZXQuZGF0ZSA9IGZvcm1hdHRlZERhdGU7XG4gICAgICAgICAgd2Vla0RpdlNwYW4uaW5uZXJIVE1MID0gJ0luY29tcGxldGUnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdlZWtEaXYuY2xhc3NOYW1lICs9ICcgY29tcGxldGUnO1xuICAgICAgICAgIHdlZWtEaXYuZGF0YXNldC5kYXRlID0gZm9ybWF0dGVkRGF0ZTtcbiAgICAgICAgICB3ZWVrRGl2U3Bhbi5pbm5lckhUTUwgPSAnQ29tcGxldGUnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB3ZWVrRGl2LmFwcGVuZENoaWxkKHdlZWtEaXZTcGFuKTtcbiAgICAgIGRheXNDb250YWluZXIuYXBwZW5kQ2hpbGQod2Vla0Rpdik7XG5cbiAgICAgIC8vU2hpZnQgdG8gbG9jYXRpb25cblxuICAgICAgd2Vla0Rpdi5zdHlsZS50b3AgPSB3ZWVrU3RhcnREYXlEaXYub2Zmc2V0VG9wKydweCc7XG4gICAgICB3ZWVrRGl2LnN0eWxlLmxlZnQgPSB3ZWVrU3RhcnREYXlEaXYub2Zmc2V0TGVmdCsncHgnO1xuICAgIH1cbiAgICB0aGlzLnNoaWZ0V2Vla1NlbGVjdG9yKHdlZWtTZWxlY3RvckRhdGUpO1xuICB9LFxuICBjaGVja0lucHV0V2Vla1NlbGVjdGVkOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgdGhpcy5zZWxlY3RlZFdlZWtJZCA9IGVsZW1lbnQuY3VycmVudFRhcmdldC5pZDtcbiAgICBpZiAodGhpcy50aW1lU2VsZWN0b3JJbnB1dENoYW5nZWQpIHtcbiAgICAgIC8vVGVtcG9yYXJpbHkgc2hpZnRpbmcgdmlldyBlbGVtZW50IHRvIGdsb2JhbCB0byBjYXRjaCBtb2RhbCBldmVudHNcbiAgICAgIHRoaXMuc2V0RWxlbWVudCgkKCcjY2hhbmdlVGltZVNoZWV0TW9kYWwnKS5mb3VuZGF0aW9uKCdyZXZlYWwnLCAnb3BlbicpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZWdpc3RlcldlZWtTZWxlY3RlZCgpO1xuICAgIH1cbiAgfSxcbiAgdW5yZWdpc3RlcldlZWtTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgJCgnI2NoYW5nZVRpbWVTaGVldE1vZGFsJykuZm91bmRhdGlvbigncmV2ZWFsJywgJ2Nsb3NlJyk7XG4gICAgLy9zd2l0Y2hpbmcgYmFjayB0byBwcm9wZXIgdmlldyBlbGVtZW50XG4gICAgdGhpcy5zZXRFbGVtZW50KCQodGhpcy5vcHRpb25zLmVsKSk7XG4gIH0sXG4gIHJlZ2lzdGVyV2Vla1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAkKCcjY2hhbmdlVGltZVNoZWV0TW9kYWwnKS5mb3VuZGF0aW9uKCdyZXZlYWwnLCAnY2xvc2UnKTtcbiAgICAvL3N3aXRjaGluZyBiYWNrIHRvIHByb3BlciB2aWV3IGVsZW1lbnRcbiAgICB0aGlzLnNldEVsZW1lbnQoJCh0aGlzLm9wdGlvbnMuZWwpKTtcbiAgICB2YXIgd2Vla0RpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuc2VsZWN0ZWRXZWVrSWQpO1xuICAgICQoJy5zZWxlY3RlZCcpLnJlbW92ZUNsYXNzKCdzZWxlY3RlZCcpO1xuICAgIHRoaXMuc2hpZnRXZWVrU2VsZWN0b3Iod2Vla0Rpdi5kYXRhc2V0LmRhdGUpO1xuICAgIHdlZWtEaXYuY2xhc3NOYW1lICs9ICcgc2VsZWN0ZWQnO1xuICB9LFxuICBzaGlmdFdlZWtTZWxlY3RvcjogZnVuY3Rpb24oZGF0ZSkge1xuICAgIHRoaXMudHJpZ2dlcigndGltZVNlbGVjdG9yJywgZGF0ZSk7XG4gICAgdGhpcy50aW1lU2VsZWN0b3JJbnB1dENoYW5nZWQgPSBmYWxzZTtcbiAgICB2YXIgd2Vla1N0YXJ0RGF5RGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoZGF0ZSk7XG4gICAgdmFyIHdlZWtTZWxlY3RvciA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3ZWVrU2VsZWN0b3InKTtcbiAgICB2YXIgd2Vla0RpdiA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGRhdGUrJy13ZWVrRGl2Jyk7XG4gICAgd2Vla0Rpdi5jbGFzc05hbWUgKz0gJyBzZWxlY3RlZCc7XG4gICAgd2Vla1NlbGVjdG9yLnN0eWxlLnRvcCA9IHdlZWtTdGFydERheURpdi5vZmZzZXRUb3ArJ3B4JztcbiAgICB3ZWVrU2VsZWN0b3Iuc3R5bGUubGVmdCA9IHdlZWtTdGFydERheURpdi5vZmZzZXRMZWZ0KydweCc7XG4gIH0sXG4gIHJlbmRlck5leHRQcmV2QnV0dG9uczogZnVuY3Rpb24oKSB7XG4gICAgaWYodGhpcy5vcHRpb25zLm5leHQpIHtcbiAgICAgICQoJy5jbG5kci1uZXh0LWJ1dHRvbicpLnJlbW92ZUNsYXNzKCdpbmFjdGl2ZScpO1xuICAgIH0gZWxzZSB7XG4gICAgICAkKCcuY2xuZHItbmV4dC1idXR0b24nKS5hZGRDbGFzcygnaW5hY3RpdmUnKTtcbiAgICB9XG4gICAgaWYodGhpcy5vcHRpb25zLnByZXYpIHtcbiAgICAgICQoJy5jbG5kci1wcmV2aW91cy1idXR0b24nKS5yZW1vdmVDbGFzcygnaW5hY3RpdmUnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgJCgnLmNsbmRyLXByZXZpb3VzLWJ1dHRvbicpLmFkZENsYXNzKCdpbmFjdGl2ZScpO1xuICAgIH1cbiAgfSxcbiAgZmV0Y2hDb2xsZWN0aW9uOiBmdW5jdGlvbihkYXRlLCBkb25lKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBpbml0aWFsaXplZFNlbGVjdFN0YXJ0RGF0ZSxcbiAgICBpbml0aWFsaXplZFNlbGVjdEVuZERhdGU7XG5cbiAgICAvL0NoZWNrIGZvciBwcmV2L25leHQgbW9udGggbW9uZGF5cyB2aWV3YWJsZVxuICAgIHZhciBwcmV2TW9udGhNb25kYXkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsYXN0LW1vbnRoIG1vbmRheScpO1xuICAgIGlmIChwcmV2TW9udGhNb25kYXkubGVuZ3RoKSB7XG4gICAgICBpbml0aWFsaXplZFNlbGVjdFN0YXJ0RGF0ZSA9IHByZXZNb250aE1vbmRheVswXS5pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbGl6ZWRTZWxlY3RTdGFydERhdGUgPSBtb21lbnQoZGF0ZSkuc3RhcnRPZignbW9udGgnKS5mb3JtYXQoJ1lZWVktTU0tREQnKTtcbiAgICB9XG4gICAgdmFyIG5leHRNb250aE1vbmRheSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ25leHQtbW9udGggbW9uZGF5Jyk7XG4gICAgaWYgKG5leHRNb250aE1vbmRheS5sZW5ndGgpIHtcbiAgICAgIGluaXRpYWxpemVkU2VsZWN0RW5kRGF0ZSA9IG5leHRNb250aE1vbmRheVswXS5pZDtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5pdGlhbGl6ZWRTZWxlY3RFbmREYXRlID0gbW9tZW50KGRhdGUpLmVuZE9mKCdtb250aCcpLmZvcm1hdCgnWVlZWS1NTS1ERCcpO1xuICAgIH1cbiAgICB0aGlzLmNvbGxlY3Rpb24uZmV0Y2goe1xuICAgICAgcmVzZXQ6IHRydWUsXG4gICAgICBkYXRhIDoge1xuICAgICAgICB0aW1lU2VsZWN0b3JXZWVrRGF0ZTogbW9tZW50KGRhdGUpLnN0YXJ0T2YoJ2lzb1dlZWsnKS5mb3JtYXQoJ1lZWVktTU0tREQnKSxcbiAgICAgICAgc2VsZWN0U3RhcnREYXRlOiBpbml0aWFsaXplZFNlbGVjdFN0YXJ0RGF0ZSxcbiAgICAgICAgc2VsZWN0RW5kRGF0ZTogaW5pdGlhbGl6ZWRTZWxlY3RFbmREYXRlXG4gICAgICB9LFxuICAgICAgc3VjY2VzczogZnVuY3Rpb24oY29sbGVjdGlvbiwgcmVzcG9uc2UsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhhdC5vcHRpb25zLm5leHQgPSByZXNwb25zZS5uZXh0O1xuICAgICAgICB0aGF0Lm9wdGlvbnMucHJldiA9IHJlc3BvbnNlLnByZXY7XG4gICAgICAgIGRvbmUobnVsbCk7XG4gICAgICB9LFxuICAgICAgZXJyb3I6IGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgICAgIC8vaGFuZGxlIHNlcnZlciBlcnJvclxuICAgICAgICBkb25lKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn0pO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2FwcC9jbGllbnQtYXBwL3ZpZXdzL2NhbGVuZGFyLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.views.home = Backbone.View.extend({\n    template: null,\n    initialize: function initialize(data) {\n        var resizes = ['homeContent'];\n        $(window).resize(_.throttle(function () {\n            _app.app.resizeFunction(resizes);\n        }, 1000));\n\n        this.options = data;\n        this.template = _.template(this.options.template);\n        this.render();\n    },\n    events: {\n        'click #toLoginPageButton': 'toLogin',\n        'click #toAccountCreationButton': 'toLoginCreation'\n    },\n    render: function render() {\n        this.$el.html(this.template({}));\n        this.delegateEvents();\n        //Making it so the 'trigger' call is next in the event\n        //queue after the rendering\n        setTimeout(function () {\n            $(window).trigger('resize');\n        }, 0);\n    },\n    toLogin: function toLogin() {\n        _app.app.event_bus.trigger('login');\n    },\n    toLoginCreation: function toLoginCreation() {\n        _app.app.event_bus.trigger('loginCreation');\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvdmlld3MvaG9tZS5qcz80YzQ1Il0sIm5hbWVzIjpbInZpZXdzIiwiaG9tZSIsIkJhY2tib25lIiwiVmlldyIsImV4dGVuZCIsInRlbXBsYXRlIiwiaW5pdGlhbGl6ZSIsImRhdGEiLCJyZXNpemVzIiwiJCIsIndpbmRvdyIsInJlc2l6ZSIsIl8iLCJ0aHJvdHRsZSIsInJlc2l6ZUZ1bmN0aW9uIiwib3B0aW9ucyIsInJlbmRlciIsImV2ZW50cyIsIiRlbCIsImh0bWwiLCJkZWxlZ2F0ZUV2ZW50cyIsInNldFRpbWVvdXQiLCJ0cmlnZ2VyIiwidG9Mb2dpbiIsImV2ZW50X2J1cyIsInRvTG9naW5DcmVhdGlvbiJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0E7O0FBRUEsU0FBSUEsS0FBSixDQUFVQyxJQUFWLEdBQWlCQyxTQUFTQyxJQUFULENBQWNDLE1BQWQsQ0FBcUI7QUFDbENDLGNBQVUsSUFEd0I7QUFFbENDLGdCQUFZLG9CQUFTQyxJQUFULEVBQWU7QUFDdkIsWUFBSUMsVUFBVSxDQUFDLGFBQUQsQ0FBZDtBQUNBQyxVQUFFQyxNQUFGLEVBQVVDLE1BQVYsQ0FBa0JDLEVBQUVDLFFBQUYsQ0FBWSxZQUFXO0FBQ3JDLHFCQUFJQyxjQUFKLENBQW1CTixPQUFuQjtBQUNILFNBRmlCLEVBRWYsSUFGZSxDQUFsQjs7QUFJQSxhQUFLTyxPQUFMLEdBQWVSLElBQWY7QUFDQSxhQUFLRixRQUFMLEdBQWdCTyxFQUFFUCxRQUFGLENBQVcsS0FBS1UsT0FBTCxDQUFhVixRQUF4QixDQUFoQjtBQUNBLGFBQUtXLE1BQUw7QUFDSCxLQVhpQztBQVlsQ0MsWUFBUTtBQUNKLG9DQUE2QixTQUR6QjtBQUVKLDBDQUFtQztBQUYvQixLQVowQjtBQWdCbENELFlBQVEsa0JBQVU7QUFDZCxhQUFLRSxHQUFMLENBQVNDLElBQVQsQ0FBYyxLQUFLZCxRQUFMLENBQWMsRUFBZCxDQUFkO0FBQ0EsYUFBS2UsY0FBTDtBQUNBO0FBQ0E7QUFDQUMsbUJBQVksWUFBVztBQUNuQlosY0FBRUMsTUFBRixFQUFVWSxPQUFWLENBQWtCLFFBQWxCO0FBQ0gsU0FGRCxFQUVHLENBRkg7QUFHSCxLQXhCaUM7QUF5QmxDQyxhQUFVLG1CQUFXO0FBQ2pCLGlCQUFJQyxTQUFKLENBQWNGLE9BQWQsQ0FBc0IsT0FBdEI7QUFDSCxLQTNCaUM7QUE0QmxDRyxxQkFBa0IsMkJBQVk7QUFDMUIsaUJBQUlELFNBQUosQ0FBY0YsT0FBZCxDQUFzQixlQUF0QjtBQUNIO0FBOUJpQyxDQUFyQixDQUFqQiIsImZpbGUiOiIyMi5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IGFwcCB9IGZyb20gJy4uL2FwcCc7XG5cbmFwcC52aWV3cy5ob21lID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIHRlbXBsYXRlOiBudWxsLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc2l6ZXMgPSBbJ2hvbWVDb250ZW50J107XG4gICAgICAgICQod2luZG93KS5yZXNpemUoIF8udGhyb3R0bGUoIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYXBwLnJlc2l6ZUZ1bmN0aW9uKHJlc2l6ZXMpO1xuICAgICAgICB9LCAxMDAwICkgKTtcblxuICAgICAgICB0aGlzLm9wdGlvbnMgPSBkYXRhO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gXy50ZW1wbGF0ZSh0aGlzLm9wdGlvbnMudGVtcGxhdGUpO1xuICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgIH0sXG4gICAgZXZlbnRzOiB7XG4gICAgICAgICdjbGljayAjdG9Mb2dpblBhZ2VCdXR0b24nIDogJ3RvTG9naW4nLFxuICAgICAgICAnY2xpY2sgI3RvQWNjb3VudENyZWF0aW9uQnV0dG9uJyA6ICd0b0xvZ2luQ3JlYXRpb24nXG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuJGVsLmh0bWwodGhpcy50ZW1wbGF0ZSh7fSkpO1xuICAgICAgICB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgICAgIC8vTWFraW5nIGl0IHNvIHRoZSAndHJpZ2dlcicgY2FsbCBpcyBuZXh0IGluIHRoZSBldmVudFxuICAgICAgICAvL3F1ZXVlIGFmdGVyIHRoZSByZW5kZXJpbmdcbiAgICAgICAgc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkKHdpbmRvdykudHJpZ2dlcigncmVzaXplJyk7XG4gICAgICAgIH0sIDApO1xuICAgIH0sXG4gICAgdG9Mb2dpbiA6IGZ1bmN0aW9uKCkge1xuICAgICAgICBhcHAuZXZlbnRfYnVzLnRyaWdnZXIoJ2xvZ2luJyk7XG4gICAgfSxcbiAgICB0b0xvZ2luQ3JlYXRpb24gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGFwcC5ldmVudF9idXMudHJpZ2dlcignbG9naW5DcmVhdGlvbicpO1xuICAgIH1cbn0pO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2FwcC9jbGllbnQtYXBwL3ZpZXdzL2hvbWUuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.views.loggedInHeader = Backbone.View.extend({\n    initialize: function initialize(data) {\n        this.options = data;\n    },\n    render: function render() {\n        this.template = _.template(_app.app.createTemplate('templates/loggedInHeader.tpl', this.options.data));\n        this.$el.html(this.template({}));\n        this.delegateEvents();\n    },\n    events: {\n        'click #logoutButton': 'logout'\n    },\n    logout: function logout() {\n        this.model.fetch({\n            success: function success(model, response) {\n                _app.app.event_bus.trigger('login');\n            }\n        });\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvdmlld3MvbG9nZ2VkSW5IZWFkZXIuanM/ZThiNiJdLCJuYW1lcyI6WyJ2aWV3cyIsImxvZ2dlZEluSGVhZGVyIiwiQmFja2JvbmUiLCJWaWV3IiwiZXh0ZW5kIiwiaW5pdGlhbGl6ZSIsImRhdGEiLCJvcHRpb25zIiwicmVuZGVyIiwidGVtcGxhdGUiLCJfIiwiY3JlYXRlVGVtcGxhdGUiLCIkZWwiLCJodG1sIiwiZGVsZWdhdGVFdmVudHMiLCJldmVudHMiLCJsb2dvdXQiLCJtb2RlbCIsImZldGNoIiwic3VjY2VzcyIsInJlc3BvbnNlIiwiZXZlbnRfYnVzIiwidHJpZ2dlciJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0E7O0FBRUEsU0FBSUEsS0FBSixDQUFVQyxjQUFWLEdBQTJCQyxTQUFTQyxJQUFULENBQWNDLE1BQWQsQ0FBcUI7QUFDNUNDLGdCQUFZLG9CQUFTQyxJQUFULEVBQWU7QUFDdkIsYUFBS0MsT0FBTCxHQUFlRCxJQUFmO0FBQ0gsS0FIMkM7QUFJNUNFLFlBQVEsa0JBQVU7QUFDZCxhQUFLQyxRQUFMLEdBQWdCQyxFQUFFRCxRQUFGLENBQVcsU0FBSUUsY0FBSixDQUFtQiw4QkFBbkIsRUFBbUQsS0FBS0osT0FBTCxDQUFhRCxJQUFoRSxDQUFYLENBQWhCO0FBQ0EsYUFBS00sR0FBTCxDQUFTQyxJQUFULENBQWMsS0FBS0osUUFBTCxDQUFjLEVBQWQsQ0FBZDtBQUNBLGFBQUtLLGNBQUw7QUFDSCxLQVIyQztBQVM1Q0MsWUFBUTtBQUNKLCtCQUF3QjtBQURwQixLQVRvQztBQVk1Q0MsWUFBUSxrQkFBVztBQUNmLGFBQUtDLEtBQUwsQ0FBV0MsS0FBWCxDQUFpQjtBQUNiQyxxQkFBUyxpQkFBU0YsS0FBVCxFQUFnQkcsUUFBaEIsRUFBMEI7QUFDL0IseUJBQUlDLFNBQUosQ0FBY0MsT0FBZCxDQUFzQixPQUF0QjtBQUNIO0FBSFksU0FBakI7QUFLSDtBQWxCMkMsQ0FBckIsQ0FBM0IiLCJmaWxlIjoiMjMuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBhcHAgfSBmcm9tICcuLi9hcHAnO1xuXG5hcHAudmlld3MubG9nZ2VkSW5IZWFkZXIgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBkYXRhO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gXy50ZW1wbGF0ZShhcHAuY3JlYXRlVGVtcGxhdGUoJ3RlbXBsYXRlcy9sb2dnZWRJbkhlYWRlci50cGwnLCB0aGlzLm9wdGlvbnMuZGF0YSkpO1xuICAgICAgICB0aGlzLiRlbC5odG1sKHRoaXMudGVtcGxhdGUoe30pKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgIH0sXG4gICAgZXZlbnRzOiB7XG4gICAgICAgICdjbGljayAjbG9nb3V0QnV0dG9uJyA6ICdsb2dvdXQnXG4gICAgfSxcbiAgICBsb2dvdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm1vZGVsLmZldGNoKHtcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKG1vZGVsLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIGFwcC5ldmVudF9idXMudHJpZ2dlcignbG9naW4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvYXBwL2NsaWVudC1hcHAvdmlld3MvbG9nZ2VkSW5IZWFkZXIuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.views.loggedOutHeader = Backbone.View.extend({\n    template: null,\n    initialize: function initialize(data) {\n        this.options = data;\n        this.template = _.template(this.options.template);\n    },\n    render: function render() {\n        this.$el.html(this.template({}));\n        this.delegateEvents();\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvdmlld3MvbG9nZ2VkT3V0SGVhZGVyLmpzPzQyN2QiXSwibmFtZXMiOlsidmlld3MiLCJsb2dnZWRPdXRIZWFkZXIiLCJCYWNrYm9uZSIsIlZpZXciLCJleHRlbmQiLCJ0ZW1wbGF0ZSIsImluaXRpYWxpemUiLCJkYXRhIiwib3B0aW9ucyIsIl8iLCJyZW5kZXIiLCIkZWwiLCJodG1sIiwiZGVsZWdhdGVFdmVudHMiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBOztBQUVBLFNBQUlBLEtBQUosQ0FBVUMsZUFBVixHQUE0QkMsU0FBU0MsSUFBVCxDQUFjQyxNQUFkLENBQXFCO0FBQzdDQyxjQUFVLElBRG1DO0FBRTdDQyxnQkFBWSxvQkFBU0MsSUFBVCxFQUFlO0FBQ3ZCLGFBQUtDLE9BQUwsR0FBZUQsSUFBZjtBQUNBLGFBQUtGLFFBQUwsR0FBZ0JJLEVBQUVKLFFBQUYsQ0FBVyxLQUFLRyxPQUFMLENBQWFILFFBQXhCLENBQWhCO0FBQ0gsS0FMNEM7QUFNN0NLLFlBQVEsa0JBQVU7QUFDZCxhQUFLQyxHQUFMLENBQVNDLElBQVQsQ0FBYyxLQUFLUCxRQUFMLENBQWMsRUFBZCxDQUFkO0FBQ0EsYUFBS1EsY0FBTDtBQUNIO0FBVDRDLENBQXJCLENBQTVCIiwiZmlsZSI6IjI0LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgYXBwIH0gZnJvbSAnLi4vYXBwJztcblxuYXBwLnZpZXdzLmxvZ2dlZE91dEhlYWRlciA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICB0ZW1wbGF0ZTogbnVsbCxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGRhdGE7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBfLnRlbXBsYXRlKHRoaXMub3B0aW9ucy50ZW1wbGF0ZSk7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMuJGVsLmh0bWwodGhpcy50ZW1wbGF0ZSh7fSkpO1xuICAgICAgICB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgfVxufSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvYXBwL2NsaWVudC1hcHAvdmlld3MvbG9nZ2VkT3V0SGVhZGVyLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.views.login = Backbone.View.extend({\n    template: null,\n    initialize: function initialize(data) {\n        this.options = data;\n        this.template = _.template(this.options.template);\n        this.render();\n\n        Backbone.Validation.bind(this, {\n            valid: function valid(view, attr) {\n                var element = view.$(\"[name=\" + attr + \"]\");\n                var parent = element.closest('.inputWrapper');\n                element.removeClass('error');\n                parent.find('small.error').html('').addClass('hidden');\n            },\n            invalid: function invalid(view, attr, error) {\n                //Hide server errors if input error arises\n                $('#serverError').html('').addClass('hidden');\n                var element = view.$(\"[name=\" + attr + \"]\");\n                var parent = element.closest('.inputWrapper');\n                element.addClass('error');\n                parent.find('small.error').html(error).removeClass('hidden');\n            }\n        });\n    },\n    events: {\n        'click #loginButton': 'login',\n        'click #homeButton': 'home'\n    },\n    render: function render() {\n        this.$el.html(this.template({}));\n        this.delegateEvents();\n    },\n    login: function login() {\n        event.preventDefault();\n        var data = $('#loginRequest').serializeObject();\n        this.model.set(data);\n        if (this.model.isValid(true)) {\n            this.model.save({\n                Email: data.Email,\n                Password: data.Password\n            }, {\n                success: function success(model, response) {\n                    _app.app.event_bus.trigger('timeSheet');\n                },\n                error: function error(model, response) {\n                    $('#serverError').html(response.responseJSON.message).removeClass('hidden');\n                }\n            });\n        }\n    },\n    home: function home() {\n        _app.app.event_bus.trigger('home');\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvdmlld3MvbG9naW4uanM/ZjQwNiJdLCJuYW1lcyI6WyJ2aWV3cyIsImxvZ2luIiwiQmFja2JvbmUiLCJWaWV3IiwiZXh0ZW5kIiwidGVtcGxhdGUiLCJpbml0aWFsaXplIiwiZGF0YSIsIm9wdGlvbnMiLCJfIiwicmVuZGVyIiwiVmFsaWRhdGlvbiIsImJpbmQiLCJ2YWxpZCIsInZpZXciLCJhdHRyIiwiZWxlbWVudCIsIiQiLCJwYXJlbnQiLCJjbG9zZXN0IiwicmVtb3ZlQ2xhc3MiLCJmaW5kIiwiaHRtbCIsImFkZENsYXNzIiwiaW52YWxpZCIsImVycm9yIiwiZXZlbnRzIiwiJGVsIiwiZGVsZWdhdGVFdmVudHMiLCJldmVudCIsInByZXZlbnREZWZhdWx0Iiwic2VyaWFsaXplT2JqZWN0IiwibW9kZWwiLCJzZXQiLCJpc1ZhbGlkIiwic2F2ZSIsIkVtYWlsIiwiUGFzc3dvcmQiLCJzdWNjZXNzIiwicmVzcG9uc2UiLCJldmVudF9idXMiLCJ0cmlnZ2VyIiwicmVzcG9uc2VKU09OIiwibWVzc2FnZSIsImhvbWUiXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBOztBQUVBLFNBQUlBLEtBQUosQ0FBVUMsS0FBVixHQUFrQkMsU0FBU0MsSUFBVCxDQUFjQyxNQUFkLENBQXFCO0FBQ25DQyxjQUFVLElBRHlCO0FBRW5DQyxnQkFBWSxvQkFBU0MsSUFBVCxFQUFlO0FBQ3ZCLGFBQUtDLE9BQUwsR0FBZUQsSUFBZjtBQUNBLGFBQUtGLFFBQUwsR0FBZ0JJLEVBQUVKLFFBQUYsQ0FBVyxLQUFLRyxPQUFMLENBQWFILFFBQXhCLENBQWhCO0FBQ0EsYUFBS0ssTUFBTDs7QUFFQVIsaUJBQVNTLFVBQVQsQ0FBb0JDLElBQXBCLENBQXlCLElBQXpCLEVBQStCO0FBQzdCQyxtQkFBTyxlQUFTQyxJQUFULEVBQWVDLElBQWYsRUFBcUI7QUFDMUIsb0JBQUlDLFVBQVVGLEtBQUtHLENBQUwsQ0FBTyxXQUFTRixJQUFULEdBQWMsR0FBckIsQ0FBZDtBQUNBLG9CQUFJRyxTQUFTRixRQUFRRyxPQUFSLENBQWdCLGVBQWhCLENBQWI7QUFDQUgsd0JBQVFJLFdBQVIsQ0FBb0IsT0FBcEI7QUFDQUYsdUJBQU9HLElBQVAsQ0FBWSxhQUFaLEVBQTJCQyxJQUEzQixDQUFnQyxFQUFoQyxFQUFvQ0MsUUFBcEMsQ0FBNkMsUUFBN0M7QUFDRCxhQU40QjtBQU83QkMscUJBQVMsaUJBQVNWLElBQVQsRUFBZUMsSUFBZixFQUFxQlUsS0FBckIsRUFBNEI7QUFDbkM7QUFDQVIsa0JBQUUsY0FBRixFQUFrQkssSUFBbEIsQ0FBdUIsRUFBdkIsRUFBMkJDLFFBQTNCLENBQW9DLFFBQXBDO0FBQ0Esb0JBQUlQLFVBQVVGLEtBQUtHLENBQUwsQ0FBTyxXQUFTRixJQUFULEdBQWMsR0FBckIsQ0FBZDtBQUNBLG9CQUFJRyxTQUFTRixRQUFRRyxPQUFSLENBQWdCLGVBQWhCLENBQWI7QUFDQUgsd0JBQVFPLFFBQVIsQ0FBaUIsT0FBakI7QUFDQUwsdUJBQU9HLElBQVAsQ0FBWSxhQUFaLEVBQTJCQyxJQUEzQixDQUFnQ0csS0FBaEMsRUFBdUNMLFdBQXZDLENBQW1ELFFBQW5EO0FBQ0Q7QUFkNEIsU0FBL0I7QUFnQkgsS0F2QmtDO0FBd0JuQ00sWUFBUTtBQUNOLDhCQUF1QixPQURqQjtBQUVOLDZCQUFzQjtBQUZoQixLQXhCMkI7QUE0Qm5DaEIsWUFBUSxrQkFBVTtBQUNkLGFBQUtpQixHQUFMLENBQVNMLElBQVQsQ0FBYyxLQUFLakIsUUFBTCxDQUFjLEVBQWQsQ0FBZDtBQUNBLGFBQUt1QixjQUFMO0FBQ0gsS0EvQmtDO0FBZ0NuQzNCLFdBQU8saUJBQVc7QUFDZDRCLGNBQU1DLGNBQU47QUFDQSxZQUFJdkIsT0FBT1UsRUFBRSxlQUFGLEVBQW1CYyxlQUFuQixFQUFYO0FBQ0EsYUFBS0MsS0FBTCxDQUFXQyxHQUFYLENBQWUxQixJQUFmO0FBQ0EsWUFBSSxLQUFLeUIsS0FBTCxDQUFXRSxPQUFYLENBQW1CLElBQW5CLENBQUosRUFBOEI7QUFDMUIsaUJBQUtGLEtBQUwsQ0FBV0csSUFBWCxDQUFnQjtBQUNaQyx1QkFBTzdCLEtBQUs2QixLQURBO0FBRVpDLDBCQUFVOUIsS0FBSzhCO0FBRkgsYUFBaEIsRUFHRztBQUNDQyx5QkFBUyxpQkFBU04sS0FBVCxFQUFnQk8sUUFBaEIsRUFBMEI7QUFDL0IsNkJBQUlDLFNBQUosQ0FBY0MsT0FBZCxDQUFzQixXQUF0QjtBQUNILGlCQUhGO0FBSUNoQix1QkFBTyxlQUFTTyxLQUFULEVBQWdCTyxRQUFoQixFQUEwQjtBQUM3QnRCLHNCQUFFLGNBQUYsRUFBa0JLLElBQWxCLENBQXVCaUIsU0FBU0csWUFBVCxDQUFzQkMsT0FBN0MsRUFBc0R2QixXQUF0RCxDQUFrRSxRQUFsRTtBQUNIO0FBTkYsYUFISDtBQVdIO0FBQ0osS0FqRGtDO0FBa0RuQ3dCLFVBQU0sZ0JBQVc7QUFDYixpQkFBSUosU0FBSixDQUFjQyxPQUFkLENBQXNCLE1BQXRCO0FBQ0g7QUFwRGtDLENBQXJCLENBQWxCIiwiZmlsZSI6IjI1LmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgYXBwIH0gZnJvbSAnLi4vYXBwJztcblxuYXBwLnZpZXdzLmxvZ2luID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIHRlbXBsYXRlOiBudWxsLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gZGF0YTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IF8udGVtcGxhdGUodGhpcy5vcHRpb25zLnRlbXBsYXRlKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcblxuICAgICAgICBCYWNrYm9uZS5WYWxpZGF0aW9uLmJpbmQodGhpcywge1xuICAgICAgICAgIHZhbGlkOiBmdW5jdGlvbih2aWV3LCBhdHRyKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHZpZXcuJChcIltuYW1lPVwiK2F0dHIrXCJdXCIpO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsZW1lbnQuY2xvc2VzdCgnLmlucHV0V3JhcHBlcicpO1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcygnZXJyb3InKTtcbiAgICAgICAgICAgIHBhcmVudC5maW5kKCdzbWFsbC5lcnJvcicpLmh0bWwoJycpLmFkZENsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGludmFsaWQ6IGZ1bmN0aW9uKHZpZXcsIGF0dHIsIGVycm9yKSB7XG4gICAgICAgICAgICAvL0hpZGUgc2VydmVyIGVycm9ycyBpZiBpbnB1dCBlcnJvciBhcmlzZXNcbiAgICAgICAgICAgICQoJyNzZXJ2ZXJFcnJvcicpLmh0bWwoJycpLmFkZENsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdmlldy4kKFwiW25hbWU9XCIrYXR0citcIl1cIik7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gZWxlbWVudC5jbG9zZXN0KCcuaW5wdXRXcmFwcGVyJyk7XG4gICAgICAgICAgICBlbGVtZW50LmFkZENsYXNzKCdlcnJvcicpO1xuICAgICAgICAgICAgcGFyZW50LmZpbmQoJ3NtYWxsLmVycm9yJykuaHRtbChlcnJvcikucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBldmVudHM6IHtcbiAgICAgICdjbGljayAjbG9naW5CdXR0b24nIDogJ2xvZ2luJyxcbiAgICAgICdjbGljayAjaG9tZUJ1dHRvbicgOiAnaG9tZSdcbiAgICB9LFxuICAgIHJlbmRlcjogZnVuY3Rpb24oKXtcbiAgICAgICAgdGhpcy4kZWwuaHRtbCh0aGlzLnRlbXBsYXRlKHt9KSk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcbiAgICB9LFxuICAgIGxvZ2luOiBmdW5jdGlvbigpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGRhdGEgPSAkKCcjbG9naW5SZXF1ZXN0Jykuc2VyaWFsaXplT2JqZWN0KCk7XG4gICAgICAgIHRoaXMubW9kZWwuc2V0KGRhdGEpO1xuICAgICAgICBpZiAodGhpcy5tb2RlbC5pc1ZhbGlkKHRydWUpKSB7XG4gICAgICAgICAgICB0aGlzLm1vZGVsLnNhdmUoe1xuICAgICAgICAgICAgICAgIEVtYWlsOiBkYXRhLkVtYWlsLFxuICAgICAgICAgICAgICAgIFBhc3N3b3JkOiBkYXRhLlBhc3N3b3JkXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24obW9kZWwsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGFwcC5ldmVudF9idXMudHJpZ2dlcigndGltZVNoZWV0Jyk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZnVuY3Rpb24obW9kZWwsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICQoJyNzZXJ2ZXJFcnJvcicpLmh0bWwocmVzcG9uc2UucmVzcG9uc2VKU09OLm1lc3NhZ2UpLnJlbW92ZUNsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgaG9tZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGFwcC5ldmVudF9idXMudHJpZ2dlcignaG9tZScpO1xuICAgIH1cbn0pO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2FwcC9jbGllbnQtYXBwL3ZpZXdzL2xvZ2luLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	eval("//Validation Source: http://jsfiddle.net/thedersen/udXL5/\n\n'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.views.loginCreation = Backbone.View.extend({\n    template: null,\n    initialize: function initialize(data) {\n        this.options = data;\n        this.template = _.template(this.options.template);\n        this.render();\n\n        Backbone.Validation.bind(this, {\n            valid: function valid(view, attr) {\n                var element = view.$(\"[name=\" + attr + \"]\");\n                var parent = element.closest('.inputWrapper');\n                element.removeClass('error');\n                parent.find('small.error').html('').addClass('hidden');\n            },\n            invalid: function invalid(view, attr, error) {\n                //Hide server errors if input error arises\n                $('#serverError').html('').addClass('hidden');\n                var element = view.$(\"[name=\" + attr + \"]\");\n                var parent = element.closest('.inputWrapper');\n                element.addClass('error');\n                parent.find('small.error').html(error).removeClass('hidden');\n            }\n        });\n    },\n    events: {\n        \"click #submitButton\": \"loginCreation\",\n        \"click #homeButton\": \"home\"\n    },\n    render: function render() {\n        this.$el.html(this.template({}));\n        this.delegateEvents();\n    },\n    loginCreation: function loginCreation() {\n        event.preventDefault();\n        var data = $('#loginCreation').serializeObject();\n        this.model.set(data);\n        if (this.model.isValid(true)) {\n            this.model.save({\n                FirstName: data.FirstName,\n                LastName: data.LastName,\n                Email: data.Email,\n                Password: data.Password,\n                AuthToken: data.AuthToken\n            }, {\n                success: function success(model, response) {\n                    _app.app.event_bus.trigger('timeSheet');\n                },\n                error: function error(model, response) {\n                    $('#serverError').html(response.responseJSON.message).removeClass('hidden');\n                }\n            });\n        }\n    },\n    home: function home() {\n        _app.app.event_bus.trigger('home');\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvdmlld3MvbG9naW5DcmVhdGlvbi5qcz83MzhjIl0sIm5hbWVzIjpbInZpZXdzIiwibG9naW5DcmVhdGlvbiIsIkJhY2tib25lIiwiVmlldyIsImV4dGVuZCIsInRlbXBsYXRlIiwiaW5pdGlhbGl6ZSIsImRhdGEiLCJvcHRpb25zIiwiXyIsInJlbmRlciIsIlZhbGlkYXRpb24iLCJiaW5kIiwidmFsaWQiLCJ2aWV3IiwiYXR0ciIsImVsZW1lbnQiLCIkIiwicGFyZW50IiwiY2xvc2VzdCIsInJlbW92ZUNsYXNzIiwiZmluZCIsImh0bWwiLCJhZGRDbGFzcyIsImludmFsaWQiLCJlcnJvciIsImV2ZW50cyIsIiRlbCIsImRlbGVnYXRlRXZlbnRzIiwiZXZlbnQiLCJwcmV2ZW50RGVmYXVsdCIsInNlcmlhbGl6ZU9iamVjdCIsIm1vZGVsIiwic2V0IiwiaXNWYWxpZCIsInNhdmUiLCJGaXJzdE5hbWUiLCJMYXN0TmFtZSIsIkVtYWlsIiwiUGFzc3dvcmQiLCJBdXRoVG9rZW4iLCJzdWNjZXNzIiwicmVzcG9uc2UiLCJldmVudF9idXMiLCJ0cmlnZ2VyIiwicmVzcG9uc2VKU09OIiwibWVzc2FnZSIsImhvbWUiXSwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUNBOztBQUVBLFNBQUlBLEtBQUosQ0FBVUMsYUFBVixHQUEwQkMsU0FBU0MsSUFBVCxDQUFjQyxNQUFkLENBQXFCO0FBQzNDQyxjQUFVLElBRGlDO0FBRTNDQyxnQkFBWSxvQkFBU0MsSUFBVCxFQUFlO0FBQ3ZCLGFBQUtDLE9BQUwsR0FBZUQsSUFBZjtBQUNBLGFBQUtGLFFBQUwsR0FBZ0JJLEVBQUVKLFFBQUYsQ0FBVyxLQUFLRyxPQUFMLENBQWFILFFBQXhCLENBQWhCO0FBQ0EsYUFBS0ssTUFBTDs7QUFFQVIsaUJBQVNTLFVBQVQsQ0FBb0JDLElBQXBCLENBQXlCLElBQXpCLEVBQStCO0FBQzdCQyxtQkFBTyxlQUFTQyxJQUFULEVBQWVDLElBQWYsRUFBcUI7QUFDMUIsb0JBQUlDLFVBQVVGLEtBQUtHLENBQUwsQ0FBTyxXQUFTRixJQUFULEdBQWMsR0FBckIsQ0FBZDtBQUNBLG9CQUFJRyxTQUFTRixRQUFRRyxPQUFSLENBQWdCLGVBQWhCLENBQWI7QUFDQUgsd0JBQVFJLFdBQVIsQ0FBb0IsT0FBcEI7QUFDQUYsdUJBQU9HLElBQVAsQ0FBWSxhQUFaLEVBQTJCQyxJQUEzQixDQUFnQyxFQUFoQyxFQUFvQ0MsUUFBcEMsQ0FBNkMsUUFBN0M7QUFDRCxhQU40QjtBQU83QkMscUJBQVMsaUJBQVNWLElBQVQsRUFBZUMsSUFBZixFQUFxQlUsS0FBckIsRUFBNEI7QUFDbkM7QUFDQVIsa0JBQUUsY0FBRixFQUFrQkssSUFBbEIsQ0FBdUIsRUFBdkIsRUFBMkJDLFFBQTNCLENBQW9DLFFBQXBDO0FBQ0Esb0JBQUlQLFVBQVVGLEtBQUtHLENBQUwsQ0FBTyxXQUFTRixJQUFULEdBQWMsR0FBckIsQ0FBZDtBQUNBLG9CQUFJRyxTQUFTRixRQUFRRyxPQUFSLENBQWdCLGVBQWhCLENBQWI7QUFDQUgsd0JBQVFPLFFBQVIsQ0FBaUIsT0FBakI7QUFDQUwsdUJBQU9HLElBQVAsQ0FBWSxhQUFaLEVBQTJCQyxJQUEzQixDQUFnQ0csS0FBaEMsRUFBdUNMLFdBQXZDLENBQW1ELFFBQW5EO0FBQ0Q7QUFkNEIsU0FBL0I7QUFnQkgsS0F2QjBDO0FBd0IzQ00sWUFBUTtBQUNOLCtCQUF3QixlQURsQjtBQUVOLDZCQUFzQjtBQUZoQixLQXhCbUM7QUE0QjNDaEIsWUFBUSxrQkFBVTtBQUNkLGFBQUtpQixHQUFMLENBQVNMLElBQVQsQ0FBYyxLQUFLakIsUUFBTCxDQUFjLEVBQWQsQ0FBZDtBQUNBLGFBQUt1QixjQUFMO0FBQ0gsS0EvQjBDO0FBZ0MzQzNCLG1CQUFlLHlCQUFVO0FBQ3JCNEIsY0FBTUMsY0FBTjtBQUNBLFlBQUl2QixPQUFPVSxFQUFFLGdCQUFGLEVBQW9CYyxlQUFwQixFQUFYO0FBQ0EsYUFBS0MsS0FBTCxDQUFXQyxHQUFYLENBQWUxQixJQUFmO0FBQ0EsWUFBSSxLQUFLeUIsS0FBTCxDQUFXRSxPQUFYLENBQW1CLElBQW5CLENBQUosRUFBOEI7QUFDMUIsaUJBQUtGLEtBQUwsQ0FBV0csSUFBWCxDQUFnQjtBQUNaQywyQkFBVzdCLEtBQUs2QixTQURKO0FBRVpDLDBCQUFVOUIsS0FBSzhCLFFBRkg7QUFHWkMsdUJBQU8vQixLQUFLK0IsS0FIQTtBQUlaQywwQkFBVWhDLEtBQUtnQyxRQUpIO0FBS1pDLDJCQUFXakMsS0FBS2lDO0FBTEosYUFBaEIsRUFNRztBQUNDQyx5QkFBUyxpQkFBU1QsS0FBVCxFQUFnQlUsUUFBaEIsRUFBMEI7QUFDL0IsNkJBQUlDLFNBQUosQ0FBY0MsT0FBZCxDQUFzQixXQUF0QjtBQUNILGlCQUhGO0FBSUNuQix1QkFBTyxlQUFTTyxLQUFULEVBQWdCVSxRQUFoQixFQUEwQjtBQUM3QnpCLHNCQUFFLGNBQUYsRUFBa0JLLElBQWxCLENBQXVCb0IsU0FBU0csWUFBVCxDQUFzQkMsT0FBN0MsRUFBc0QxQixXQUF0RCxDQUFrRSxRQUFsRTtBQUNIO0FBTkYsYUFOSDtBQWNIO0FBQ0osS0FwRDBDO0FBcUQzQzJCLFVBQU0sZ0JBQVc7QUFDYixpQkFBSUosU0FBSixDQUFjQyxPQUFkLENBQXNCLE1BQXRCO0FBQ0g7QUF2RDBDLENBQXJCLENBQTFCIiwiZmlsZSI6IjI2LmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy9WYWxpZGF0aW9uIFNvdXJjZTogaHR0cDovL2pzZmlkZGxlLm5ldC90aGVkZXJzZW4vdWRYTDUvXG5cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IGFwcCB9IGZyb20gJy4uL2FwcCc7XG5cbmFwcC52aWV3cy5sb2dpbkNyZWF0aW9uID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICAgIHRlbXBsYXRlOiBudWxsLFxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gZGF0YTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IF8udGVtcGxhdGUodGhpcy5vcHRpb25zLnRlbXBsYXRlKTtcbiAgICAgICAgdGhpcy5yZW5kZXIoKTtcblxuICAgICAgICBCYWNrYm9uZS5WYWxpZGF0aW9uLmJpbmQodGhpcywge1xuICAgICAgICAgIHZhbGlkOiBmdW5jdGlvbih2aWV3LCBhdHRyKSB7XG4gICAgICAgICAgICB2YXIgZWxlbWVudCA9IHZpZXcuJChcIltuYW1lPVwiK2F0dHIrXCJdXCIpO1xuICAgICAgICAgICAgdmFyIHBhcmVudCA9IGVsZW1lbnQuY2xvc2VzdCgnLmlucHV0V3JhcHBlcicpO1xuICAgICAgICAgICAgZWxlbWVudC5yZW1vdmVDbGFzcygnZXJyb3InKTtcbiAgICAgICAgICAgIHBhcmVudC5maW5kKCdzbWFsbC5lcnJvcicpLmh0bWwoJycpLmFkZENsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGludmFsaWQ6IGZ1bmN0aW9uKHZpZXcsIGF0dHIsIGVycm9yKSB7XG4gICAgICAgICAgICAvL0hpZGUgc2VydmVyIGVycm9ycyBpZiBpbnB1dCBlcnJvciBhcmlzZXNcbiAgICAgICAgICAgICQoJyNzZXJ2ZXJFcnJvcicpLmh0bWwoJycpLmFkZENsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICAgIHZhciBlbGVtZW50ID0gdmlldy4kKFwiW25hbWU9XCIrYXR0citcIl1cIik7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gZWxlbWVudC5jbG9zZXN0KCcuaW5wdXRXcmFwcGVyJyk7XG4gICAgICAgICAgICBlbGVtZW50LmFkZENsYXNzKCdlcnJvcicpO1xuICAgICAgICAgICAgcGFyZW50LmZpbmQoJ3NtYWxsLmVycm9yJykuaHRtbChlcnJvcikucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBldmVudHM6IHtcbiAgICAgIFwiY2xpY2sgI3N1Ym1pdEJ1dHRvblwiIDogXCJsb2dpbkNyZWF0aW9uXCIsXG4gICAgICBcImNsaWNrICNob21lQnV0dG9uXCIgOiBcImhvbWVcIlxuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLiRlbC5odG1sKHRoaXMudGVtcGxhdGUoe30pKTtcbiAgICAgICAgdGhpcy5kZWxlZ2F0ZUV2ZW50cygpO1xuICAgIH0sXG4gICAgbG9naW5DcmVhdGlvbjogZnVuY3Rpb24oKXtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgdmFyIGRhdGEgPSAkKCcjbG9naW5DcmVhdGlvbicpLnNlcmlhbGl6ZU9iamVjdCgpO1xuICAgICAgICB0aGlzLm1vZGVsLnNldChkYXRhKTtcbiAgICAgICAgaWYgKHRoaXMubW9kZWwuaXNWYWxpZCh0cnVlKSkge1xuICAgICAgICAgICAgdGhpcy5tb2RlbC5zYXZlKHtcbiAgICAgICAgICAgICAgICBGaXJzdE5hbWU6IGRhdGEuRmlyc3ROYW1lLFxuICAgICAgICAgICAgICAgIExhc3ROYW1lOiBkYXRhLkxhc3ROYW1lLFxuICAgICAgICAgICAgICAgIEVtYWlsOiBkYXRhLkVtYWlsLFxuICAgICAgICAgICAgICAgIFBhc3N3b3JkOiBkYXRhLlBhc3N3b3JkLFxuICAgICAgICAgICAgICAgIEF1dGhUb2tlbjogZGF0YS5BdXRoVG9rZW5cbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihtb2RlbCwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgYXBwLmV2ZW50X2J1cy50cmlnZ2VyKCd0aW1lU2hlZXQnKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbihtb2RlbCwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgJCgnI3NlcnZlckVycm9yJykuaHRtbChyZXNwb25zZS5yZXNwb25zZUpTT04ubWVzc2FnZSkucmVtb3ZlQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBob21lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgYXBwLmV2ZW50X2J1cy50cmlnZ2VyKCdob21lJyk7XG4gICAgfVxufSk7XG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvYXBwL2NsaWVudC1hcHAvdmlld3MvbG9naW5DcmVhdGlvbi5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.views.personCollectionView = Backbone.View.extend({\n  initialize: function initialize(options) {\n    this.personView = options.childView;\n\n    this.personViews = {};\n\n    this.collection.each(this.add, this);\n    this.listenTo(this.collection, 'add', this.add);\n    this.listenTo(this.collection, 'remove', this.removePerson);\n  },\n  add: function add(person) {\n    var personView = this.personViews[person.id] || new this.personView({\n      model: person\n    });\n    this.listenTo(personView, 'remove', this.removePerson);\n    this.personViews[person.id] = personView;\n\n    if (this.rendered) {\n      $(this.el).append(personView.render().el);\n    }\n  },\n  removePerson: function removePerson(person) {\n    var viewToRemove = this.personViews[person.id];\n    viewToRemove.close();\n  },\n  render: function render() {\n    this.rendered = true;\n    this.collection.each(function (person) {\n      this.$el.append(this.personViews[person.id].render().el);\n    }, this);\n  }\n}); //Help: http://liquidmedia.org/blog/2011/02/backbone-js-part-3/\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvdmlld3MvcGVyc29uQ29sbGVjdGlvbi5qcz8xMzg1Il0sIm5hbWVzIjpbInZpZXdzIiwicGVyc29uQ29sbGVjdGlvblZpZXciLCJCYWNrYm9uZSIsIlZpZXciLCJleHRlbmQiLCJpbml0aWFsaXplIiwib3B0aW9ucyIsInBlcnNvblZpZXciLCJjaGlsZFZpZXciLCJwZXJzb25WaWV3cyIsImNvbGxlY3Rpb24iLCJlYWNoIiwiYWRkIiwibGlzdGVuVG8iLCJyZW1vdmVQZXJzb24iLCJwZXJzb24iLCJpZCIsIm1vZGVsIiwicmVuZGVyZWQiLCIkIiwiZWwiLCJhcHBlbmQiLCJyZW5kZXIiLCJ2aWV3VG9SZW1vdmUiLCJjbG9zZSIsIiRlbCJdLCJtYXBwaW5ncyI6Ijs7QUFDQTs7QUFFQSxTQUFJQSxLQUFKLENBQVVDLG9CQUFWLEdBQWlDQyxTQUFTQyxJQUFULENBQWNDLE1BQWQsQ0FBcUI7QUFDcERDLGNBQWEsb0JBQVNDLE9BQVQsRUFBa0I7QUFDN0IsU0FBS0MsVUFBTCxHQUFrQkQsUUFBUUUsU0FBMUI7O0FBRUEsU0FBS0MsV0FBTCxHQUFtQixFQUFuQjs7QUFFQSxTQUFLQyxVQUFMLENBQWdCQyxJQUFoQixDQUFxQixLQUFLQyxHQUExQixFQUErQixJQUEvQjtBQUNBLFNBQUtDLFFBQUwsQ0FBYyxLQUFLSCxVQUFuQixFQUErQixLQUEvQixFQUFzQyxLQUFLRSxHQUEzQztBQUNBLFNBQUtDLFFBQUwsQ0FBYyxLQUFLSCxVQUFuQixFQUErQixRQUEvQixFQUF5QyxLQUFLSSxZQUE5QztBQUNELEdBVG1EO0FBVXBERixPQUFLLGFBQVNHLE1BQVQsRUFBaUI7QUFDcEIsUUFBSVIsYUFBYSxLQUFLRSxXQUFMLENBQWlCTSxPQUFPQyxFQUF4QixLQUErQixJQUFJLEtBQUtULFVBQVQsQ0FBb0I7QUFDbEVVLGFBQU9GO0FBRDJELEtBQXBCLENBQWhEO0FBR0EsU0FBS0YsUUFBTCxDQUFjTixVQUFkLEVBQTBCLFFBQTFCLEVBQW9DLEtBQUtPLFlBQXpDO0FBQ0EsU0FBS0wsV0FBTCxDQUFpQk0sT0FBT0MsRUFBeEIsSUFBOEJULFVBQTlCOztBQUVBLFFBQUksS0FBS1csUUFBVCxFQUFtQjtBQUNqQkMsUUFBRSxLQUFLQyxFQUFQLEVBQVdDLE1BQVgsQ0FBa0JkLFdBQVdlLE1BQVgsR0FBb0JGLEVBQXRDO0FBQ0Q7QUFDRixHQXBCbUQ7QUFxQnBETixnQkFBYyxzQkFBU0MsTUFBVCxFQUFpQjtBQUM3QixRQUFJUSxlQUFlLEtBQUtkLFdBQUwsQ0FBaUJNLE9BQU9DLEVBQXhCLENBQW5CO0FBQ0FPLGlCQUFhQyxLQUFiO0FBQ0QsR0F4Qm1EO0FBeUJwREYsVUFBUSxrQkFBVztBQUNqQixTQUFLSixRQUFMLEdBQWdCLElBQWhCO0FBQ0EsU0FBS1IsVUFBTCxDQUFnQkMsSUFBaEIsQ0FBc0IsVUFBU0ksTUFBVCxFQUFpQjtBQUNyQyxXQUFLVSxHQUFMLENBQVNKLE1BQVQsQ0FBZ0IsS0FBS1osV0FBTCxDQUFpQk0sT0FBT0MsRUFBeEIsRUFBNEJNLE1BQTVCLEdBQXFDRixFQUFyRDtBQUNELEtBRkQsRUFFRyxJQUZIO0FBR0Q7QUE5Qm1ELENBQXJCLENBQWpDLEMsQ0FIQSIsImZpbGUiOiIyNy5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8vSGVscDogaHR0cDovL2xpcXVpZG1lZGlhLm9yZy9ibG9nLzIwMTEvMDIvYmFja2JvbmUtanMtcGFydC0zL1xuaW1wb3J0IHsgYXBwIH0gZnJvbSAnLi4vYXBwJztcblxuYXBwLnZpZXdzLnBlcnNvbkNvbGxlY3Rpb25WaWV3ID0gQmFja2JvbmUuVmlldy5leHRlbmQoe1xuICBpbml0aWFsaXplIDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHRoaXMucGVyc29uVmlldyA9IG9wdGlvbnMuY2hpbGRWaWV3O1xuXG4gICAgdGhpcy5wZXJzb25WaWV3cyA9IHt9O1xuXG4gICAgdGhpcy5jb2xsZWN0aW9uLmVhY2godGhpcy5hZGQsIHRoaXMpO1xuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb2xsZWN0aW9uLCAnYWRkJywgdGhpcy5hZGQpO1xuICAgIHRoaXMubGlzdGVuVG8odGhpcy5jb2xsZWN0aW9uLCAncmVtb3ZlJywgdGhpcy5yZW1vdmVQZXJzb24pO1xuICB9LFxuICBhZGQ6IGZ1bmN0aW9uKHBlcnNvbikge1xuICAgIHZhciBwZXJzb25WaWV3ID0gdGhpcy5wZXJzb25WaWV3c1twZXJzb24uaWRdIHx8IG5ldyB0aGlzLnBlcnNvblZpZXcoe1xuICAgICAgbW9kZWw6IHBlcnNvblxuICAgIH0pO1xuICAgIHRoaXMubGlzdGVuVG8ocGVyc29uVmlldywgJ3JlbW92ZScsIHRoaXMucmVtb3ZlUGVyc29uKTtcbiAgICB0aGlzLnBlcnNvblZpZXdzW3BlcnNvbi5pZF0gPSBwZXJzb25WaWV3O1xuXG4gICAgaWYgKHRoaXMucmVuZGVyZWQpIHtcbiAgICAgICQodGhpcy5lbCkuYXBwZW5kKHBlcnNvblZpZXcucmVuZGVyKCkuZWwpO1xuICAgIH1cbiAgfSxcbiAgcmVtb3ZlUGVyc29uOiBmdW5jdGlvbihwZXJzb24pIHtcbiAgICB2YXIgdmlld1RvUmVtb3ZlID0gdGhpcy5wZXJzb25WaWV3c1twZXJzb24uaWRdO1xuICAgIHZpZXdUb1JlbW92ZS5jbG9zZSgpO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMucmVuZGVyZWQgPSB0cnVlO1xuICAgIHRoaXMuY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbihwZXJzb24pIHtcbiAgICAgIHRoaXMuJGVsLmFwcGVuZCh0aGlzLnBlcnNvblZpZXdzW3BlcnNvbi5pZF0ucmVuZGVyKCkuZWwpO1xuICAgIH0sIHRoaXMpO1xuICB9XG59KTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9hcHAvY2xpZW50LWFwcC92aWV3cy9wZXJzb25Db2xsZWN0aW9uLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 28 */,
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	eval("//Not particularly pleased with the nongeneric way I'm implementing this at the moment.\n//Possible alternative is to use actual dates instead of mondayTime, tuesdayTime, etc.\n// Ex: 2016-05-07-Time\n\n'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.views.TimeSelector = Backbone.View.extend({\n  initialize: function initialize(data) {\n    this.options = data;\n    this.dayIds = ['mondayTime', 'tuesdayTime', 'wednesdayTime', 'thursdayTime', 'fridayTime'];\n    this.listenTo(_app.app.event_bus, 'totalTime', this.computeTotalTime);\n    this.timeSelectorDayViews = {};\n  },\n  render: function render() {\n    this.template = _.template(_app.app.createTemplate('templates/timeSelector.tpl', { weekStartDate: this.model.get('weekStartDate'), totalTime: this.model.get('totalTime') }));\n    $(this.options.el).html(this.template({}));\n\n    for (var i = 0; i < this.dayIds.length; i++) {\n      this.timeSelectorDayViews[i] = new _app.app.views.TimeSelectorDay({\n        el: '#timePickersWrapper',\n        data: {\n          time: this.model.get(this.dayIds[i]),\n          date: moment(this.model.get('weekStartDate')).add(i, 'd')\n        }\n      }).render();\n    }\n    $('input').timepicker({\n      noneOption: true,\n      step: 15,\n      disableTouchKeyboard: true,\n      disableTextInput: true\n    });\n    if (this.checkTotalTime() > 0) {\n      this.handlePreviouslySubmitted();\n    }\n    this.delegateEvents();\n  },\n  checkTotalTime: function checkTotalTime() {\n    var totalTimeDiv = document.getElementById('totalTime');\n    var totalTime = parseFloat(totalTimeDiv.innerHTML);\n    if (totalTime > 0) {\n      totalTimeDiv.style.backgroundColor = '#69a776';\n    } else {\n      totalTimeDiv.style.backgroundColor = '#dd3c3c';\n    }\n    return totalTime;\n  },\n  computeTotalTime: function computeTotalTime() {\n    var totalTime = 0;\n    for (var i = 0; i < this.dayIds.length; i++) {\n      totalTime += this.timeSelectorDayViews[i].totalHours;\n    }\n    document.getElementById('totalTime').innerHTML = totalTime;\n    this.checkTotalTime();\n  },\n  handlePreviouslySubmitted: function handlePreviouslySubmitted() {\n    var coverDiv = document.getElementById('timePickersCover');\n    var coverInnerDiv = document.createElement('div');\n    var coverInnerDivSpan = document.createElement('div');\n    var resubmissionButton = document.createElement('button');\n    coverDiv.className = 'active';\n    resubmissionButton.innerHTML = 'Request Review';\n    resubmissionButton.className = 'expand';\n    coverInnerDivSpan.innerHTML = alreadySubmittedInfo;\n    coverInnerDiv.appendChild(coverInnerDivSpan);\n    coverInnerDiv.appendChild(resubmissionButton);\n    coverDiv.appendChild(coverInnerDiv);\n  }\n});\n\nvar alreadySubmittedInfo = 'This timesheet has already been submitted. If you would like \\\nto resubmit please request a review.';\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvdmlld3MvdGltZVNlbGVjdG9yLmpzPzM3NDQiXSwibmFtZXMiOlsidmlld3MiLCJUaW1lU2VsZWN0b3IiLCJCYWNrYm9uZSIsIlZpZXciLCJleHRlbmQiLCJpbml0aWFsaXplIiwiZGF0YSIsIm9wdGlvbnMiLCJkYXlJZHMiLCJsaXN0ZW5UbyIsImV2ZW50X2J1cyIsImNvbXB1dGVUb3RhbFRpbWUiLCJ0aW1lU2VsZWN0b3JEYXlWaWV3cyIsInJlbmRlciIsInRlbXBsYXRlIiwiXyIsImNyZWF0ZVRlbXBsYXRlIiwid2Vla1N0YXJ0RGF0ZSIsIm1vZGVsIiwiZ2V0IiwidG90YWxUaW1lIiwiJCIsImVsIiwiaHRtbCIsImkiLCJsZW5ndGgiLCJUaW1lU2VsZWN0b3JEYXkiLCJ0aW1lIiwiZGF0ZSIsIm1vbWVudCIsImFkZCIsInRpbWVwaWNrZXIiLCJub25lT3B0aW9uIiwic3RlcCIsImRpc2FibGVUb3VjaEtleWJvYXJkIiwiZGlzYWJsZVRleHRJbnB1dCIsImNoZWNrVG90YWxUaW1lIiwiaGFuZGxlUHJldmlvdXNseVN1Ym1pdHRlZCIsImRlbGVnYXRlRXZlbnRzIiwidG90YWxUaW1lRGl2IiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInBhcnNlRmxvYXQiLCJpbm5lckhUTUwiLCJzdHlsZSIsImJhY2tncm91bmRDb2xvciIsInRvdGFsSG91cnMiLCJjb3ZlckRpdiIsImNvdmVySW5uZXJEaXYiLCJjcmVhdGVFbGVtZW50IiwiY292ZXJJbm5lckRpdlNwYW4iLCJyZXN1Ym1pc3Npb25CdXR0b24iLCJjbGFzc05hbWUiLCJhbHJlYWR5U3VibWl0dGVkSW5mbyIsImFwcGVuZENoaWxkIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7O0FBRUEsU0FBSUEsS0FBSixDQUFVQyxZQUFWLEdBQXlCQyxTQUFTQyxJQUFULENBQWNDLE1BQWQsQ0FBcUI7QUFDMUNDLGNBQVks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dUIsS0FBdkIsQ0FBeEI7QUFDQSxRQUFJRSxxQkFBcUJYLFNBQVNTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBekI7QUFDQUYsYUFBU0ssU0FBVCxHQUFxQixRQUFyQjtBQUNBRCx1QkFBbUJSLFNBQW5CLEdBQStCLGdCQUEvQjtBQUNBUSx1QkFBbUJDLFNBQW5CLEdBQStCLFFBQS9CO0FBQ0FGLHNCQUFrQlAsU0FBbEIsR0FBOEJVLG9CQUE5QjtBQUNBTCxrQkFBY00sV0FBZCxDQUEwQkosaUJBQTFCO0FBQ0FGLGtCQUFjTSxXQUFkLENBQTBCSCxrQkFBMUI7QUFDQUosYUFBU08sV0FBVCxDQUFxQk4sYUFBckI7QUFDRDtBQTdEeUMsQ0FBckIsQ0FBekI7O0FBZ0VBLElBQUlLLHVCQUF1QjtxQ0FBM0IiLCJmaWxlIjoiMjkuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvL05vdCBwYXJ0aWN1bGFybHkgcGxlYXNlZCB3aXRoIHRoZSBub25nZW5lcmljIHdheSBJJ20gaW1wbGVtZW50aW5nIHRoaXMgYXQgdGhlIG1vbWVudC5cbi8vUG9zc2libGUgYWx0ZXJuYXRpdmUgaXMgdG8gdXNlIGFjdHVhbCBkYXRlcyBpbnN0ZWFkIG9mIG1vbmRheVRpbWUsIHR1ZXNkYXlUaW1lLCBldGMuXG4vLyBFeDogMjAxNi0wNS0wNy1UaW1lXG5cbid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IGFwcCB9IGZyb20gJy4uL2FwcCc7XG5cbmFwcC52aWV3cy5UaW1lU2VsZWN0b3IgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdGhpcy5vcHRpb25zID0gZGF0YTtcbiAgICAgIHRoaXMuZGF5SWRzID0gWydtb25kYXlUaW1lJywgJ3R1ZXNkYXlUaW1lJywgJ3dlZG5lc2RheVRpbWUnLCAndGh1cnNkYXlUaW1lJywgJ2ZyaWRheVRpbWUnXTtcbiAgICAgIHRoaXMubGlzdGVuVG8oYXBwLmV2ZW50X2J1cywgJ3RvdGFsVGltZScsIHRoaXMuY29tcHV0ZVRvdGFsVGltZSk7XG4gICAgICB0aGlzLnRpbWVTZWxlY3RvckRheVZpZXdzID0ge307XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCl7XG4gICAgICB0aGlzLnRlbXBsYXRlID0gXy50ZW1wbGF0ZShhcHAuY3JlYXRlVGVtcGxhdGUoJ3RlbXBsYXRlcy90aW1lU2VsZWN0b3IudHBsJywgeyB3ZWVrU3RhcnREYXRlOiB0aGlzLm1vZGVsLmdldCgnd2Vla1N0YXJ0RGF0ZScpLCB0b3RhbFRpbWU6IHRoaXMubW9kZWwuZ2V0KCd0b3RhbFRpbWUnKSB9KSk7XG4gICAgICAkKHRoaXMub3B0aW9ucy5lbCkuaHRtbCh0aGlzLnRlbXBsYXRlKHt9KSk7XG5cbiAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmRheUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLnRpbWVTZWxlY3RvckRheVZpZXdzW2ldID0gbmV3IGFwcC52aWV3cy5UaW1lU2VsZWN0b3JEYXkoe1xuICAgICAgICAgIGVsOiAnI3RpbWVQaWNrZXJzV3JhcHBlcicsXG4gICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgdGltZTogdGhpcy5tb2RlbC5nZXQodGhpcy5kYXlJZHNbaV0pLFxuICAgICAgICAgICAgZGF0ZTogbW9tZW50KHRoaXMubW9kZWwuZ2V0KCd3ZWVrU3RhcnREYXRlJykpLmFkZChpLCAnZCcpXG4gICAgICAgICAgfVxuICAgICAgICB9KS5yZW5kZXIoKTtcbiAgICAgIH1cbiAgICAgICQoJ2lucHV0JykudGltZXBpY2tlcih7XG4gICAgICAgIG5vbmVPcHRpb246IHRydWUsXG4gICAgICAgIHN0ZXA6IDE1LFxuICAgICAgICBkaXNhYmxlVG91Y2hLZXlib2FyZDogdHJ1ZSxcbiAgICAgICAgZGlzYWJsZVRleHRJbnB1dDogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpZiAodGhpcy5jaGVja1RvdGFsVGltZSgpPjApIHtcbiAgICAgICAgdGhpcy5oYW5kbGVQcmV2aW91c2x5U3VibWl0dGVkKCk7XG4gICAgICB9XG4gICAgICB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgfSxcbiAgICBjaGVja1RvdGFsVGltZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdG90YWxUaW1lRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RvdGFsVGltZScpO1xuICAgICAgdmFyIHRvdGFsVGltZSA9IHBhcnNlRmxvYXQodG90YWxUaW1lRGl2LmlubmVySFRNTCk7XG4gICAgICBpZiAodG90YWxUaW1lPjApIHtcbiAgICAgICAgdG90YWxUaW1lRGl2LnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjNjlhNzc2JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRvdGFsVGltZURpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2RkM2MzYyc7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG90YWxUaW1lO1xuICAgIH0sXG4gICAgY29tcHV0ZVRvdGFsVGltZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdG90YWxUaW1lID0gMDtcbiAgICAgIGZvciAodmFyIGk9MDsgaTx0aGlzLmRheUlkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0b3RhbFRpbWUgKz0gdGhpcy50aW1lU2VsZWN0b3JEYXlWaWV3c1tpXS50b3RhbEhvdXJzO1xuICAgICAgfVxuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RvdGFsVGltZScpLmlubmVySFRNTCA9IHRvdGFsVGltZTtcbiAgICAgIHRoaXMuY2hlY2tUb3RhbFRpbWUoKTtcbiAgICB9LFxuICAgIGhhbmRsZVByZXZpb3VzbHlTdWJtaXR0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGNvdmVyRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RpbWVQaWNrZXJzQ292ZXInKTtcbiAgICAgIHZhciBjb3ZlcklubmVyRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICB2YXIgY292ZXJJbm5lckRpdlNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHZhciByZXN1Ym1pc3Npb25CdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKTtcbiAgICAgIGNvdmVyRGl2LmNsYXNzTmFtZSA9ICdhY3RpdmUnO1xuICAgICAgcmVzdWJtaXNzaW9uQnV0dG9uLmlubmVySFRNTCA9ICdSZXF1ZXN0IFJldmlldyc7XG4gICAgICByZXN1Ym1pc3Npb25CdXR0b24uY2xhc3NOYW1lID0gJ2V4cGFuZCc7XG4gICAgICBjb3ZlcklubmVyRGl2U3Bhbi5pbm5lckhUTUwgPSBhbHJlYWR5U3VibWl0dGVkSW5mbztcbiAgICAgIGNvdmVySW5uZXJEaXYuYXBwZW5kQ2hpbGQoY292ZXJJbm5lckRpdlNwYW4pO1xuICAgICAgY292ZXJJbm5lckRpdi5hcHBlbmRDaGlsZChyZXN1Ym1pc3Npb25CdXR0b24pO1xuICAgICAgY292ZXJEaXYuYXBwZW5kQ2hpbGQoY292ZXJJbm5lckRpdik7XG4gICAgfVxufSk7XG5cbnZhciBhbHJlYWR5U3VibWl0dGVkSW5mbyA9ICdUaGlzIHRpbWVzaGVldCBoYXMgYWxyZWFkeSBiZWVuIHN1Ym1pdHRlZC4gSWYgeW91IHdvdWxkIGxpa2UgXFxcbnRvIHJlc3VibWl0IHBsZWFzZSByZXF1ZXN0IGEgcmV2aWV3Lic7XG5cblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9hcHAvY2xpZW50LWFwcC92aWV3cy90aW1lU2VsZWN0b3IuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.views.TimeSelectorDay = Backbone.View.extend({\n  initialize: function initialize(data) {\n    this.options = data;\n    this.options.data.formattedDate = moment(this.options.data.date).format('YYYY-MM-DD');\n    this.events = this.events || {};\n    var inputEventKey = 'change' + ' .input-' + this.options.data.formattedDate;\n    this.events[inputEventKey] = 'inputCheck';\n    this.totalHours = 0;\n  },\n  render: function render() {\n    this.template = _.template(_app.app.createTemplate('templates/timeSelectorDay.tpl', this.options.data));\n    $(this.options.el).append(this.template({}));\n    this.delegateEvents();\n    this.checkTotalTime();\n    return this;\n  },\n  inputCheck: function inputCheck() {\n    var totalTimeDiv = document.getElementById('totalHours-' + this.options.data.formattedDate);\n    var totalTime = 0;\n    //compute total hours\n    var morningLoginHour = $('#timeselectors-' + this.options.data.formattedDate + ' #morning-login').val();\n    var morningLogoutHourElement = $('#timeselectors-' + this.options.data.formattedDate + ' #morning-logout');\n    if (morningLoginHour) {\n      morningLogoutHourElement.timepicker('option', { 'minTime': morningLoginHour });\n    }\n    var morningLogoutHour = morningLogoutHourElement.val();\n    var morningHours = moment(morningLogoutHour, 'LT').diff(moment(morningLoginHour, 'LT'), 'h', true);\n    if (morningHours >= 0) {\n      totalTime += morningHours;\n    }\n    var afternoonLoginHour = $('#timeselectors-' + this.options.data.formattedDate + ' #afternoon-login').val();\n    var afternoonLogoutHourElement = $('#timeselectors-' + this.options.data.formattedDate + ' #afternoon-logout');\n    if (afternoonLoginHour) {\n      afternoonLogoutHourElement.timepicker('option', { 'minTime': afternoonLoginHour });\n    }\n    var afternoonLogoutHour = afternoonLogoutHourElement.val();\n    var afternoonHours = moment(afternoonLogoutHour, 'LT').diff(moment(afternoonLoginHour, 'LT'), 'h', true);\n    if (afternoonHours >= 0) {\n      totalTime += afternoonHours;\n    }\n    totalTimeDiv.innerHTML = totalTime;\n    this.checkTotalTime();\n    _app.app.event_bus.trigger('totalTime');\n    _app.app.event_bus.trigger('inputChange');\n  },\n  checkTotalTime: function checkTotalTime() {\n    var totalTimeDiv = document.getElementById('totalHours-' + this.options.data.formattedDate);\n    var totalTime = parseFloat(totalTimeDiv.innerHTML);\n    if (totalTime > 0) {\n      totalTimeDiv.style.backgroundColor = '#69a776';\n    } else {\n      totalTimeDiv.style.backgroundColor = '#dd3c3c';\n    }\n    this.totalHours = totalTime;\n  }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvdmlld3MvdGltZVNlbGVjdG9yRGF5LmpzPzdjMTUiXSwibmFtZXMiOlsidmlld3MiLCJUaW1lU2VsZWN0b3JEYXkiLCJCYWNrYm9uZSIsIlZpZXciLCJleHRlbmQiLCJpbml0aWFsaXplIiwiZGF0YSIsIm9wdGlvbnMiLCJmb3JtYXR0ZWREYXRlIiwibW9tZW50IiwiZGF0ZSIsImZvcm1hdCIsImV2ZW50cyIsImlucHV0RXZlbnRLZXkiLCJ0b3RhbEhvdXJzIiwicmVuZGVyIiwidGVtcGxhdGUiLCJfIiwiY3JlYXRlVGVtcGxhdGUiLCIkIiwiZWwiLCJhcHBlbmQiLCJkZWxlZ2F0ZUV2ZW50cyIsImNoZWNrVG90YWxUaW1lIiwiaW5wdXRDaGVjayIsInRvdGFsVGltZURpdiIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJ0b3RhbFRpbWUiLCJtb3JuaW5nTG9naW5Ib3VyIiwidmFsIiwibW9ybmluZ0xvZ291dEhvdXJFbGVtZW50IiwidGltZXBpY2tlciIsIm1vcm5pbmdMb2dvdXRIb3VyIiwibW9ybmluZ0hvdXJzIiwiZGlmZiIsImFmdGVybm9vbkxvZ2luSG91ciIsImFmdGVybm9vbkxvZ291dEhvdXJFbGVtZW50IiwiYWZ0ZXJub29uTG9nb3V0SG91ciIsImFmdGVybm9vbkhvdXJzIiwiaW5uZXJIVE1MIiwiZXZlbnRfYnVzIiwidHJpZ2dlciIsInBhcnNlRmxvYXQiLCJzdHlsZSIsImJhY2tncm91bmRDb2xvciJdLCJtYXBwaW5ncyI6IkFBQUE7O0FBQ0E7O0FBRUEsU0FBSUEsS0FBSixDQUFVQyxlQUFWLEdBQTRCQyxTQUFTQyxJQUFULENBQWNDLE1BQWQsQ0FBcUI7QUFDN0NDLGNBQVksb0JBQVNDLElBQVQsRUFBZTtBQUN6QixTQUFLQyxPQUFMLEdBQWVELElBQWY7QUFDQSxTQUFLQyxPQUFMLENBQWFELElBQWIsQ0FBa0JFLGFBQWxCLEdBQWtDQyxPQUFPLEtBQUtGLE9BQUwsQ0FB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QVNDLGNBQVQsQ0FBd0IsZ0JBQWMsS0FBS3BCLE9BQUwsQ0FBYUQsSUFBYixDQUFrQkUsYUFBeEQsQ0FBbkI7QUFDQSxRQUFJb0IsWUFBWWUsV0FBV2xCLGFBQWFlLFNBQXhCLENBQWhCO0FBQ0EsUUFBSVosWUFBVSxDQUFkLEVBQWlCO0FBQ2ZILG1CQUFhbUIsS0FBYixDQUFtQkMsZUFBbkIsR0FBcUMsU0FBckM7QUFDRCxLQUZELE1BRU87QUFDTHBCLG1CQUFhbUIsS0FBYixDQUFtQkMsZUFBbkIsR0FBcUMsU0FBckM7QUFDRDtBQUNELFNBQUsvQixVQUFMLEdBQWtCYyxTQUFsQjtBQUNEO0FBdEQ0QyxDQUFyQixDQUE1QiIsImZpbGUiOiIzMC5qcyIsInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcbmltcG9ydCB7IGFwcCB9IGZyb20gJy4uL2FwcCc7XG5cbmFwcC52aWV3cy5UaW1lU2VsZWN0b3JEYXkgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgdGhpcy5vcHRpb25zID0gZGF0YTtcbiAgICAgIHRoaXMub3B0aW9ucy5kYXRhLmZvcm1hdHRlZERhdGUgPSBtb21lbnQodGhpcy5vcHRpb25zLmRhdGEuZGF0ZSkuZm9ybWF0KCdZWVlZLU1NLUREJyk7XG4gICAgICB0aGlzLmV2ZW50cyA9IHRoaXMuZXZlbnRzIHx8IHt9O1xuICAgICAgdmFyIGlucHV0RXZlbnRLZXkgPSAnY2hhbmdlJyArICcgLmlucHV0LScgKyB0aGlzLm9wdGlvbnMuZGF0YS5mb3JtYXR0ZWREYXRlO1xuICAgICAgdGhpcy5ldmVudHNbaW5wdXRFdmVudEtleV0gPSAnaW5wdXRDaGVjayc7XG4gICAgICB0aGlzLnRvdGFsSG91cnMgPSAwO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpe1xuICAgICAgdGhpcy50ZW1wbGF0ZSA9IF8udGVtcGxhdGUoYXBwLmNyZWF0ZVRlbXBsYXRlKCd0ZW1wbGF0ZXMvdGltZVNlbGVjdG9yRGF5LnRwbCcsIHRoaXMub3B0aW9ucy5kYXRhKSk7XG4gICAgICAkKHRoaXMub3B0aW9ucy5lbCkuYXBwZW5kKHRoaXMudGVtcGxhdGUoe30pKTtcbiAgICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgIHRoaXMuY2hlY2tUb3RhbFRpbWUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgaW5wdXRDaGVjazogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdG90YWxUaW1lRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RvdGFsSG91cnMtJyt0aGlzLm9wdGlvbnMuZGF0YS5mb3JtYXR0ZWREYXRlKTtcbiAgICAgIHZhciB0b3RhbFRpbWUgPSAwO1xuICAgICAgLy9jb21wdXRlIHRvdGFsIGhvdXJzXG4gICAgICB2YXIgbW9ybmluZ0xvZ2luSG91ciA9ICQoJyN0aW1lc2VsZWN0b3JzLScrdGhpcy5vcHRpb25zLmRhdGEuZm9ybWF0dGVkRGF0ZSsnICNtb3JuaW5nLWxvZ2luJykudmFsKCk7XG4gICAgICB2YXIgbW9ybmluZ0xvZ291dEhvdXJFbGVtZW50ID0gJCgnI3RpbWVzZWxlY3RvcnMtJyt0aGlzLm9wdGlvbnMuZGF0YS5mb3JtYXR0ZWREYXRlKycgI21vcm5pbmctbG9nb3V0Jyk7XG4gICAgICBpZiAobW9ybmluZ0xvZ2luSG91cikge1xuICAgICAgICBtb3JuaW5nTG9nb3V0SG91ckVsZW1lbnQudGltZXBpY2tlcignb3B0aW9uJywgeydtaW5UaW1lJyA6IG1vcm5pbmdMb2dpbkhvdXJ9ICk7XG4gICAgICB9XG4gICAgICB2YXIgbW9ybmluZ0xvZ291dEhvdXIgPSBtb3JuaW5nTG9nb3V0SG91ckVsZW1lbnQudmFsKCk7XG4gICAgICB2YXIgbW9ybmluZ0hvdXJzID0gbW9tZW50KG1vcm5pbmdMb2dvdXRIb3VyLCAnTFQnKS5kaWZmKG1vbWVudChtb3JuaW5nTG9naW5Ib3VyLCAnTFQnKSwgJ2gnLCB0cnVlKTtcbiAgICAgIGlmIChtb3JuaW5nSG91cnM+PTApIHtcbiAgICAgICAgdG90YWxUaW1lICs9IG1vcm5pbmdIb3VycztcbiAgICAgIH1cbiAgICAgIHZhciBhZnRlcm5vb25Mb2dpbkhvdXIgPSAkKCcjdGltZXNlbGVjdG9ycy0nK3RoaXMub3B0aW9ucy5kYXRhLmZvcm1hdHRlZERhdGUrJyAjYWZ0ZXJub29uLWxvZ2luJykudmFsKCk7XG4gICAgICB2YXIgYWZ0ZXJub29uTG9nb3V0SG91ckVsZW1lbnQgPSAkKCcjdGltZXNlbGVjdG9ycy0nK3RoaXMub3B0aW9ucy5kYXRhLmZvcm1hdHRlZERhdGUrJyAjYWZ0ZXJub29uLWxvZ291dCcpO1xuICAgICAgaWYgKGFmdGVybm9vbkxvZ2luSG91cikge1xuICAgICAgICBhZnRlcm5vb25Mb2dvdXRIb3VyRWxlbWVudC50aW1lcGlja2VyKCdvcHRpb24nLCB7J21pblRpbWUnIDogYWZ0ZXJub29uTG9naW5Ib3VyfSApO1xuICAgICAgfVxuICAgICAgdmFyIGFmdGVybm9vbkxvZ291dEhvdXIgPSBhZnRlcm5vb25Mb2dvdXRIb3VyRWxlbWVudC52YWwoKTtcbiAgICAgIHZhciBhZnRlcm5vb25Ib3VycyA9IG1vbWVudChhZnRlcm5vb25Mb2dvdXRIb3VyLCAnTFQnKS5kaWZmKG1vbWVudChhZnRlcm5vb25Mb2dpbkhvdXIsICdMVCcpLCAnaCcsIHRydWUpO1xuICAgICAgaWYgKGFmdGVybm9vbkhvdXJzPj0wKSB7XG4gICAgICAgIHRvdGFsVGltZSArPSBhZnRlcm5vb25Ib3VycztcbiAgICAgIH1cbiAgICAgIHRvdGFsVGltZURpdi5pbm5lckhUTUwgPSB0b3RhbFRpbWU7XG4gICAgICB0aGlzLmNoZWNrVG90YWxUaW1lKCk7XG4gICAgICBhcHAuZXZlbnRfYnVzLnRyaWdnZXIoJ3RvdGFsVGltZScpO1xuICAgICAgYXBwLmV2ZW50X2J1cy50cmlnZ2VyKCdpbnB1dENoYW5nZScpO1xuICAgIH0sXG4gICAgY2hlY2tUb3RhbFRpbWU6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdG90YWxUaW1lRGl2ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RvdGFsSG91cnMtJyt0aGlzLm9wdGlvbnMuZGF0YS5mb3JtYXR0ZWREYXRlKTtcbiAgICAgIHZhciB0b3RhbFRpbWUgPSBwYXJzZUZsb2F0KHRvdGFsVGltZURpdi5pbm5lckhUTUwpO1xuICAgICAgaWYgKHRvdGFsVGltZT4wKSB7XG4gICAgICAgIHRvdGFsVGltZURpdi5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnIzY5YTc3Nic7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3RhbFRpbWVEaXYuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNkZDNjM2MnO1xuICAgICAgfVxuICAgICAgdGhpcy50b3RhbEhvdXJzID0gdG90YWxUaW1lO1xuICAgIH1cbn0pO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2FwcC9jbGllbnQtYXBwL3ZpZXdzL3RpbWVTZWxlY3RvckRheS5qc1xuICoqLyJdLCJzb3VyY2VSb290IjoiIn0=");

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.views.timeSheet = Backbone.View.extend({\n    template: null,\n    initialize: function initialize(data) {\n        var initializedWeekStartDate = moment().startOf('isoWeek').format('YYYY-MM-DD');\n\n        this.options = data;\n        this.template = _.template(this.options.template);\n        this.timeSheets = new _app.app.collections.TimeSheets();\n        this.calendarView = new _app.app.views.Calendar({\n            el: '#clndr-view',\n            renderWeekStartDate: initializedWeekStartDate,\n            collection: this.timeSheets\n        });\n\n        this.listenTo(this.calendarView, 'timeSelector', this.renderTimeSelector);\n    },\n    render: function render() {\n        var initializedWeekStartDate = moment().startOf('isoWeek').format('YYYY-MM-DD');\n        //Render Parent\n        this.$el.html(this.template({}));\n\n        //Render Calendar\n        this.calendarView.render();\n        this.delegateEvents();\n    },\n    renderTimeSelector: function renderTimeSelector(date) {\n        var model = this.timeSheets.find(function (timeSheet) {\n            var modelStartDate = moment.utc(timeSheet.get('weekStartDate')).format('YYYY-MM-DD');\n            return moment(modelStartDate).isSame(date);\n        });\n        if (this.timeSelectorView) {\n            this.timeSelectorView.close();\n        }\n        this.timeSelectorView = new _app.app.views.TimeSelector({\n            el: '#timeSelector-view',\n            model: model\n        });\n        this.timeSelectorView.render();\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvdmlld3MvdGltZVNoZWV0LmpzPzEwYjIiXSwibmFtZXMiOlsidmlld3MiLCJ0aW1lU2hlZXQiLCJCYWNrYm9uZSIsIlZpZXciLCJleHRlbmQiLCJ0ZW1wbGF0ZSIsImluaXRpYWxpemUiLCJkYXRhIiwiaW5pdGlhbGl6ZWRXZWVrU3RhcnREYXRlIiwibW9tZW50Iiwic3RhcnRPZiIsImZvcm1hdCIsIm9wdGlvbnMiLCJfIiwidGltZVNoZWV0cyIsImNvbGxlY3Rpb25zIiwiVGltZVNoZWV0cyIsImNhbGVuZGFyVmlldyIsIkNhbGVuZGFyIiwiZWwiLCJyZW5kZXJXZWVrU3RhcnREYXRlIiwiY29sbGVjdGlvbiIsImxpc3RlblRvIiwicmVuZGVyVGltZVNlbGVjdG9yIiwicmVuZGVyIiwiJGVsIiwiaHRtbCIsImRlbGVnYXRlRXZlbnRzIiwiZGF0ZSIsIm1vZGVsIiwiZmluZCIsIm1vZGVsU3RhcnREYXRlIiwidXRjIiwiZ2V0IiwiaXNTYW1lIiwidGltZVNlbGVjdG9yVmlldyIsImNsb3NlIiwiVGltZVNlbGVjdG9yIl0sIm1hcHBpbmdzIjoiQUFBQTs7QUFDQTs7QUFFQSxTQUFJQSxLQUFKLENBQVVDLFNBQVYsR0FBc0JDLFNBQVNDLElBQVQsQ0FBY0MsTUFBZCxDQUFxQjtBQUN2Q0MsY0FBVSxJQUQ2QjtBQUV2Q0MsZ0JBQVksb0JBQVNDLElBQVQsRUFBZTtBQUN2QixZQUFJQywyQkFBMkJDLFNBQVNDLE9BQVQsQ0FBaUIsU0FBakIsRUFBNEJDLE1BQTVCLENBQW1DLFlBQW5DLENBQS9COztBQUVBLGFBQUtDLE9BQUwsR0FBZUwsSUFBZjtBQUNBLGFBQUtGLFFBQUwsR0FBZ0JRLEVBQUVSLFFBQUYsQ0FBVyxLQUFLTyxPQUFMLENBQWFQLFFBQXhCLENBQWhCO0FBQ0EsYUFBS1MsVUFBTCxHQUFrQixJQUFJLFNBQUlDLFdBQUosQ0FBZ0JDLFVBQXBCLEVBQWxCO0FBQ0EsYUFBS0MsWUFBTCxHQUFvQixJQUFJLFNBQUlqQixLQUFKLENBQVVrQixRQUFkLENBQXVCO0FBQ3ZDQyxnQkFBSSxhQURtQztBQUV2Q0MsaUNBQXFCWix3QkFGa0I7QUFHdkNhLHdCQUFZLEtBQUtQO0FBSHNCLFNBQXZCLENBQXBCOztBQU1BLGFBQUtRLFFBQUwsQ0FBYyxLQUFLTCxZQUFuQixFQUFpQyxjQUFqQyxFQUFpRCxLQUFLTSxrQkFBdEQ7QUFDSCxLQWZzQztBQWdCdkNDLFlBQVEsa0JBQVc7QUFDZixZQUFJaEIsMkJBQTJCQyxTQUFTQyxPQUFULENBQWlCLFNBQWpCLEVBQTRCQyxNQUE1QixDQUFtQyxZQUFuQyxDQUEvQjtBQUNBO0FBQ0EsYUFBS2MsR0FBTCxDQUFTQyxJQUFULENBQWMsS0FBS3JCLFFBQUwsQ0FBYyxFQUFkLENBQWQ7O0FBRUE7QUFDQSxhQUFLWSxZQUFMLENBQWtCTyxNQUFsQjtBQUNBLGFBQUtHLGNBQUw7QUFDSCxLQXhCc0M7QUF5QnZDSix3QkFBb0IsNEJBQVNLLElBQVQsRUFBZTtBQUMvQixZQUFJQyxRQUFRLEtBQUtmLFVBQUwsQ0FBZ0JnQixJQUFoQixDQUFxQixVQUFTN0IsU0FBVCxFQUFvQjtBQUNqRCxnQkFBSThCLGlCQUFpQnRCLE9BQU91QixHQUFQLENBQVcvQixVQUFVZ0MsR0FBVixDQUFjLGVBQWQsQ0FBWCxFQUEyQ3RCLE1BQTNDLENBQWtELFlBQWxELENBQXJCO0FBQ0EsbUJBQU9GLE9BQU9zQixjQUFQLEVBQXVCRyxNQUF2QixDQUE4Qk4sSUFBOUIsQ0FBUDtBQUNILFNBSFcsQ0FBWjtBQUlBLFlBQUksS0FBS08sZ0JBQVQsRUFBMkI7QUFDdkIsaUJBQUtBLGdCQUFMLENBQXNCQyxLQUF0QjtBQUNIO0FBQ0QsYUFBS0QsZ0JBQUwsR0FBd0IsSUFBSSxTQUFJbkMsS0FBSixDQUFVcUMsWUFBZCxDQUEyQjtBQUMvQ2xCLGdCQUFJLG9CQUQyQztBQUUvQ1UsbUJBQU9BO0FBRndDLFNBQTNCLENBQXhCO0FBSUEsYUFBS00sZ0JBQUwsQ0FBc0JYLE1BQXRCO0FBQ0g7QUF0Q3NDLENBQXJCLENBQXRCIiwiZmlsZSI6IjMxLmpzIiwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgYXBwIH0gZnJvbSAnLi4vYXBwJztcblxuYXBwLnZpZXdzLnRpbWVTaGVldCA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICB0ZW1wbGF0ZTogbnVsbCxcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHZhciBpbml0aWFsaXplZFdlZWtTdGFydERhdGUgPSBtb21lbnQoKS5zdGFydE9mKCdpc29XZWVrJykuZm9ybWF0KCdZWVlZLU1NLUREJyk7XG5cbiAgICAgICAgdGhpcy5vcHRpb25zID0gZGF0YTtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZSA9IF8udGVtcGxhdGUodGhpcy5vcHRpb25zLnRlbXBsYXRlKTtcbiAgICAgICAgdGhpcy50aW1lU2hlZXRzID0gbmV3IGFwcC5jb2xsZWN0aW9ucy5UaW1lU2hlZXRzKCk7XG4gICAgICAgIHRoaXMuY2FsZW5kYXJWaWV3ID0gbmV3IGFwcC52aWV3cy5DYWxlbmRhcih7XG4gICAgICAgICAgICBlbDogJyNjbG5kci12aWV3JyxcbiAgICAgICAgICAgIHJlbmRlcldlZWtTdGFydERhdGU6IGluaXRpYWxpemVkV2Vla1N0YXJ0RGF0ZSxcbiAgICAgICAgICAgIGNvbGxlY3Rpb246IHRoaXMudGltZVNoZWV0c1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmxpc3RlblRvKHRoaXMuY2FsZW5kYXJWaWV3LCAndGltZVNlbGVjdG9yJywgdGhpcy5yZW5kZXJUaW1lU2VsZWN0b3IpO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGluaXRpYWxpemVkV2Vla1N0YXJ0RGF0ZSA9IG1vbWVudCgpLnN0YXJ0T2YoJ2lzb1dlZWsnKS5mb3JtYXQoJ1lZWVktTU0tREQnKTtcbiAgICAgICAgLy9SZW5kZXIgUGFyZW50XG4gICAgICAgIHRoaXMuJGVsLmh0bWwodGhpcy50ZW1wbGF0ZSh7fSkpO1xuXG4gICAgICAgIC8vUmVuZGVyIENhbGVuZGFyXG4gICAgICAgIHRoaXMuY2FsZW5kYXJWaWV3LnJlbmRlcigpO1xuICAgICAgICB0aGlzLmRlbGVnYXRlRXZlbnRzKCk7XG4gICAgfSxcbiAgICByZW5kZXJUaW1lU2VsZWN0b3I6IGZ1bmN0aW9uKGRhdGUpIHtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy50aW1lU2hlZXRzLmZpbmQoZnVuY3Rpb24odGltZVNoZWV0KSB7XG4gICAgICAgICAgICB2YXIgbW9kZWxTdGFydERhdGUgPSBtb21lbnQudXRjKHRpbWVTaGVldC5nZXQoJ3dlZWtTdGFydERhdGUnKSkuZm9ybWF0KCdZWVlZLU1NLUREJyk7XG4gICAgICAgICAgICByZXR1cm4gbW9tZW50KG1vZGVsU3RhcnREYXRlKS5pc1NhbWUoZGF0ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy50aW1lU2VsZWN0b3JWaWV3KSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVTZWxlY3RvclZpZXcuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRpbWVTZWxlY3RvclZpZXcgPSBuZXcgYXBwLnZpZXdzLlRpbWVTZWxlY3Rvcih7XG4gICAgICAgICAgICBlbDogJyN0aW1lU2VsZWN0b3ItdmlldycsXG4gICAgICAgICAgICBtb2RlbDogbW9kZWxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGltZVNlbGVjdG9yVmlldy5yZW5kZXIoKTtcbiAgICB9XG59KTtcblxuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogLi9zcmMvYXBwL2NsaWVudC1hcHAvdmlld3MvdGltZVNoZWV0LmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	eval("'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.views.unverifiedUser = Backbone.View.extend({\n    initialize: function initialize(data) {\n        this.options = data;\n        this.resendSignupEmailModel = new _app.app.models.ResendSignupEmail();\n    },\n    render: function render() {\n        this.template = _.template(_app.app.createTemplate('templates/unverifiedUser.tpl', { person: this.model.attributes }));\n        this.$el.html(this.template({}));\n        this.delegateEvents();\n        return this;\n    },\n    events: {\n        'click .deleteButton': 'delete',\n        'click .resendButton': 'resendSignupEmail'\n    },\n    delete: function _delete() {\n        var that = this;\n        $('#deleteModal').foundation('reveal', 'open');\n        $(document).on('opened.fndtn.reveal', '#deleteModal[data-reveal]', function () {\n            $('#deleteYes').click(function () {\n                that.model.destroy();\n                $('#deleteModal[data-reveal]').foundation('reveal', 'close');\n                modalListenerCleanup();\n            });\n            $('#deleteNo').click(function (event) {\n                $('#deleteModal[data-reveal]').foundation('reveal', 'close');\n                modalListenerCleanup();\n            });\n        });\n\n        function modalListenerCleanup() {\n            $(document).off('opened.fndtn.reveal');\n            $('#deleteYes').off('click');\n            $('#deleteNo').off('click');\n        }\n    },\n    resendSignupEmail: function resendSignupEmail() {\n        var that = this;\n        this.resendSignupEmailModel.save({\n            Email: this.model.get('Email'),\n            Token: this.model.get('id')\n        }, {\n            success: function success(model, response) {\n                $('#resendSignupEmailModal').foundation('reveal', 'open');\n            },\n            error: function error(model, response) {\n                //Some sort of error handling here\n            }\n        });\n        console.log();\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvdmlld3MvdW52ZXJpZmllZFVzZXIuanM/YTQ1ZiJdLCJuYW1lcyI6WyJ2aWV3cyIsInVudmVyaWZpZWRVc2VyIiwiQmFja2JvbmUiLCJWaWV3IiwiZXh0ZW5kIiwiaW5pdGlhbGl6ZSIsImRhdGEiLCJvcHRpb25zIiwicmVzZW5kU2lnbnVwRW1haWxNb2RlbCIsIm1vZGVscyIsIlJlc2VuZFNpZ251cEVtYWlsIiwicmVuZGVyIiwidGVtcGxhdGUiLCJfIiwiY3JlYXRlVGVtcGxhdGUiLCJwZXJzb24iLCJtb2RlbCIsImF0dHJpYnV0ZXMiLCIkZWwiLCJodG1sIiwiZGVsZWdhdGVFdmVudHMiLCJldmVudHMiLCJkZWxldGUiLCJ0aGF0IiwiJCIsImZvdW5kYXRpb24iLCJkb2N1bWVudCIsIm9uIiwiY2xpY2siLCJkZXN0cm95IiwibW9kYWxMaXN0ZW5lckNsZWFudXAiLCJldmVudCIsIm9mZiIsInJlc2VuZFNpZ251cEVtYWlsIiwic2F2ZSIsIkVtYWlsIiwiZ2V0IiwiVG9rZW4iLCJzdWNjZXNzIiwicmVzcG9uc2UiLCJlcnJvciIsImNvbnNvbGUiLCJsb2ciXSwibWFwcGluZ3MiOiJBQUFBOztBQUNBOztBQUVBLFNBQUlBLEtBQUosQ0FBVUMsY0FBVixHQUEyQkMsU0FBU0MsSUFBVCxDQUFjQyxNQUFkLENBQXFCO0FBQzVDQyxnQkFBWSxvQkFBU0MsSUFBVCxFQUFlO0FBQ3ZCLGFBQUtDLE9BQUwsR0FBZUQsSUFBZjtBQUNBLGFBQUtFLHNCQUFMLEdBQThCLElBQUksU0FBSUMsTUFBSixDQUFXQyxpQkFBZixFQUE5QjtBQUNILEtBSjJDO0FBSzVDQyxZQUFRLGtCQUFVO0FBQ2QsYUFBS0MsUUFBTCxHQUFnQkMsRUFBRUQsUUFBRixDQUFXLFNBQUlFLGNBQUosQ0FBbUIsOEJBQW5CLEVBQW1ELEVBQUVDLFFBQVEsS0FBS0MsS0FBTCxDQUFXQyxVQUFyQixFQUFuRCxDQUFYLENBQWhCO0FBQ0EsYUFBS0MsR0FBTCxDQUFTQyxJQUFULENBQWMsS0FBS1AsUUFBTCxDQUFjLEVBQWQsQ0FBZDtBQUNBLGFBQUtRLGNBQUw7QUFDQSxlQUFPLElBQVA7QUFDSCxLQVYyQztBQVc1Q0MsWUFBUTtBQUNOLCtCQUF3QixRQURsQjtBQUVOLCtCQUF3QjtBQUZsQixLQVhvQztBQWU1Q0MsWUFBUSxtQkFBVztBQUNqQixZQUFJQyxPQUFPLElBQVg7QUFDQUMsVUFBRSxjQUFGLEVBQWtCQyxVQUFsQixDQUE2QixRQUE3QixFQUF1QyxNQUF2QztBQUNBRCxVQUFFRSxRQUFGLEVBQVlDLEVBQVosQ0FBZSxxQkFBZixFQUFzQywyQkFBdEMsRUFBbUUsWUFBWTtBQUMzRUgsY0FBRSxZQUFGLEVBQWdCSSxLQUFoQixDQUFzQixZQUFZO0FBQzlCTCxxQkFBS1AsS0FBTCxDQUFXYSxPQUFYO0FBQ0FMLGtCQUFFLDJCQUFGLEVBQStCQyxVQUEvQixDQUEwQyxRQUExQyxFQUFvRCxPQUFwRDtBQUNBSztBQUNILGFBSkQ7QUFLQU4sY0FBRSxXQUFGLEVBQWVJLEtBQWYsQ0FBcUIsVUFBVUcsS0FBVixFQUFpQjtBQUNsQ1Asa0JBQUUsMkJBQUYsRUFBK0JDLFVBQS9CLENBQTBDLFFBQTFDLEVBQW9ELE9BQXBEO0FBQ0FLO0FBQ0gsYUFIRDtBQUlILFNBVkQ7O0FBWUEsaUJBQVNBLG9CQUFULEdBQWdDO0FBQzlCTixjQUFFRSxRQUFGLEVBQVlNLEdBQVosQ0FBZ0IscUJBQWhCO0FBQ0FSLGNBQUUsWUFBRixFQUFnQlEsR0FBaEIsQ0FBb0IsT0FBcEI7QUFDQVIsY0FBRSxXQUFGLEVBQWVRLEdBQWYsQ0FBbUIsT0FBbkI7QUFDRDtBQUNGLEtBbkMyQztBQW9DNUNDLHVCQUFtQiw2QkFBVztBQUM1QixZQUFJVixPQUFPLElBQVg7QUFDQSxhQUFLZixzQkFBTCxDQUE0QjBCLElBQTVCLENBQWlDO0FBQzdCQyxtQkFBTyxLQUFLbkIsS0FBTCxDQUFXb0IsR0FBWCxDQUFlLE9BQWYsQ0FEc0I7QUFFN0JDLG1CQUFPLEtBQUtyQixLQUFMLENBQVdvQixHQUFYLENBQWUsSUFBZjtBQUZzQixTQUFqQyxFQUdHO0FBQ0NFLHFCQUFTLGlCQUFTdEIsS0FBVCxFQUFnQnVCLFFBQWhCLEVBQTBCO0FBQ2pDZixrQkFBRSx5QkFBRixFQUE2QkMsVUFBN0IsQ0FBd0MsUUFBeEMsRUFBa0QsTUFBbEQ7QUFDRCxhQUhGO0FBSUNlLG1CQUFPLGVBQVN4QixLQUFULEVBQWdCdUIsUUFBaEIsRUFBMEI7QUFDN0I7QUFDSDtBQU5GLFNBSEg7QUFXQUUsZ0JBQVFDLEdBQVI7QUFDRDtBQWxEMkMsQ0FBckIsQ0FBM0IiLCJmaWxlIjoiMzIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5pbXBvcnQgeyBhcHAgfSBmcm9tICcuLi9hcHAnO1xuXG5hcHAudmlld3MudW52ZXJpZmllZFVzZXIgPSBCYWNrYm9uZS5WaWV3LmV4dGVuZCh7XG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBkYXRhO1xuICAgICAgICB0aGlzLnJlc2VuZFNpZ251cEVtYWlsTW9kZWwgPSBuZXcgYXBwLm1vZGVscy5SZXNlbmRTaWdudXBFbWFpbCgpO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbigpe1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gXy50ZW1wbGF0ZShhcHAuY3JlYXRlVGVtcGxhdGUoJ3RlbXBsYXRlcy91bnZlcmlmaWVkVXNlci50cGwnLCB7IHBlcnNvbjogdGhpcy5tb2RlbC5hdHRyaWJ1dGVzIH0pKTtcbiAgICAgICAgdGhpcy4kZWwuaHRtbCh0aGlzLnRlbXBsYXRlKHt9KSk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBldmVudHM6IHtcbiAgICAgICdjbGljayAuZGVsZXRlQnV0dG9uJyA6ICdkZWxldGUnLFxuICAgICAgJ2NsaWNrIC5yZXNlbmRCdXR0b24nIDogJ3Jlc2VuZFNpZ251cEVtYWlsJ1xuICAgIH0sXG4gICAgZGVsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgICQoJyNkZWxldGVNb2RhbCcpLmZvdW5kYXRpb24oJ3JldmVhbCcsICdvcGVuJyk7XG4gICAgICAkKGRvY3VtZW50KS5vbignb3BlbmVkLmZuZHRuLnJldmVhbCcsICcjZGVsZXRlTW9kYWxbZGF0YS1yZXZlYWxdJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICQoJyNkZWxldGVZZXMnKS5jbGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHRoYXQubW9kZWwuZGVzdHJveSgpO1xuICAgICAgICAgICAgICAkKCcjZGVsZXRlTW9kYWxbZGF0YS1yZXZlYWxdJykuZm91bmRhdGlvbigncmV2ZWFsJywgJ2Nsb3NlJyk7XG4gICAgICAgICAgICAgIG1vZGFsTGlzdGVuZXJDbGVhbnVwKCk7XG4gICAgICAgICAgfSlcbiAgICAgICAgICAkKCcjZGVsZXRlTm8nKS5jbGljayhmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgJCgnI2RlbGV0ZU1vZGFsW2RhdGEtcmV2ZWFsXScpLmZvdW5kYXRpb24oJ3JldmVhbCcsICdjbG9zZScpO1xuICAgICAgICAgICAgICBtb2RhbExpc3RlbmVyQ2xlYW51cCgpO1xuICAgICAgICAgIH0pXG4gICAgICB9KTtcblxuICAgICAgZnVuY3Rpb24gbW9kYWxMaXN0ZW5lckNsZWFudXAoKSB7XG4gICAgICAgICQoZG9jdW1lbnQpLm9mZignb3BlbmVkLmZuZHRuLnJldmVhbCcpO1xuICAgICAgICAkKCcjZGVsZXRlWWVzJykub2ZmKCdjbGljaycpO1xuICAgICAgICAkKCcjZGVsZXRlTm8nKS5vZmYoJ2NsaWNrJyk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZXNlbmRTaWdudXBFbWFpbDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB0aGlzLnJlc2VuZFNpZ251cEVtYWlsTW9kZWwuc2F2ZSh7XG4gICAgICAgICAgRW1haWw6IHRoaXMubW9kZWwuZ2V0KCdFbWFpbCcpLFxuICAgICAgICAgIFRva2VuOiB0aGlzLm1vZGVsLmdldCgnaWQnKVxuICAgICAgfSwge1xuICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKG1vZGVsLCByZXNwb25zZSkge1xuICAgICAgICAgICAgJCgnI3Jlc2VuZFNpZ251cEVtYWlsTW9kYWwnKS5mb3VuZGF0aW9uKCdyZXZlYWwnLCAnb3BlbicpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uKG1vZGVsLCByZXNwb25zZSkge1xuICAgICAgICAgICAgICAvL1NvbWUgc29ydCBvZiBlcnJvciBoYW5kbGluZyBoZXJlXG4gICAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBjb25zb2xlLmxvZygpO1xuICAgIH1cbn0pO1xuXG5cbi8qKiBXRUJQQUNLIEZPT1RFUiAqKlxuICoqIC4vc3JjL2FwcC9jbGllbnQtYXBwL3ZpZXdzL3VudmVyaWZpZWRVc2VyLmpzXG4gKiovIl0sInNvdXJjZVJvb3QiOiIifQ==");

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	eval("// NOTES:\n// - I seperated this and unverified user as I intend on putting a large amount more\n// logic in the 'verified user' view.\n\n'use strict';\n\nvar _app = __webpack_require__(6);\n\n_app.app.views.verifiedUser = Backbone.View.extend({\n    initialize: function initialize(data) {\n        this.options = data;\n    },\n    render: function render() {\n        this.template = _.template(_app.app.createTemplate('templates/verifiedUser.tpl', { person: this.model.attributes }));\n        this.$el.html(this.template({}));\n        this.delegateEvents();\n        return this;\n    },\n    events: {\n        'click .deleteButton': 'delete'\n    },\n    delete: function _delete() {\n        var that = this;\n        $('#deleteModal').foundation('reveal', 'open');\n        $(document).on('opened.fndtn.reveal', '#deleteModal[data-reveal]', function () {\n            $('#deleteYes').click(function () {\n                that.model.destroy();\n                $('#deleteModal[data-reveal]').foundation('reveal', 'close');\n                modalListenerCleanup();\n            });\n            $('#deleteNo').click(function (event) {\n                $('#deleteModal[data-reveal]').foundation('reveal', 'close');\n                modalListenerCleanup();\n            });\n        });\n\n        function modalListenerCleanup() {\n            $(document).off('opened.fndtn.reveal');\n            $('#deleteYes').off('click');\n            $('#deleteNo').off('click');\n        }\n    }\n});\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NsaWVudC1hcHAvdmlld3MvdmVyaWZpZWRVc2VyLmpzP2NhZWEiXSwibmFtZXMiOlsidmlld3MiLCJ2ZXJpZmllZFVzZXIiLCJCYWNrYm9uZSIsIlZpZXciLCJleHRlbmQiLCJpbml0aWFsaXplIiwiZGF0YSIsIm9wdGlvbnMiLCJyZW5kZXIiLCJ0ZW1wbGF0ZSIsIl8iLCJjcmVhdGVUZW1wbGF0ZSIsInBlcnNvbiIsIm1vZGVsIiwiYXR0cmlidXRlcyIsIiRlbCIsImh0bWwiLCJkZWxlZ2F0ZUV2ZW50cyIsImV2ZW50cyIsImRlbGV0ZSIsInRoYXQiLCIkIiwiZm91bmRhdGlvbiIsImRvY3VtZW50Iiwib24iLCJjbGljayIsImRlc3Ryb3kiLCJtb2RhbExpc3RlbmVyQ2xlYW51cCIsImV2ZW50Iiwib2ZmIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7O0FBQ0E7O0FBRUEsU0FBSUEsS0FBSixDQUFVQyxZQUFWLEdBQXlCQyxTQUFTQyxJQUFULENBQWNDLE1BQWQsQ0FBcUI7QUFDMUNDLGdCQUFZLG9CQUFTQyxJQUFULEVBQWU7QUFDdkIsYUFBS0MsT0FBTCxHQUFlRCxJQUFmO0FBQ0gsS0FIeUM7QUFJMUNFLFlBQVEsa0JBQVU7QUFDZCxhQUFLQyxRQUFMLEdBQWdCQyxFQUFFRCxRQUFGLENBQVcsU0FBSUUsY0FBSixDQUFtQiw0QkFBbkIsRUFBaUQsRUFBRUMsUUFBUSxLQUFLQyxLQUFMLENBQVdDLFVBQXJCLEVBQWpELENBQVgsQ0FBaEI7QUFDQSxhQUFLQyxHQUFMLENBQVNDLElBQVQsQ0FBYyxLQUFLUCxRQUFMLENBQWMsRUFBZCxDQUFkO0FBQ0EsYUFBS1EsY0FBTDtBQUNBLGVBQU8sSUFBUDtBQUNILEtBVHlDO0FBVTFDQyxZQUFRO0FBQ04sK0JBQXdCO0FBRGxCLEtBVmtDO0FBYTFDQyxZQUFRLG1CQUFXO0FBQ2pCLFlBQUlDLE9BQU8sSUFBWDtBQUNBQyxVQUFFLGNBQUYsRUFBa0JDLFVBQWxCLENBQTZCLFFBQTdCLEVBQXVDLE1BQXZDO0FBQ0FELFVBQUVFLFFBQUYsRUFBWUMsRUFBWixDQUFlLHFCQUFmLEVBQXNDLDJCQUF0QyxFQUFtRSxZQUFZO0FBQzNFSCxjQUFFLFlBQUYsRUFBZ0JJLEtBQWhCLENBQXNCLFlBQVk7QUFDOUJMLHFCQUFLUCxLQUFMLENBQVdhLE9BQVg7QUFDQUwsa0JBQUUsMkJBQUYsRUFBK0JDLFVBQS9CLENBQTBDLFFBQTFDLEVBQW9ELE9BQXBEO0FBQ0FLO0FBQ0gsYUFKRDtBQUtBTixjQUFFLFdBQUYsRUFBZUksS0FBZixDQUFxQixVQUFVRyxLQUFWLEVBQWlCO0FBQ2xDUCxrQkFBRSwyQkFBRixFQUErQkMsVUFBL0IsQ0FBMEMsUUFBMUMsRUFBb0QsT0FBcEQ7QUFDQUs7QUFDSCxhQUhEO0FBSUgsU0FWRDs7QUFZQSxpQkFBU0Esb0JBQVQsR0FBZ0M7QUFDOUJOLGNBQUVFLFFBQUYsRUFBWU0sR0FBWixDQUFnQixxQkFBaEI7QUFDQVIsY0FBRSxZQUFGLEVBQWdCUSxHQUFoQixDQUFvQixPQUFwQjtBQUNBUixjQUFFLFdBQUYsRUFBZVEsR0FBZixDQUFtQixPQUFuQjtBQUNEO0FBQ0Y7QUFqQ3lDLENBQXJCLENBQXpCIiwiZmlsZSI6IjMzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLy8gTk9URVM6XG4vLyAtIEkgc2VwZXJhdGVkIHRoaXMgYW5kIHVudmVyaWZpZWQgdXNlciBhcyBJIGludGVuZCBvbiBwdXR0aW5nIGEgbGFyZ2UgYW1vdW50IG1vcmVcbi8vIGxvZ2ljIGluIHRoZSAndmVyaWZpZWQgdXNlcicgdmlldy5cblxuJ3VzZSBzdHJpY3QnO1xuaW1wb3J0IHsgYXBwIH0gZnJvbSAnLi4vYXBwJztcblxuYXBwLnZpZXdzLnZlcmlmaWVkVXNlciA9IEJhY2tib25lLlZpZXcuZXh0ZW5kKHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IGRhdGE7XG4gICAgfSxcbiAgICByZW5kZXI6IGZ1bmN0aW9uKCl7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSBfLnRlbXBsYXRlKGFwcC5jcmVhdGVUZW1wbGF0ZSgndGVtcGxhdGVzL3ZlcmlmaWVkVXNlci50cGwnLCB7IHBlcnNvbjogdGhpcy5tb2RlbC5hdHRyaWJ1dGVzIH0pKTtcbiAgICAgICAgdGhpcy4kZWwuaHRtbCh0aGlzLnRlbXBsYXRlKHt9KSk7XG4gICAgICAgIHRoaXMuZGVsZWdhdGVFdmVudHMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBldmVudHM6IHtcbiAgICAgICdjbGljayAuZGVsZXRlQnV0dG9uJyA6ICdkZWxldGUnXG4gICAgfSxcbiAgICBkZWxldGU6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgICAgJCgnI2RlbGV0ZU1vZGFsJykuZm91bmRhdGlvbigncmV2ZWFsJywgJ29wZW4nKTtcbiAgICAgICQoZG9jdW1lbnQpLm9uKCdvcGVuZWQuZm5kdG4ucmV2ZWFsJywgJyNkZWxldGVNb2RhbFtkYXRhLXJldmVhbF0nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgJCgnI2RlbGV0ZVllcycpLmNsaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdGhhdC5tb2RlbC5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICQoJyNkZWxldGVNb2RhbFtkYXRhLXJldmVhbF0nKS5mb3VuZGF0aW9uKCdyZXZlYWwnLCAnY2xvc2UnKTtcbiAgICAgICAgICAgICAgbW9kYWxMaXN0ZW5lckNsZWFudXAoKTtcbiAgICAgICAgICB9KVxuICAgICAgICAgICQoJyNkZWxldGVObycpLmNsaWNrKGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAkKCcjZGVsZXRlTW9kYWxbZGF0YS1yZXZlYWxdJykuZm91bmRhdGlvbigncmV2ZWFsJywgJ2Nsb3NlJyk7XG4gICAgICAgICAgICAgIG1vZGFsTGlzdGVuZXJDbGVhbnVwKCk7XG4gICAgICAgICAgfSlcbiAgICAgIH0pO1xuXG4gICAgICBmdW5jdGlvbiBtb2RhbExpc3RlbmVyQ2xlYW51cCgpIHtcbiAgICAgICAgJChkb2N1bWVudCkub2ZmKCdvcGVuZWQuZm5kdG4ucmV2ZWFsJyk7XG4gICAgICAgICQoJyNkZWxldGVZZXMnKS5vZmYoJ2NsaWNrJyk7XG4gICAgICAgICQoJyNkZWxldGVObycpLm9mZignY2xpY2snKTtcbiAgICAgIH1cbiAgICB9XG59KTtcblxuXG4vKiogV0VCUEFDSyBGT09URVIgKipcbiAqKiAuL3NyYy9hcHAvY2xpZW50LWFwcC92aWV3cy92ZXJpZmllZFVzZXIuanNcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9");

/***/ }
/******/ ]);